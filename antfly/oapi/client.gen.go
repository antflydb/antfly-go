// Package oapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package oapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes = "BasicAuth.Scopes"
)

// Defines values for AggregationType.
const (
	AggregationTypeAvg              AggregationType = "avg"
	AggregationTypeCardinality      AggregationType = "cardinality"
	AggregationTypeCount            AggregationType = "count"
	AggregationTypeDateHistogram    AggregationType = "date_histogram"
	AggregationTypeDateRange        AggregationType = "date_range"
	AggregationTypeGeoDistance      AggregationType = "geo_distance"
	AggregationTypeGeohashGrid      AggregationType = "geohash_grid"
	AggregationTypeHistogram        AggregationType = "histogram"
	AggregationTypeMax              AggregationType = "max"
	AggregationTypeMin              AggregationType = "min"
	AggregationTypeRange            AggregationType = "range"
	AggregationTypeSignificantTerms AggregationType = "significant_terms"
	AggregationTypeStats            AggregationType = "stats"
	AggregationTypeSum              AggregationType = "sum"
	AggregationTypeSumsquares       AggregationType = "sumsquares"
	AggregationTypeTerms            AggregationType = "terms"
)

// Defines values for AntflyType.
const (
	AntflyTypeBlob            AntflyType = "blob"
	AntflyTypeBoolean         AntflyType = "boolean"
	AntflyTypeDatetime        AntflyType = "datetime"
	AntflyTypeEmbedding       AntflyType = "embedding"
	AntflyTypeGeopoint        AntflyType = "geopoint"
	AntflyTypeGeoshape        AntflyType = "geoshape"
	AntflyTypeHtml            AntflyType = "html"
	AntflyTypeKeyword         AntflyType = "keyword"
	AntflyTypeLink            AntflyType = "link"
	AntflyTypeNumeric         AntflyType = "numeric"
	AntflyTypeSearchAsYouType AntflyType = "search_as_you_type"
	AntflyTypeText            AntflyType = "text"
)

// Defines values for BingSearchConfigFreshness.
const (
	BingSearchConfigFreshnessDay   BingSearchConfigFreshness = "Day"
	BingSearchConfigFreshnessMonth BingSearchConfigFreshness = "Month"
	BingSearchConfigFreshnessWeek  BingSearchConfigFreshness = "Week"
)

// Defines values for BraveSearchConfigFreshness.
const (
	BraveSearchConfigFreshnessPd BraveSearchConfigFreshness = "pd"
	BraveSearchConfigFreshnessPm BraveSearchConfigFreshness = "pm"
	BraveSearchConfigFreshnessPw BraveSearchConfigFreshness = "pw"
	BraveSearchConfigFreshnessPy BraveSearchConfigFreshness = "py"
)

// Defines values for CalendarInterval.
const (
	CalendarIntervalDay     CalendarInterval = "day"
	CalendarIntervalHour    CalendarInterval = "hour"
	CalendarIntervalMinute  CalendarInterval = "minute"
	CalendarIntervalMonth   CalendarInterval = "month"
	CalendarIntervalQuarter CalendarInterval = "quarter"
	CalendarIntervalWeek    CalendarInterval = "week"
	CalendarIntervalYear    CalendarInterval = "year"
)

// Defines values for ChainCondition.
const (
	ChainConditionAlways      ChainCondition = "always"
	ChainConditionOnError     ChainCondition = "on_error"
	ChainConditionOnRateLimit ChainCondition = "on_rate_limit"
	ChainConditionOnTimeout   ChainCondition = "on_timeout"
)

// Defines values for ChatMessageRole.
const (
	ChatMessageRoleAssistant ChatMessageRole = "assistant"
	ChatMessageRoleSystem    ChatMessageRole = "system"
	ChatMessageRoleTool      ChatMessageRole = "tool"
	ChatMessageRoleUser      ChatMessageRole = "user"
)

// Defines values for ChatToolName.
const (
	ChatToolNameAddFilter        ChatToolName = "add_filter"
	ChatToolNameAskClarification ChatToolName = "ask_clarification"
	ChatToolNameFetch            ChatToolName = "fetch"
	ChatToolNameFullTextSearch   ChatToolName = "full_text_search"
	ChatToolNameGraphSearch      ChatToolName = "graph_search"
	ChatToolNameSearch           ChatToolName = "search"
	ChatToolNameSemanticSearch   ChatToolName = "semantic_search"
	ChatToolNameTreeSearch       ChatToolName = "tree_search"
	ChatToolNameWebsearch        ChatToolName = "websearch"
)

// Defines values for ChunkerProvider.
const (
	ChunkerProviderAntfly  ChunkerProvider = "antfly"
	ChunkerProviderMock    ChunkerProvider = "mock"
	ChunkerProviderTermite ChunkerProvider = "termite"
)

// Defines values for ClusterBackupResponseStatus.
const (
	ClusterBackupResponseStatusCompleted ClusterBackupResponseStatus = "completed"
	ClusterBackupResponseStatusFailed    ClusterBackupResponseStatus = "failed"
	ClusterBackupResponseStatusPartial   ClusterBackupResponseStatus = "partial"
)

// Defines values for ClusterHealth.
const (
	ClusterHealthDegraded  ClusterHealth = "degraded"
	ClusterHealthError     ClusterHealth = "error"
	ClusterHealthHealthy   ClusterHealth = "healthy"
	ClusterHealthUnhealthy ClusterHealth = "unhealthy"
	ClusterHealthUnknown   ClusterHealth = "unknown"
)

// Defines values for ClusterRestoreRequestRestoreMode.
const (
	ClusterRestoreRequestRestoreModeFailIfExists ClusterRestoreRequestRestoreMode = "fail_if_exists"
	ClusterRestoreRequestRestoreModeOverwrite    ClusterRestoreRequestRestoreMode = "overwrite"
	ClusterRestoreRequestRestoreModeSkipIfExists ClusterRestoreRequestRestoreMode = "skip_if_exists"
)

// Defines values for ClusterRestoreResponseStatus.
const (
	ClusterRestoreResponseStatusFailed    ClusterRestoreResponseStatus = "failed"
	ClusterRestoreResponseStatusPartial   ClusterRestoreResponseStatus = "partial"
	ClusterRestoreResponseStatusTriggered ClusterRestoreResponseStatus = "triggered"
)

// Defines values for CohereEmbedderConfigInputType.
const (
	CohereEmbedderConfigInputTypeClassification CohereEmbedderConfigInputType = "classification"
	CohereEmbedderConfigInputTypeClustering     CohereEmbedderConfigInputType = "clustering"
	CohereEmbedderConfigInputTypeSearchDocument CohereEmbedderConfigInputType = "search_document"
	CohereEmbedderConfigInputTypeSearchQuery    CohereEmbedderConfigInputType = "search_query"
)

// Defines values for CohereEmbedderConfigTruncate.
const (
	CohereEmbedderConfigTruncateEND   CohereEmbedderConfigTruncate = "END"
	CohereEmbedderConfigTruncateNONE  CohereEmbedderConfigTruncate = "NONE"
	CohereEmbedderConfigTruncateSTART CohereEmbedderConfigTruncate = "START"
)

// Defines values for DistanceUnit.
const (
	DistanceUnitFt DistanceUnit = "ft"
	DistanceUnitKm DistanceUnit = "km"
	DistanceUnitM  DistanceUnit = "m"
	DistanceUnitMi DistanceUnit = "mi"
	DistanceUnitYd DistanceUnit = "yd"
)

// Defines values for DynamicTemplateMatchMappingType.
const (
	DynamicTemplateMatchMappingTypeBoolean DynamicTemplateMatchMappingType = "boolean"
	DynamicTemplateMatchMappingTypeDate    DynamicTemplateMatchMappingType = "date"
	DynamicTemplateMatchMappingTypeNumber  DynamicTemplateMatchMappingType = "number"
	DynamicTemplateMatchMappingTypeObject  DynamicTemplateMatchMappingType = "object"
	DynamicTemplateMatchMappingTypeString  DynamicTemplateMatchMappingType = "string"
)

// Defines values for EdgeDirection.
const (
	EdgeDirectionBoth EdgeDirection = "both"
	EdgeDirectionIn   EdgeDirection = "in"
	EdgeDirectionOut  EdgeDirection = "out"
)

// Defines values for EdgeTypeConfigTopology.
const (
	EdgeTypeConfigTopologyGraph EdgeTypeConfigTopology = "graph"
	EdgeTypeConfigTopologyTree  EdgeTypeConfigTopology = "tree"
)

// Defines values for EmbedderProvider.
const (
	EmbedderProviderAntfly     EmbedderProvider = "antfly"
	EmbedderProviderBedrock    EmbedderProvider = "bedrock"
	EmbedderProviderCohere     EmbedderProvider = "cohere"
	EmbedderProviderGemini     EmbedderProvider = "gemini"
	EmbedderProviderMock       EmbedderProvider = "mock"
	EmbedderProviderOllama     EmbedderProvider = "ollama"
	EmbedderProviderOpenai     EmbedderProvider = "openai"
	EmbedderProviderOpenrouter EmbedderProvider = "openrouter"
	EmbedderProviderTermite    EmbedderProvider = "termite"
	EmbedderProviderVertex     EmbedderProvider = "vertex"
)

// Defines values for EvaluatorName.
const (
	EvaluatorNameCitationQuality EvaluatorName = "citation_quality"
	EvaluatorNameCoherence       EvaluatorName = "coherence"
	EvaluatorNameCompleteness    EvaluatorName = "completeness"
	EvaluatorNameCorrectness     EvaluatorName = "correctness"
	EvaluatorNameFaithfulness    EvaluatorName = "faithfulness"
	EvaluatorNameHelpfulness     EvaluatorName = "helpfulness"
	EvaluatorNameMap             EvaluatorName = "map"
	EvaluatorNameMrr             EvaluatorName = "mrr"
	EvaluatorNameNdcg            EvaluatorName = "ndcg"
	EvaluatorNamePrecision       EvaluatorName = "precision"
	EvaluatorNameRecall          EvaluatorName = "recall"
	EvaluatorNameRelevance       EvaluatorName = "relevance"
	EvaluatorNameSafety          EvaluatorName = "safety"
)

// Defines values for FailedOperationOperation.
const (
	FailedOperationOperationDelete FailedOperationOperation = "delete"
	FailedOperationOperationUpsert FailedOperationOperation = "upsert"
)

// Defines values for FilterSpecOperator.
const (
	FilterSpecOperatorContains FilterSpecOperator = "contains"
	FilterSpecOperatorEq       FilterSpecOperator = "eq"
	FilterSpecOperatorGt       FilterSpecOperator = "gt"
	FilterSpecOperatorGte      FilterSpecOperator = "gte"
	FilterSpecOperatorIn       FilterSpecOperator = "in"
	FilterSpecOperatorLt       FilterSpecOperator = "lt"
	FilterSpecOperatorLte      FilterSpecOperator = "lte"
	FilterSpecOperatorNe       FilterSpecOperator = "ne"
	FilterSpecOperatorPrefix   FilterSpecOperator = "prefix"
	FilterSpecOperatorRange    FilterSpecOperator = "range"
)

// Defines values for ForeignSourceType.
const (
	ForeignSourceTypePostgres ForeignSourceType = "postgres"
)

// Defines values for Fuzziness1.
const (
	Fuzziness1Auto Fuzziness1 = "auto"
)

// Defines values for GeneratorProvider.
const (
	GeneratorProviderAnthropic  GeneratorProvider = "anthropic"
	GeneratorProviderBedrock    GeneratorProvider = "bedrock"
	GeneratorProviderCohere     GeneratorProvider = "cohere"
	GeneratorProviderGemini     GeneratorProvider = "gemini"
	GeneratorProviderMock       GeneratorProvider = "mock"
	GeneratorProviderOllama     GeneratorProvider = "ollama"
	GeneratorProviderOpenai     GeneratorProvider = "openai"
	GeneratorProviderOpenrouter GeneratorProvider = "openrouter"
	GeneratorProviderTermite    GeneratorProvider = "termite"
	GeneratorProviderVertex     GeneratorProvider = "vertex"
)

// Defines values for GeoShapeGeometryRelation.
const (
	GeoShapeGeometryRelationContains   GeoShapeGeometryRelation = "contains"
	GeoShapeGeometryRelationIntersects GeoShapeGeometryRelation = "intersects"
	GeoShapeGeometryRelationWithin     GeoShapeGeometryRelation = "within"
)

// Defines values for GoogleSearchConfigSearchType.
const (
	GoogleSearchConfigSearchTypeImage GoogleSearchConfigSearchType = "image"
	GoogleSearchConfigSearchTypeWeb   GoogleSearchConfigSearchType = "web"
)

// Defines values for GraphQueryType.
const (
	GraphQueryTypeKShortestPaths GraphQueryType = "k_shortest_paths"
	GraphQueryTypeNeighbors      GraphQueryType = "neighbors"
	GraphQueryTypePattern        GraphQueryType = "pattern"
	GraphQueryTypeShortestPath   GraphQueryType = "shortest_path"
	GraphQueryTypeTraverse       GraphQueryType = "traverse"
)

// Defines values for IndexType.
const (
	IndexTypeAknnV0     IndexType = "aknn_v0"
	IndexTypeFullTextV0 IndexType = "full_text_v0"
	IndexTypeGraphV0    IndexType = "graph_v0"
)

// Defines values for JoinOperator.
const (
	JoinOperatorEq  JoinOperator = "eq"
	JoinOperatorGt  JoinOperator = "gt"
	JoinOperatorGte JoinOperator = "gte"
	JoinOperatorLt  JoinOperator = "lt"
	JoinOperatorLte JoinOperator = "lte"
	JoinOperatorNeq JoinOperator = "neq"
)

// Defines values for JoinStrategy.
const (
	JoinStrategyBroadcast   JoinStrategy = "broadcast"
	JoinStrategyIndexLookup JoinStrategy = "index_lookup"
	JoinStrategyShuffle     JoinStrategy = "shuffle"
)

// Defines values for JoinType.
const (
	JoinTypeInner JoinType = "inner"
	JoinTypeLeft  JoinType = "left"
	JoinTypeRight JoinType = "right"
)

// Defines values for LinearMergePageStatus.
const (
	LinearMergePageStatusError   LinearMergePageStatus = "error"
	LinearMergePageStatusPartial LinearMergePageStatus = "partial"
	LinearMergePageStatusSuccess LinearMergePageStatus = "success"
)

// Defines values for MatchQueryOperator.
const (
	MatchQueryOperatorAnd MatchQueryOperator = "and"
	MatchQueryOperatorOr  MatchQueryOperator = "or"
)

// Defines values for MergeStrategy.
const (
	MergeStrategyFailover MergeStrategy = "failover"
	MergeStrategyRrf      MergeStrategy = "rrf"
	MergeStrategyRsf      MergeStrategy = "rsf"
)

// Defines values for PathFindWeightMode.
const (
	PathFindWeightModeMaxWeight PathFindWeightMode = "max_weight"
	PathFindWeightModeMinHops   PathFindWeightMode = "min_hops"
	PathFindWeightModeMinWeight PathFindWeightMode = "min_weight"
)

// Defines values for PathWeightMode.
const (
	PathWeightModeMaxWeight PathWeightMode = "max_weight"
	PathWeightModeMinHops   PathWeightMode = "min_hops"
	PathWeightModeMinWeight PathWeightMode = "min_weight"
)

// Defines values for PermissionType.
const (
	PermissionTypeAdmin PermissionType = "admin"
	PermissionTypeRead  PermissionType = "read"
	PermissionTypeWrite PermissionType = "write"
)

// Defines values for QueryRequestExpandStrategy.
const (
	QueryRequestExpandStrategyIntersection QueryRequestExpandStrategy = "intersection"
	QueryRequestExpandStrategyUnion        QueryRequestExpandStrategy = "union"
)

// Defines values for QueryStrategy.
const (
	QueryStrategyDecompose QueryStrategy = "decompose"
	QueryStrategyHyde      QueryStrategy = "hyde"
	QueryStrategySimple    QueryStrategy = "simple"
	QueryStrategyStepBack  QueryStrategy = "step_back"
)

// Defines values for RerankerProvider.
const (
	RerankerProviderCohere  RerankerProvider = "cohere"
	RerankerProviderOllama  RerankerProvider = "ollama"
	RerankerProviderTermite RerankerProvider = "termite"
	RerankerProviderVertex  RerankerProvider = "vertex"
)

// Defines values for ResourceType.
const (
	ResourceTypeAsterisk ResourceType = "*"
	ResourceTypeTable    ResourceType = "table"
	ResourceTypeUser     ResourceType = "user"
)

// Defines values for RetrievalAgentState.
const (
	RetrievalAgentStateAwaitingClarification RetrievalAgentState = "awaiting_clarification"
	RetrievalAgentStateComplete              RetrievalAgentState = "complete"
	RetrievalAgentStateToolCalling           RetrievalAgentState = "tool_calling"
)

// Defines values for RetrievalQueryRequestExpandStrategy.
const (
	RetrievalQueryRequestExpandStrategyIntersection RetrievalQueryRequestExpandStrategy = "intersection"
	RetrievalQueryRequestExpandStrategyUnion        RetrievalQueryRequestExpandStrategy = "union"
)

// Defines values for RetrievalStrategy.
const (
	RetrievalStrategyBm25     RetrievalStrategy = "bm25"
	RetrievalStrategyGraph    RetrievalStrategy = "graph"
	RetrievalStrategyHybrid   RetrievalStrategy = "hybrid"
	RetrievalStrategyMetadata RetrievalStrategy = "metadata"
	RetrievalStrategySemantic RetrievalStrategy = "semantic"
	RetrievalStrategyTree     RetrievalStrategy = "tree"
)

// Defines values for RouteType.
const (
	RouteTypeQuestion RouteType = "question"
	RouteTypeSearch   RouteType = "search"
)

// Defines values for SemanticQueryMode.
const (
	SemanticQueryModeHypothetical SemanticQueryMode = "hypothetical"
	SemanticQueryModeRewrite      SemanticQueryMode = "rewrite"
)

// Defines values for SerperSearchConfigSearchType.
const (
	SerperSearchConfigSearchTypeImages   SerperSearchConfigSearchType = "images"
	SerperSearchConfigSearchTypeNews     SerperSearchConfigSearchType = "news"
	SerperSearchConfigSearchTypePlaces   SerperSearchConfigSearchType = "places"
	SerperSearchConfigSearchTypeSearch   SerperSearchConfigSearchType = "search"
	SerperSearchConfigSearchTypeShopping SerperSearchConfigSearchType = "shopping"
)

// Defines values for SerperSearchConfigTimePeriod.
const (
	SerperSearchConfigTimePeriodD SerperSearchConfigTimePeriod = "d"
	SerperSearchConfigTimePeriodM SerperSearchConfigTimePeriod = "m"
	SerperSearchConfigTimePeriodW SerperSearchConfigTimePeriod = "w"
	SerperSearchConfigTimePeriodY SerperSearchConfigTimePeriod = "y"
)

// Defines values for SignificanceAlgorithm.
const (
	SignificanceAlgorithmChiSquared        SignificanceAlgorithm = "chi_squared"
	SignificanceAlgorithmJlh               SignificanceAlgorithm = "jlh"
	SignificanceAlgorithmMutualInformation SignificanceAlgorithm = "mutual_information"
	SignificanceAlgorithmPercentage        SignificanceAlgorithm = "percentage"
)

// Defines values for SyncLevel.
const (
	SyncLevelAknn        SyncLevel = "aknn"
	SyncLevelEnrichments SyncLevel = "enrichments"
	SyncLevelFullText    SyncLevel = "full_text"
	SyncLevelPropose     SyncLevel = "propose"
	SyncLevelWrite       SyncLevel = "write"
)

// Defines values for TableBackupStatusStatus.
const (
	TableBackupStatusStatusCompleted TableBackupStatusStatus = "completed"
	TableBackupStatusStatusFailed    TableBackupStatusStatus = "failed"
	TableBackupStatusStatusSkipped   TableBackupStatusStatus = "skipped"
)

// Defines values for TableRestoreStatusStatus.
const (
	TableRestoreStatusStatusFailed    TableRestoreStatusStatus = "failed"
	TableRestoreStatusStatusSkipped   TableRestoreStatusStatus = "skipped"
	TableRestoreStatusStatusTriggered TableRestoreStatusStatus = "triggered"
)

// Defines values for TavilySearchConfigSearchDepth.
const (
	TavilySearchConfigSearchDepthAdvanced TavilySearchConfigSearchDepth = "advanced"
	TavilySearchConfigSearchDepthBasic    TavilySearchConfigSearchDepth = "basic"
)

// Defines values for TransactionCommitResponseStatus.
const (
	TransactionCommitResponseStatusAborted   TransactionCommitResponseStatus = "aborted"
	TransactionCommitResponseStatusCommitted TransactionCommitResponseStatus = "committed"
)

// Defines values for TransformOpType.
const (
	TransformOpTypeAddToSet    TransformOpType = "$addToSet"
	TransformOpTypeCurrentDate TransformOpType = "$currentDate"
	TransformOpTypeInc         TransformOpType = "$inc"
	TransformOpTypeMax         TransformOpType = "$max"
	TransformOpTypeMin         TransformOpType = "$min"
	TransformOpTypeMul         TransformOpType = "$mul"
	TransformOpTypePop         TransformOpType = "$pop"
	TransformOpTypePull        TransformOpType = "$pull"
	TransformOpTypePush        TransformOpType = "$push"
	TransformOpTypeRename      TransformOpType = "$rename"
	TransformOpTypeSet         TransformOpType = "$set"
	TransformOpTypeUnset       TransformOpType = "$unset"
)

// Defines values for WebSearchProvider.
const (
	WebSearchProviderBing       WebSearchProvider = "bing"
	WebSearchProviderBrave      WebSearchProvider = "brave"
	WebSearchProviderDuckduckgo WebSearchProvider = "duckduckgo"
	WebSearchProviderGoogle     WebSearchProvider = "google"
	WebSearchProviderSerper     WebSearchProvider = "serper"
	WebSearchProviderTavily     WebSearchProvider = "tavily"
)

// Defines values for SchemasAntflyType.
const (
	SchemasAntflyTypeBlob            SchemasAntflyType = "blob"
	SchemasAntflyTypeBoolean         SchemasAntflyType = "boolean"
	SchemasAntflyTypeDatetime        SchemasAntflyType = "datetime"
	SchemasAntflyTypeEmbedding       SchemasAntflyType = "embedding"
	SchemasAntflyTypeGeopoint        SchemasAntflyType = "geopoint"
	SchemasAntflyTypeGeoshape        SchemasAntflyType = "geoshape"
	SchemasAntflyTypeHtml            SchemasAntflyType = "html"
	SchemasAntflyTypeKeyword         SchemasAntflyType = "keyword"
	SchemasAntflyTypeLink            SchemasAntflyType = "link"
	SchemasAntflyTypeNumeric         SchemasAntflyType = "numeric"
	SchemasAntflyTypeSearchAsYouType SchemasAntflyType = "search_as_you_type"
	SchemasAntflyTypeText            SchemasAntflyType = "text"
)

// AggregationBucket defines model for AggregationBucket.
type AggregationBucket struct {
	// BgCount Background count (for significant_terms)
	BgCount *int `json:"bg_count,omitempty"`

	// DocCount Number of documents in this bucket
	DocCount int `json:"doc_count"`

	// From Lower bound for range buckets
	From *float64 `json:"from,omitempty"`

	// FromAsString Formatted lower bound
	FromAsString *string `json:"from_as_string,omitempty"`

	// Key Bucket key (term, range name, date, etc.)
	Key string `json:"key"`

	// KeyAsString Formatted key for display (e.g., formatted dates)
	KeyAsString *string `json:"key_as_string,omitempty"`

	// Score Significance score (for significant_terms)
	Score *float64 `json:"score,omitempty"`

	// SubAggregations Results of nested sub-aggregations
	SubAggregations map[string]AggregationResult `json:"sub_aggregations,omitempty,omitzero"`

	// To Upper bound for range buckets
	To *float64 `json:"to,omitempty"`

	// ToAsString Formatted upper bound
	ToAsString *string `json:"to_as_string,omitempty"`
}

// AggregationDateRange defines model for AggregationDateRange.
type AggregationDateRange struct {
	// From Start date (ISO 8601 or relative like "now-7d")
	From *string `json:"from,omitempty"`

	// Name Name of the date range bucket
	Name string `json:"name"`

	// To End date (ISO 8601 or relative like "now")
	To *string `json:"to,omitempty"`
}

// AggregationRange defines model for AggregationRange.
type AggregationRange struct {
	// From Lower bound (inclusive)
	From *float64 `json:"from,omitempty"`

	// Name Name of the range bucket
	Name string `json:"name"`

	// To Upper bound (exclusive)
	To *float64 `json:"to,omitempty"`
}

// AggregationRequest defines model for AggregationRequest.
type AggregationRequest struct {
	// Algorithm Significance algorithm for significant_terms aggregations
	Algorithm *SignificanceAlgorithm `json:"algorithm,omitempty"`

	// BackgroundFilter Background filter for significant_terms aggregations
	BackgroundFilter json.RawMessage `json:"background_filter,omitempty,omitzero"`

	// CalendarInterval Calendar-aware interval for date_histogram aggregations
	CalendarInterval *CalendarInterval `json:"calendar_interval,omitempty"`

	// DateRanges Date ranges for date_range aggregations
	DateRanges []AggregationDateRange `json:"date_ranges,omitempty,omitzero"`

	// DistanceRanges Distance ranges for geo_distance aggregations
	DistanceRanges []DistanceRange `json:"distance_ranges,omitempty,omitzero"`

	// Field Field to aggregate on
	Field string `json:"field"`

	// Interval Fixed interval for histogram aggregations
	Interval *float64 `json:"interval,omitempty"`

	// MinDocCount Minimum document count for a bucket to be included
	MinDocCount *int `json:"min_doc_count,omitempty"`

	// Origin Origin for geohash_grid aggregation (format: "lat,lon")
	// Example: "37.7749,-122.4194"
	Origin *string `json:"origin,omitempty"`

	// Precision Geohash precision (1-12) for geohash_grid aggregations
	Precision *int `json:"precision,omitempty"`

	// Ranges Ranges for range aggregations
	Ranges []AggregationRange `json:"ranges,omitempty,omitzero"`

	// Size Maximum number of buckets to return (for bucketing aggregations)
	Size *int `json:"size,omitempty"`

	// SubAggregations Nested sub-aggregations
	SubAggregations map[string]AggregationRequest `json:"sub_aggregations,omitempty,omitzero"`

	// Type Type of aggregation to compute:
	// - Metrics: sum, avg, min, max, count, sumsquares, stats, cardinality
	// - Bucketing: terms, range, date_range, histogram, date_histogram
	// - Geo: geohash_grid, geo_distance
	// - Analytics: significant_terms
	Type AggregationType `json:"type"`

	// Unit Distance unit for geo_distance aggregations
	Unit *DistanceUnit `json:"unit,omitempty"`
}

// AggregationResult defines model for AggregationResult.
type AggregationResult struct {
	// Avg Average for stats aggregations
	Avg *float64 `json:"avg,omitempty"`

	// Buckets Buckets for bucketing aggregations (terms, range, histogram, etc.)
	Buckets []AggregationBucket `json:"buckets,omitempty,omitzero"`

	// Count Document count for stats aggregations
	Count *int `json:"count,omitempty"`

	// Max Maximum value for stats aggregations
	Max *float64 `json:"max,omitempty"`

	// Min Minimum value for stats aggregations
	Min *float64 `json:"min,omitempty"`

	// StdDeviation Standard deviation for stats aggregations
	StdDeviation *float64 `json:"std_deviation,omitempty"`

	// Sum Sum for stats aggregations
	Sum *float64 `json:"sum,omitempty"`

	// SumOfSquares Sum of squares for stats aggregations
	SumOfSquares *float64 `json:"sum_of_squares,omitempty"`

	// Value Single value for metric aggregations (sum, avg, min, max, count, cardinality)
	Value *float64 `json:"value,omitempty"`

	// Variance Variance for stats aggregations
	Variance *float64 `json:"variance,omitempty"`
}

// AggregationType Type of aggregation to compute:
// - Metrics: sum, avg, min, max, count, sumsquares, stats, cardinality
// - Bucketing: terms, range, date_range, histogram, date_histogram
// - Geo: geohash_grid, geo_distance
// - Analytics: significant_terms
type AggregationType string

// Analyses defines model for Analyses.
type Analyses struct {
	Pca  bool `json:"pca,omitempty,omitzero"`
	Tsne bool `json:"tsne,omitempty,omitzero"`
}

// AnalysesResult defines model for AnalysesResult.
type AnalysesResult struct {
	Pca  []float64 `json:"pca,omitempty,omitzero"`
	Tsne []float64 `json:"tsne,omitempty,omitzero"`
}

// AnswerAgentRequest DEPRECATED: Use RetrievalAgentRequest instead.
// Request for the answer agent. Accepts the old request format and
// internally delegates to the retrieval agent.
type AnswerAgentRequest struct {
	// AgentKnowledge Domain-specific knowledge for the agent
	AgentKnowledge string `json:"agent_knowledge,omitempty,omitzero"`

	// Chain Chain of generators
	Chain []ChainLink `json:"chain,omitempty,omitzero"`

	// Eval Configuration for inline evaluation of query results.
	// Add to RAGRequest, QueryRequest, or AnswerAgentRequest.
	Eval EvalConfig `json:"eval,omitempty,omitzero"`

	// Generator A unified configuration for a generative AI provider.
	//
	// Generators can be configured with custom prompts using templates. Templates use
	// Handlebars syntax and support various built-in helpers for formatting and data manipulation.
	//
	// **Template System:**
	// - **Syntax**: Handlebars templating (https://handlebarsjs.com/guide/)
	// - **Caching**: Templates are automatically cached with configurable TTL (default: 5 minutes)
	// - **Context**: Templates receive the full context data passed to the generator
	//
	// **Built-in Helpers:**
	//
	// 1. **scrubHtml** - Remove script/style tags and extract clean text from HTML
	//    ```handlebars
	//    {{scrubHtml html_content}}
	//    ```
	//    - Removes `<script>` and `<style>` tags
	//    - Adds newlines after block elements (p, div, h1-h6, li, etc.)
	//    - Returns plain text with preserved readability
	//    - Useful for cleaning web content before summarization
	//
	// 2. **eq** - Equality comparison for conditionals
	//    ```handlebars
	//    {{#if (eq status "active")}}Active{{/if}}
	//    {{#if (eq @key "special")}}Special field{{/if}}
	//    ```
	//    - Use in `{{#if}}` blocks for conditional logic
	//    - Compares any two values for equality
	//
	// 3. **media** - GenKit dotprompt media directive for multimodal content
	//    ```handlebars
	//    {{media url=imageDataURI}}
	//    {{media url=this.image_url}}
	//    {{media url="https://example.com/image.jpg"}}
	//    {{media url="s3://endpoint/bucket/image.png"}}
	//    {{media url="file:///path/to/image.jpg"}}
	//    ```
	//
	//    **Supported URL Schemes:**
	//    - `data:` - Base64 encoded data URIs (e.g., `data:image/jpeg;base64,...`)
	//    - `http://` / `https://` - Web URLs with automatic content type detection
	//    - `file://` - Local filesystem paths
	//    - `s3://` - S3-compatible storage (format: `s3://endpoint/bucket/key`)
	//
	//    **Automatic Content Processing:**
	//    - **Images**: Downloaded, resized (if needed), converted to data URIs
	//    - **PDFs**: Text extracted or first page rendered as image
	//    - **HTML**: Readable text extracted using Mozilla Readability
	//
	//    **Security Controls:**
	//    Downloads are protected by content security settings (see Configuration Reference):
	//    - Allowed host whitelist
	//    - Private IP blocking (prevents SSRF attacks)
	//    - Download size limits (default: 100MB)
	//    - Download timeouts (default: 30s)
	//    - Image dimension limits (default: 2048px, auto-resized)
	//
	//    See: https://antfly.io/docs/configuration#security--cors
	//
	// 4. **encodeToon** - Encode data in TOON format (Token-Oriented Object Notation)
	//    ```handlebars
	//    {{encodeToon this.fields}}
	//    {{encodeToon this.fields lengthMarker=false indent=4}}
	//    {{encodeToon this.fields delimiter="\t"}}
	//    ```
	//
	//    **What is TOON?**
	//    TOON is a compact, human-readable format designed for passing structured data to LLMs.
	//    It provides **30-60% token reduction** compared to JSON while maintaining high LLM
	//    comprehension accuracy.
	//
	//    **Key Features:**
	//    - Compact syntax using `:` for key-value pairs
	//    - Array length markers: `tags[#3]: ai,search,ml`
	//    - Tabular format for uniform data structures
	//    - Optimized for LLM parsing and understanding
	//    - Maintains human readability
	//
	//    **Benefits:**
	//    - **Lower API costs** - Reduced token usage means lower LLM API costs
	//    - **Faster responses** - Less tokens to process
	//    - **More context** - Fit more documents within token limits
	//
	//    **Options:**
	//    - `lengthMarker` (bool): Add # prefix to array counts like `[#3]` (default: true)
	//    - `indent` (int): Indentation spacing for nested objects (default: 2)
	//    - `delimiter` (string): Field separator for tabular arrays (default: none, use `"\t"` for tabs)
	//
	//    **Example output:**
	//    ```
	//    title: Introduction to Vector Search
	//    author: Jane Doe
	//    tags[#3]: ai,search,ml
	//    metadata:
	//      edition: 2
	//      pages: 450
	//    ```
	//
	//    **Default in RAG:** TOON is the default format for document rendering in RAG queries.
	//
	//    **References:**
	//    - TOON Specification: https://github.com/toon-format/toon
	//    - Go Implementation: https://github.com/alpkeskin/gotoon
	//
	// **Template Examples:**
	//
	// RAG summarization with document references:
	// ```handlebars
	// Based on these documents, provide a comprehensive summary:
	//
	// {{#each documents}}
	// Document {{this.id}}:
	// {{scrubHtml this.content}}
	//
	// {{/each}}
	//
	// Valid document IDs: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
	// ```
	//
	// Conditional formatting:
	// ```handlebars
	// {{#if system_prompt}}System: {{system_prompt}}{{/if}}
	//
	// User Query: {{query}}
	//
	// {{#if context}}
	// Context:
	// {{#each context}}
	// - {{this}}
	// {{/each}}
	// {{/if}}
	// ```
	//
	// Multimodal prompt with images:
	// ```handlebars
	// Analyze this image:
	// {{media url=image_url}}
	//
	// Focus on: {{focus_area}}
	// ```
	//
	// Structured data encoding:
	// ```handlebars
	// User Profile:
	// {{encodeToon user_data indent=2 lengthMarker=true}}
	//
	// Please analyze this profile.
	// ```
	//
	// **Common Use Cases:**
	// - **RAG (Retrieval-Augmented Generation)**: Format retrieved documents with citations
	// - **Summarization**: Clean HTML content and structure summaries
	// - **Query Classification**: Format queries with metadata for better classification
	// - **Multimodal**: Include images/audio/video in prompts
	// - **Data Formatting**: Convert structured data to readable text
	//
	// **Best Practices:**
	// - Keep templates simple - complex logic belongs in application code
	// - Use clear, descriptive field names in context
	// - Handle missing fields gracefully (templates use "missingkey=zero" by default)
	// - Test templates with representative data before production use
	Generator GeneratorConfig `json:"generator,omitempty,omitzero"`

	// MaxContextTokens Maximum tokens for document context
	MaxContextTokens int `json:"max_context_tokens,omitempty,omitzero"`

	// Queries Queries to execute. Each query specifies its own table.
	Queries []QueryRequest `json:"queries"`

	// Query User's natural language query
	Query string `json:"query"`

	// ReserveTokens Tokens to reserve for overhead
	ReserveTokens int `json:"reserve_tokens,omitempty,omitzero"`

	// Steps DEPRECATED: Use RetrievalAgentSteps instead.
	// Configuration for the answer agent's pipeline steps.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Steps AnswerAgentSteps `json:"steps,omitempty,omitzero"`

	// WithStreaming DEPRECATED: Use stream on RetrievalAgentRequest instead.
	// Enable SSE streaming vs JSON response.
	WithStreaming bool `json:"with_streaming,omitempty,omitzero"`

	// WithoutGeneration DEPRECATED: Omit steps.generation on RetrievalAgentRequest instead.
	// If true, skip the generation step.
	WithoutGeneration bool `json:"without_generation,omitempty,omitzero"`
}

// AnswerAgentResult DEPRECATED: Use RetrievalAgentResult instead.
// Result from the answer agent.
type AnswerAgentResult struct {
	// Answer DEPRECATED: Use generation on RetrievalAgentResult instead.
	// Generated answer in markdown format.
	Answer string `json:"answer,omitempty,omitzero"`

	// AnswerConfidence DEPRECATED: Use generation_confidence on RetrievalAgentResult instead.
	// Confidence in the generated answer.
	AnswerConfidence float32 `json:"answer_confidence,omitempty,omitzero"`

	// ClassificationTransformation Query classification and transformation result combining all query enhancements including strategy selection and semantic optimization
	ClassificationTransformation ClassificationTransformationResult `json:"classification_transformation,omitempty,omitzero"`

	// ContextRelevance Relevance of retrieved documents to the query
	ContextRelevance float32 `json:"context_relevance,omitempty,omitzero"`

	// EvalResult Complete evaluation result
	EvalResult EvalResult `json:"eval_result,omitempty,omitzero"`

	// FollowupQuestions Suggested follow-up questions
	FollowupQuestions []string `json:"followup_questions,omitempty,omitzero"`

	// QueryResults DEPRECATED: Use hits on RetrievalAgentResult instead.
	// Query results grouped by table.
	QueryResults []QueryResult `json:"query_results,omitempty,omitzero"`
}

// AnswerAgentSteps DEPRECATED: Use RetrievalAgentSteps instead.
// Configuration for the answer agent's pipeline steps.
type AnswerAgentSteps struct {
	// Answer Configuration for the generation step. This step generates the final
	// response from retrieved documents using the reasoning as context.
	Answer GenerationStepConfig `json:"answer,omitempty,omitzero"`

	// Classification Configuration for the classification step. This step analyzes the query,
	// selects the optimal retrieval strategy, and generates semantic transformations.
	Classification ClassificationStepConfig `json:"classification,omitempty,omitzero"`

	// Confidence Configuration for confidence assessment. Evaluates answer quality and
	// resource relevance. Can use a model calibrated for scoring tasks.
	Confidence ConfidenceStepConfig `json:"confidence,omitempty,omitzero"`

	// Followup Configuration for generating follow-up questions. Uses a separate generator
	// call which can use a cheaper/faster model.
	Followup FollowupStepConfig `json:"followup,omitempty,omitzero"`
}

// AntflyChunkerConfig Per-request configuration for chunking. All fields are optional - zero/omitted values use chunker defaults.
type AntflyChunkerConfig = ChunkOptions

// AntflyEmbedderConfig Configuration for the built-in Antfly embedding provider.
//
// Uses an embedded INT8-quantized all-MiniLM-L6-v2 ONNX model bundled directly
// in the binary. No external service, API key, or model download required.
//
// **Model:** all-MiniLM-L6-v2 (384 dimensions, text-only)
//
// **Features:**
// - Zero configuration â€” works out of the box
// - No network access required
// - Pure Go inference via GoMLX
type AntflyEmbedderConfig = map[string]interface{}

// AntflyType defines model for AntflyType.
type AntflyType string

// AnthropicGeneratorConfig Configuration for the Anthropic generative AI provider (Claude models).
//
// API key via `api_key` field or `ANTHROPIC_API_KEY` environment variable.
//
// **Example Models:** claude-sonnet-4-5-20250929 (default), claude-opus-4-5-20251101, claude-3-5-haiku-20241022
//
// **Docs:** https://docs.anthropic.com/en/docs/about-claude/models/overview
type AnthropicGeneratorConfig struct {
	// ApiKey The Anthropic API key. If not provided, falls back to ANTHROPIC_API_KEY environment variable.
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// MaxTokens Maximum number of tokens to generate in the response.
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Model The full model ID of the Anthropic model to use (e.g., 'claude-sonnet-4-5-20250929', 'claude-opus-4-5-20251101').
	Model string `json:"model"`

	// Temperature Controls randomness in generation (0.0-1.0). Higher values make output more random.
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// TopK Top-k sampling parameter. Only sample from the top K options for each subsequent token.
	TopK int `json:"top_k,omitempty,omitzero"`

	// TopP Nucleus sampling parameter (0.0-1.0). Alternative to temperature.
	TopP float32 `json:"top_p,omitempty,omitzero"`

	// Url The URL of the Anthropic API endpoint (optional, uses default if not specified).
	Url string `json:"url,omitempty,omitzero"`
}

// BackupInfo defines model for BackupInfo.
type BackupInfo struct {
	// AntflyVersion Antfly version that created the backup
	AntflyVersion string `json:"antfly_version,omitempty,omitzero"`

	// BackupId The backup identifier
	BackupId string `json:"backup_id"`

	// Location Storage location of the backup
	Location string `json:"location"`

	// Tables Tables included in the backup
	Tables []string `json:"tables"`

	// Timestamp When the backup was created
	Timestamp time.Time `json:"timestamp"`
}

// BackupListResponse defines model for BackupListResponse.
type BackupListResponse struct {
	// Backups List of available backups
	Backups []BackupInfo `json:"backups"`
}

// BackupRequest defines model for BackupRequest.
type BackupRequest struct {
	// BackupId Unique identifier for this backup. Used to reference the backup for restore operations.
	// Choose a meaningful name that includes date/version information.
	BackupId string `json:"backup_id"`

	// Location Storage location for the backup. Supports multiple backends:
	// - Local filesystem: `file:///path/to/backup`
	// - Amazon S3: `s3://bucket-name/path/to/backup`
	//
	// The backup includes all table data, indexes, and metadata for the specified table.
	Location string `json:"location"`
}

// BatchRequest Batch insert, delete, and transform operations in a single request.
//
// **Atomicity**:
// - **Single shard**: Operations are atomic within shard boundaries
// - **Multiple shards**: Uses distributed 2-phase commit (2PC) for atomic cross-shard writes
//
// **How distributed transactions work**:
// 1. Metadata server allocates HLC timestamp and selects coordinator shard
// 2. Coordinator writes transaction record, participants write intents
// 3. After all intents succeed, coordinator commits transaction
// 4. Participants are notified asynchronously to resolve intents
// 5. Recovery loop ensures notifications complete even after coordinator failure
//
// **Performance**:
// - Single-shard batches: < 5ms latency
// - Cross-shard transactions: ~20ms latency
// - Intent resolution: < 30 seconds worst-case (via recovery loop)
//
// **Guarantees**:
// - All writes succeed or all fail (atomicity across all shards)
// - Coordinator failure is recoverable (new leader resumes notifications)
// - Idempotent resolution (duplicate notifications are safe)
//
// **Benefits**:
// - Reduces network overhead compared to individual requests
// - More efficient indexing (updates are batched)
// - Automatic distributed transactions when operations span shards
//
// The inserts are upserts - existing keys are overwritten, new keys are created.
type BatchRequest struct {
	// Deletes Array of document IDs to delete. Documents are removed from all indexes.
	//
	// Notes:
	// - Non-existent keys are silently ignored
	// - Deletions are processed before inserts in the same batch
	// - Keys are permanently removed from storage and indexes
	Deletes []string `json:"deletes,omitempty,omitzero"`

	// Inserts Map of document IDs to document objects. Each key is the unique identifier for the document.
	//
	// Best practices:
	// - Use consistent key naming schemes (e.g., "user:123", "article:456")
	// - Key length affects storage and performance - keep them reasonably short
	// - Keys are sorted lexicographically, so choose prefixes that support range scans
	Inserts map[string]map[string]interface{} `json:"inserts,omitempty,omitzero"`

	// SyncLevel Synchronization level for batch operations:
	// - "propose": Wait for Raft proposal acceptance (fastest, default)
	// - "write": Wait for Pebble KV write
	// - "full_text": Wait for full-text index WAL write
	// - "enrichments": Pre-compute enrichments before Raft proposal (synchronous enrichment generation)
	// - "aknn": Wait for vector index write with best-effort synchronous embedding (falls back to async on timeout, slowest, most durable)
	SyncLevel SyncLevel `json:"sync_level,omitempty,omitzero"`

	// Transforms Array of transform operations for in-place document updates using MongoDB-style operators.
	//
	// Transform operations allow you to modify documents without read-modify-write races:
	// - Operations are applied atomically on the server
	// - Multiple operations per document are applied in sequence
	// - Supports numeric operations ($inc, $mul), array operations ($push, $pull), and more
	//
	// Common use cases:
	// - Increment counters (views, likes, votes)
	// - Update timestamps ($currentDate)
	// - Manage arrays (add/remove tags, items)
	// - Update nested fields without overwriting the entire document
	Transforms []Transform `json:"transforms,omitempty,omitzero"`
}

// BatchResponse defines model for BatchResponse.
type BatchResponse struct {
	// Deleted Number of documents successfully deleted
	Deleted int `json:"deleted,omitempty,omitzero"`

	// Inserted Number of documents successfully inserted
	Inserted int `json:"inserted,omitempty,omitzero"`

	// Transformed Number of documents successfully transformed
	Transformed int `json:"transformed,omitempty,omitzero"`
}

// BedrockEmbedderConfig Configuration for the AWS Bedrock embedding provider.
//
// Uses AWS credentials from environment or IAM roles.
//
// **Example Models:** cohere.embed-english-v4, amazon.titan-embed-text-v2:0
//
// **Docs:** https://docs.aws.amazon.com/bedrock/latest/userguide/models-supported.html
type BedrockEmbedderConfig struct {
	// BatchSize The batch size for embedding requests to optimize throughput.
	BatchSize int `json:"batch_size,omitempty,omitzero"`

	// Model The Bedrock model ID to use (e.g., 'cohere.embed-english-v4', 'amazon.titan-embed-text-v2:0').
	Model string `json:"model"`

	// Region The AWS region for the Bedrock service (e.g., 'us-east-1').
	Region string `json:"region,omitempty,omitzero"`

	// StripNewLines Whether to strip new lines from the input text before embedding.
	StripNewLines bool `json:"strip_new_lines,omitempty,omitzero"`
}

// BedrockGeneratorConfig Configuration for the AWS Bedrock generative AI provider.
//
// Provides access to models from Anthropic, Meta, Amazon, Cohere, Mistral, and others.
//
// **Example Models:** anthropic.claude-sonnet-4-5-20250929-v1:0, meta.llama3-3-70b-instruct-v1:0, amazon.nova-pro-v1:0
//
// **Docs:** https://docs.aws.amazon.com/bedrock/latest/userguide/models-supported.html
type BedrockGeneratorConfig struct {
	// MaxTokens Maximum number of tokens to generate.
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Model The Bedrock model ID to use (e.g., 'anthropic.claude-sonnet-4-5-20250929-v1:0').
	Model string `json:"model"`

	// Region The AWS region for the Bedrock service.
	Region string `json:"region,omitempty,omitzero"`

	// Temperature Controls randomness in generation (0.0-1.0).
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// TopK Top-k sampling parameter.
	TopK int `json:"top_k,omitempty,omitzero"`

	// TopP Nucleus sampling parameter.
	TopP float32 `json:"top_p,omitempty,omitzero"`
}

// BingSearchConfig defines model for BingSearchConfig.
type BingSearchConfig struct {
	// ApiKey Bing Search API key (or set BING_SEARCH_API_KEY env var)
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// Endpoint Bing API endpoint URL
	Endpoint string `json:"endpoint,omitempty,omitzero"`

	// Freshness Filter results by freshness
	Freshness BingSearchConfigFreshness `json:"freshness,omitempty,omitzero"`

	// Language Preferred language for results (e.g., 'en', 'es', 'fr')
	Language string `json:"language,omitempty,omitzero"`

	// MaxResults Maximum number of search results to return
	MaxResults int `json:"max_results,omitempty,omitzero"`

	// Provider The web search provider to use.
	//
	// - **google**: Google Custom Search API (requires CSE setup)
	// - **bing**: Microsoft Bing Web Search API
	// - **serper**: Serper.dev Google Search API (simpler setup)
	// - **tavily**: Tavily AI Search API (optimized for RAG)
	// - **brave**: Brave Search API
	// - **duckduckgo**: DuckDuckGo Instant Answer API (limited, no API key)
	Provider WebSearchProvider `json:"provider"`

	// Region Preferred region for results (e.g., 'us', 'uk', 'de')
	Region string `json:"region,omitempty,omitzero"`

	// SafeSearch Enable safe search filtering
	SafeSearch *bool `json:"safe_search,omitempty"`

	// TimeoutMs Request timeout in milliseconds
	TimeoutMs int `json:"timeout_ms,omitempty,omitzero"`
}

// BingSearchConfigFreshness Filter results by freshness
type BingSearchConfigFreshness string

// BleveIndexV2Config defines model for BleveIndexV2Config.
type BleveIndexV2Config struct {
	// MemOnly Whether to use memory-only storage
	MemOnly bool `json:"mem_only,omitempty,omitzero"`
}

// BleveIndexV2Stats defines model for BleveIndexV2Stats.
type BleveIndexV2Stats struct {
	// DiskUsage Size of the index in bytes
	DiskUsage uint64 `json:"disk_usage,omitempty,omitzero"`

	// Error Error message if stats could not be retrieved
	Error string `json:"error,omitempty,omitzero"`

	// Rebuilding Whether the index is currently rebuilding
	Rebuilding bool `json:"rebuilding,omitempty,omitzero"`

	// TotalIndexed Number of documents in the index
	TotalIndexed uint64 `json:"total_indexed,omitempty,omitzero"`
}

// BoolFieldQuery defines model for BoolFieldQuery.
type BoolFieldQuery struct {
	Bool bool `json:"bool"`

	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost Boost  `json:"boost,omitzero"`
	Field string `json:"field,omitempty,omitzero"`
}

// BooleanQuery defines model for BooleanQuery.
type BooleanQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost   Boost            `json:"boost,omitzero"`
	Filter  Query            `json:"filter,omitempty,omitzero"`
	Must    ConjunctionQuery `json:"must,omitempty,omitzero"`
	MustNot DisjunctionQuery `json:"must_not,omitempty,omitzero"`
	Should  DisjunctionQuery `json:"should,omitempty,omitzero"`
}

// Boost A floating-point number used to decrease or increase the relevance scores of a query.
type Boost = float64

// BraveSearchConfig defines model for BraveSearchConfig.
type BraveSearchConfig struct {
	// ApiKey Brave Search API key (or set BRAVE_API_KEY env var)
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// Freshness Freshness filter: pd=day, pw=week, pm=month, py=year
	Freshness BraveSearchConfigFreshness `json:"freshness,omitempty,omitzero"`

	// Language Preferred language for results (e.g., 'en', 'es', 'fr')
	Language string `json:"language,omitempty,omitzero"`

	// MaxResults Maximum number of search results to return
	MaxResults int `json:"max_results,omitempty,omitzero"`

	// Provider The web search provider to use.
	//
	// - **google**: Google Custom Search API (requires CSE setup)
	// - **bing**: Microsoft Bing Web Search API
	// - **serper**: Serper.dev Google Search API (simpler setup)
	// - **tavily**: Tavily AI Search API (optimized for RAG)
	// - **brave**: Brave Search API
	// - **duckduckgo**: DuckDuckGo Instant Answer API (limited, no API key)
	Provider WebSearchProvider `json:"provider"`

	// Region Preferred region for results (e.g., 'us', 'uk', 'de')
	Region string `json:"region,omitempty,omitzero"`

	// SafeSearch Enable safe search filtering
	SafeSearch *bool `json:"safe_search,omitempty"`

	// Spellcheck Enable spellcheck suggestions
	Spellcheck bool `json:"spellcheck,omitempty,omitzero"`

	// TextDecorations Include text decorations (bold, italic markers)
	TextDecorations bool `json:"text_decorations,omitempty,omitzero"`

	// TimeoutMs Request timeout in milliseconds
	TimeoutMs int `json:"timeout_ms,omitempty,omitzero"`
}

// BraveSearchConfigFreshness Freshness filter: pd=day, pw=week, pm=month, py=year
type BraveSearchConfigFreshness string

// ByteRange defines model for ByteRange.
type ByteRange = [][]byte

// CalendarInterval Calendar-aware interval for date_histogram aggregations
type CalendarInterval string

// ChainCondition Condition for trying the next generator in chain:
// - always: Always try next regardless of outcome
// - on_error: Try next on any error (default)
// - on_timeout: Try next only on timeout errors
// - on_rate_limit: Try next only on rate limit errors
type ChainCondition string

// ChainLink A single link in a generator chain with optional retry and condition
type ChainLink struct {
	// Condition Condition for trying the next generator in chain:
	// - always: Always try next regardless of outcome
	// - on_error: Try next on any error (default)
	// - on_timeout: Try next only on timeout errors
	// - on_rate_limit: Try next only on rate limit errors
	Condition ChainCondition `json:"condition,omitempty,omitzero"`

	// Generator A unified configuration for a generative AI provider.
	//
	// Generators can be configured with custom prompts using templates. Templates use
	// Handlebars syntax and support various built-in helpers for formatting and data manipulation.
	//
	// **Template System:**
	// - **Syntax**: Handlebars templating (https://handlebarsjs.com/guide/)
	// - **Caching**: Templates are automatically cached with configurable TTL (default: 5 minutes)
	// - **Context**: Templates receive the full context data passed to the generator
	//
	// **Built-in Helpers:**
	//
	// 1. **scrubHtml** - Remove script/style tags and extract clean text from HTML
	//    ```handlebars
	//    {{scrubHtml html_content}}
	//    ```
	//    - Removes `<script>` and `<style>` tags
	//    - Adds newlines after block elements (p, div, h1-h6, li, etc.)
	//    - Returns plain text with preserved readability
	//    - Useful for cleaning web content before summarization
	//
	// 2. **eq** - Equality comparison for conditionals
	//    ```handlebars
	//    {{#if (eq status "active")}}Active{{/if}}
	//    {{#if (eq @key "special")}}Special field{{/if}}
	//    ```
	//    - Use in `{{#if}}` blocks for conditional logic
	//    - Compares any two values for equality
	//
	// 3. **media** - GenKit dotprompt media directive for multimodal content
	//    ```handlebars
	//    {{media url=imageDataURI}}
	//    {{media url=this.image_url}}
	//    {{media url="https://example.com/image.jpg"}}
	//    {{media url="s3://endpoint/bucket/image.png"}}
	//    {{media url="file:///path/to/image.jpg"}}
	//    ```
	//
	//    **Supported URL Schemes:**
	//    - `data:` - Base64 encoded data URIs (e.g., `data:image/jpeg;base64,...`)
	//    - `http://` / `https://` - Web URLs with automatic content type detection
	//    - `file://` - Local filesystem paths
	//    - `s3://` - S3-compatible storage (format: `s3://endpoint/bucket/key`)
	//
	//    **Automatic Content Processing:**
	//    - **Images**: Downloaded, resized (if needed), converted to data URIs
	//    - **PDFs**: Text extracted or first page rendered as image
	//    - **HTML**: Readable text extracted using Mozilla Readability
	//
	//    **Security Controls:**
	//    Downloads are protected by content security settings (see Configuration Reference):
	//    - Allowed host whitelist
	//    - Private IP blocking (prevents SSRF attacks)
	//    - Download size limits (default: 100MB)
	//    - Download timeouts (default: 30s)
	//    - Image dimension limits (default: 2048px, auto-resized)
	//
	//    See: https://antfly.io/docs/configuration#security--cors
	//
	// 4. **encodeToon** - Encode data in TOON format (Token-Oriented Object Notation)
	//    ```handlebars
	//    {{encodeToon this.fields}}
	//    {{encodeToon this.fields lengthMarker=false indent=4}}
	//    {{encodeToon this.fields delimiter="\t"}}
	//    ```
	//
	//    **What is TOON?**
	//    TOON is a compact, human-readable format designed for passing structured data to LLMs.
	//    It provides **30-60% token reduction** compared to JSON while maintaining high LLM
	//    comprehension accuracy.
	//
	//    **Key Features:**
	//    - Compact syntax using `:` for key-value pairs
	//    - Array length markers: `tags[#3]: ai,search,ml`
	//    - Tabular format for uniform data structures
	//    - Optimized for LLM parsing and understanding
	//    - Maintains human readability
	//
	//    **Benefits:**
	//    - **Lower API costs** - Reduced token usage means lower LLM API costs
	//    - **Faster responses** - Less tokens to process
	//    - **More context** - Fit more documents within token limits
	//
	//    **Options:**
	//    - `lengthMarker` (bool): Add # prefix to array counts like `[#3]` (default: true)
	//    - `indent` (int): Indentation spacing for nested objects (default: 2)
	//    - `delimiter` (string): Field separator for tabular arrays (default: none, use `"\t"` for tabs)
	//
	//    **Example output:**
	//    ```
	//    title: Introduction to Vector Search
	//    author: Jane Doe
	//    tags[#3]: ai,search,ml
	//    metadata:
	//      edition: 2
	//      pages: 450
	//    ```
	//
	//    **Default in RAG:** TOON is the default format for document rendering in RAG queries.
	//
	//    **References:**
	//    - TOON Specification: https://github.com/toon-format/toon
	//    - Go Implementation: https://github.com/alpkeskin/gotoon
	//
	// **Template Examples:**
	//
	// RAG summarization with document references:
	// ```handlebars
	// Based on these documents, provide a comprehensive summary:
	//
	// {{#each documents}}
	// Document {{this.id}}:
	// {{scrubHtml this.content}}
	//
	// {{/each}}
	//
	// Valid document IDs: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
	// ```
	//
	// Conditional formatting:
	// ```handlebars
	// {{#if system_prompt}}System: {{system_prompt}}{{/if}}
	//
	// User Query: {{query}}
	//
	// {{#if context}}
	// Context:
	// {{#each context}}
	// - {{this}}
	// {{/each}}
	// {{/if}}
	// ```
	//
	// Multimodal prompt with images:
	// ```handlebars
	// Analyze this image:
	// {{media url=image_url}}
	//
	// Focus on: {{focus_area}}
	// ```
	//
	// Structured data encoding:
	// ```handlebars
	// User Profile:
	// {{encodeToon user_data indent=2 lengthMarker=true}}
	//
	// Please analyze this profile.
	// ```
	//
	// **Common Use Cases:**
	// - **RAG (Retrieval-Augmented Generation)**: Format retrieved documents with citations
	// - **Summarization**: Clean HTML content and structure summaries
	// - **Query Classification**: Format queries with metadata for better classification
	// - **Multimodal**: Include images/audio/video in prompts
	// - **Data Formatting**: Convert structured data to readable text
	//
	// **Best Practices:**
	// - Keep templates simple - complex logic belongs in application code
	// - Use clear, descriptive field names in context
	// - Handle missing fields gracefully (templates use "missingkey=zero" by default)
	// - Test templates with representative data before production use
	Generator GeneratorConfig `json:"generator"`

	// Retry Retry configuration for generator calls
	Retry RetryConfig `json:"retry,omitempty,omitzero"`
}

// ChatMessage A message in the conversation history
type ChatMessage struct {
	// Content Text content of the message
	Content string `json:"content"`

	// Role Role of the message sender in the conversation
	Role ChatMessageRole `json:"role"`

	// ToolCalls Tool calls made by the assistant (only for assistant role)
	ToolCalls []ChatToolCall `json:"tool_calls,omitempty,omitzero"`

	// ToolResults Results from tool executions (only for tool role)
	ToolResults []ChatToolResult `json:"tool_results,omitempty,omitzero"`
}

// ChatMessageRole Role of the message sender in the conversation
type ChatMessageRole string

// ChatToolCall A tool call made by the assistant
type ChatToolCall struct {
	// Arguments Arguments passed to the tool as key-value pairs
	Arguments map[string]interface{} `json:"arguments"`

	// Id Unique identifier for this tool call
	Id string `json:"id"`

	// Name Name of the tool being called
	Name string `json:"name"`
}

// ChatToolName Available tool names for the chat and retrieval agents.
// - add_filter: Add search filters (field constraints)
// - ask_clarification: Ask user for clarification
// - search: Execute semantic searches (legacy, use semantic_search for retrieval)
// - websearch: Search the web (requires websearch_config)
// - fetch: Fetch URL content (subject to security controls)
// - semantic_search: Execute semantic/vector search against an index
// - full_text_search: Execute full-text BM25 search against an index
// - tree_search: Execute tree search with beam search navigation
// - graph_search: Execute graph traversal search
type ChatToolName string

// ChatToolResult Result from executing a tool call
type ChatToolResult struct {
	// Error Error message if tool execution failed
	Error string `json:"error,omitempty,omitzero"`

	// Result Result data from the tool execution
	Result map[string]interface{} `json:"result"`

	// ToolCallId ID of the tool call this result corresponds to
	ToolCallId string `json:"tool_call_id"`
}

// ChatToolsConfig Configuration for chat agent tools.
//
// If `enabled_tools` is empty/omitted, defaults to: add_filter, ask_clarification, search.
//
// For models that don't support native tool calling (e.g., Ollama),
// a prompt-based fallback is used with structured output parsing.
type ChatToolsConfig struct {
	// EnabledTools List of tools to enable. If empty, defaults to filter, clarification, and search.
	EnabledTools []ChatToolName `json:"enabled_tools,omitempty,omitzero"`

	// FetchConfig Configuration for URL content fetching.
	//
	// Uses lib/scraping for downloading and processing. Supports:
	// - HTTP/HTTPS URLs with security validation
	// - HTML pages (extracts readable text via go-readability)
	// - PDF files (extracts text)
	// - Images (returns as data URIs)
	// - Plain text files
	// - S3 URLs (requires s3_credentials)
	//
	// Security features (from lib/scraping.ContentSecurityConfig):
	// - Allowed host whitelist
	// - Private IP blocking (SSRF prevention)
	// - Download size limits
	// - Timeout controls
	FetchConfig FetchConfig `json:"fetch_config,omitempty,omitzero"`

	// MaxToolIterations Maximum number of tool call iterations per turn.
	// Prevents infinite loops in tool execution.
	MaxToolIterations int `json:"max_tool_iterations,omitempty,omitzero"`

	// WebsearchConfig A unified configuration for web search providers.
	//
	// Each provider has specific configuration requirements. Use the appropriate
	// provider-specific config or set common options at the top level.
	//
	// **Environment Variables (fallbacks):**
	// - GOOGLE_CSE_API_KEY, GOOGLE_CSE_ID
	// - BING_SEARCH_API_KEY
	// - SERPER_API_KEY
	// - TAVILY_API_KEY
	// - BRAVE_API_KEY
	WebsearchConfig WebSearchConfig `json:"websearch_config,omitempty,omitzero"`
}

// ChunkOptions Per-request configuration for chunking. All fields are optional - zero/omitted values use chunker defaults.
type ChunkOptions struct {
	// MaxChunks Maximum number of chunks to generate per document.
	MaxChunks int `json:"max_chunks,omitempty,omitzero"`

	// OverlapDurationMs Overlap duration in milliseconds between audio chunks (default: 0).
	OverlapDurationMs int `json:"overlap_duration_ms,omitempty,omitzero"`

	// OverlapTokens Number of tokens to overlap between consecutive chunks. Helps maintain context across chunk boundaries. Only used by fixed-size chunkers.
	OverlapTokens int `json:"overlap_tokens,omitempty,omitzero"`

	// Separator Separator string for splitting (e.g., '\n\n' for paragraphs). Only used by fixed-size chunkers.
	Separator string `json:"separator,omitempty,omitzero"`

	// TargetTokens Target number of tokens per chunk.
	TargetTokens int `json:"target_tokens,omitempty,omitzero"`

	// Threshold Minimum confidence threshold for separator detection (0.0-1.0). Only used by ONNX models.
	Threshold float32 `json:"threshold,omitempty,omitzero"`

	// WindowDurationMs Window duration in milliseconds for audio chunking (default: 30000).
	WindowDurationMs int `json:"window_duration_ms,omitempty,omitzero"`
}

// ChunkerConfig defines model for ChunkerConfig.
type ChunkerConfig struct {
	// FullTextIndex Configuration for full-text indexing of chunks in Bleve.
	// When present (even if empty), chunks will be stored with :cft: suffix and indexed in Bleve's _chunks field.
	// When absent, chunks use :c: suffix and are only used for vector embeddings.
	FullTextIndex map[string]interface{} `json:"full_text_index,omitempty,omitzero"`

	// Provider The chunking provider to use.
	Provider ChunkerProvider `json:"provider"`

	// StoreChunks Controls whether chunk data is persisted to storage. When false (default), chunks are generated in memory and only embeddings are stored. When true, both chunks and embeddings are stored.
	StoreChunks bool `json:"store_chunks,omitempty,omitzero"`
	union       json.RawMessage
}

// ChunkerProvider The chunking provider to use.
type ChunkerProvider string

// ClarificationRequest Request for clarification from the user
type ClarificationRequest struct {
	// Options Optional list of choices for the user
	Options []string `json:"options,omitempty,omitzero"`

	// Question The clarifying question to ask the user
	Question string `json:"question"`

	// Reason Why clarification is needed
	Reason string `json:"reason,omitempty,omitzero"`
}

// ClassificationStepConfig Configuration for the classification step. This step analyzes the query,
// selects the optimal retrieval strategy, and generates semantic transformations.
type ClassificationStepConfig struct {
	// Chain Chain of generators to try in order. Mutually exclusive with 'generator'.
	Chain []ChainLink `json:"chain,omitempty,omitzero"`

	// Enabled Enable query classification and strategy selection
	Enabled bool `json:"enabled,omitempty,omitzero"`

	// ForceSemanticMode Mode for semantic query generation:
	// - rewrite: Transform query into expanded keywords/concepts optimized for vector search (Level 2 optimization)
	// - hypothetical: Generate a hypothetical answer that would appear in relevant documents (HyDE - Level 3 optimization)
	ForceSemanticMode SemanticQueryMode `json:"force_semantic_mode,omitempty,omitzero"`

	// ForceStrategy Strategy for query transformation and retrieval:
	// - simple: Direct query with multi-phrase expansion. Best for straightforward factual queries.
	// - decompose: Break complex queries into sub-questions, retrieve for each. Best for multi-part questions.
	// - step_back: Generate broader background query first, then specific query. Best for questions needing context.
	// - hyde: Generate hypothetical answer document, embed that for retrieval. Best for abstract/conceptual questions.
	ForceStrategy QueryStrategy `json:"force_strategy,omitempty,omitzero"`

	// Generator A unified configuration for a generative AI provider.
	//
	// Generators can be configured with custom prompts using templates. Templates use
	// Handlebars syntax and support various built-in helpers for formatting and data manipulation.
	//
	// **Template System:**
	// - **Syntax**: Handlebars templating (https://handlebarsjs.com/guide/)
	// - **Caching**: Templates are automatically cached with configurable TTL (default: 5 minutes)
	// - **Context**: Templates receive the full context data passed to the generator
	//
	// **Built-in Helpers:**
	//
	// 1. **scrubHtml** - Remove script/style tags and extract clean text from HTML
	//    ```handlebars
	//    {{scrubHtml html_content}}
	//    ```
	//    - Removes `<script>` and `<style>` tags
	//    - Adds newlines after block elements (p, div, h1-h6, li, etc.)
	//    - Returns plain text with preserved readability
	//    - Useful for cleaning web content before summarization
	//
	// 2. **eq** - Equality comparison for conditionals
	//    ```handlebars
	//    {{#if (eq status "active")}}Active{{/if}}
	//    {{#if (eq @key "special")}}Special field{{/if}}
	//    ```
	//    - Use in `{{#if}}` blocks for conditional logic
	//    - Compares any two values for equality
	//
	// 3. **media** - GenKit dotprompt media directive for multimodal content
	//    ```handlebars
	//    {{media url=imageDataURI}}
	//    {{media url=this.image_url}}
	//    {{media url="https://example.com/image.jpg"}}
	//    {{media url="s3://endpoint/bucket/image.png"}}
	//    {{media url="file:///path/to/image.jpg"}}
	//    ```
	//
	//    **Supported URL Schemes:**
	//    - `data:` - Base64 encoded data URIs (e.g., `data:image/jpeg;base64,...`)
	//    - `http://` / `https://` - Web URLs with automatic content type detection
	//    - `file://` - Local filesystem paths
	//    - `s3://` - S3-compatible storage (format: `s3://endpoint/bucket/key`)
	//
	//    **Automatic Content Processing:**
	//    - **Images**: Downloaded, resized (if needed), converted to data URIs
	//    - **PDFs**: Text extracted or first page rendered as image
	//    - **HTML**: Readable text extracted using Mozilla Readability
	//
	//    **Security Controls:**
	//    Downloads are protected by content security settings (see Configuration Reference):
	//    - Allowed host whitelist
	//    - Private IP blocking (prevents SSRF attacks)
	//    - Download size limits (default: 100MB)
	//    - Download timeouts (default: 30s)
	//    - Image dimension limits (default: 2048px, auto-resized)
	//
	//    See: https://antfly.io/docs/configuration#security--cors
	//
	// 4. **encodeToon** - Encode data in TOON format (Token-Oriented Object Notation)
	//    ```handlebars
	//    {{encodeToon this.fields}}
	//    {{encodeToon this.fields lengthMarker=false indent=4}}
	//    {{encodeToon this.fields delimiter="\t"}}
	//    ```
	//
	//    **What is TOON?**
	//    TOON is a compact, human-readable format designed for passing structured data to LLMs.
	//    It provides **30-60% token reduction** compared to JSON while maintaining high LLM
	//    comprehension accuracy.
	//
	//    **Key Features:**
	//    - Compact syntax using `:` for key-value pairs
	//    - Array length markers: `tags[#3]: ai,search,ml`
	//    - Tabular format for uniform data structures
	//    - Optimized for LLM parsing and understanding
	//    - Maintains human readability
	//
	//    **Benefits:**
	//    - **Lower API costs** - Reduced token usage means lower LLM API costs
	//    - **Faster responses** - Less tokens to process
	//    - **More context** - Fit more documents within token limits
	//
	//    **Options:**
	//    - `lengthMarker` (bool): Add # prefix to array counts like `[#3]` (default: true)
	//    - `indent` (int): Indentation spacing for nested objects (default: 2)
	//    - `delimiter` (string): Field separator for tabular arrays (default: none, use `"\t"` for tabs)
	//
	//    **Example output:**
	//    ```
	//    title: Introduction to Vector Search
	//    author: Jane Doe
	//    tags[#3]: ai,search,ml
	//    metadata:
	//      edition: 2
	//      pages: 450
	//    ```
	//
	//    **Default in RAG:** TOON is the default format for document rendering in RAG queries.
	//
	//    **References:**
	//    - TOON Specification: https://github.com/toon-format/toon
	//    - Go Implementation: https://github.com/alpkeskin/gotoon
	//
	// **Template Examples:**
	//
	// RAG summarization with document references:
	// ```handlebars
	// Based on these documents, provide a comprehensive summary:
	//
	// {{#each documents}}
	// Document {{this.id}}:
	// {{scrubHtml this.content}}
	//
	// {{/each}}
	//
	// Valid document IDs: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
	// ```
	//
	// Conditional formatting:
	// ```handlebars
	// {{#if system_prompt}}System: {{system_prompt}}{{/if}}
	//
	// User Query: {{query}}
	//
	// {{#if context}}
	// Context:
	// {{#each context}}
	// - {{this}}
	// {{/each}}
	// {{/if}}
	// ```
	//
	// Multimodal prompt with images:
	// ```handlebars
	// Analyze this image:
	// {{media url=image_url}}
	//
	// Focus on: {{focus_area}}
	// ```
	//
	// Structured data encoding:
	// ```handlebars
	// User Profile:
	// {{encodeToon user_data indent=2 lengthMarker=true}}
	//
	// Please analyze this profile.
	// ```
	//
	// **Common Use Cases:**
	// - **RAG (Retrieval-Augmented Generation)**: Format retrieved documents with citations
	// - **Summarization**: Clean HTML content and structure summaries
	// - **Query Classification**: Format queries with metadata for better classification
	// - **Multimodal**: Include images/audio/video in prompts
	// - **Data Formatting**: Convert structured data to readable text
	//
	// **Best Practices:**
	// - Keep templates simple - complex logic belongs in application code
	// - Use clear, descriptive field names in context
	// - Handle missing fields gracefully (templates use "missingkey=zero" by default)
	// - Test templates with representative data before production use
	Generator GeneratorConfig `json:"generator,omitempty,omitzero"`

	// MultiPhraseCount Number of alternative query phrasings to generate
	MultiPhraseCount int `json:"multi_phrase_count,omitempty,omitzero"`

	// WithReasoning Include pre-retrieval reasoning explaining query analysis and strategy selection
	WithReasoning bool `json:"with_reasoning,omitempty,omitzero"`
}

// ClassificationTransformationResult Query classification and transformation result combining all query enhancements including strategy selection and semantic optimization
type ClassificationTransformationResult struct {
	// Confidence Classification confidence (0.0 to 1.0)
	Confidence float32 `json:"confidence"`

	// ImprovedQuery Clarified query with added context for answer generation (human-readable)
	ImprovedQuery string `json:"improved_query"`

	// MultiPhrases Alternative phrasings of the query for expanded retrieval coverage
	MultiPhrases []string `json:"multi_phrases,omitempty,omitzero"`

	// Reasoning Pre-retrieval reasoning explaining query analysis and strategy selection (only present when with_classification_reasoning is enabled)
	Reasoning string `json:"reasoning,omitempty,omitzero"`

	// RouteType Classification of query type: question (specific factual query) or search (exploratory query)
	RouteType RouteType `json:"route_type"`

	// SemanticMode Mode for semantic query generation:
	// - rewrite: Transform query into expanded keywords/concepts optimized for vector search (Level 2 optimization)
	// - hypothetical: Generate a hypothetical answer that would appear in relevant documents (HyDE - Level 3 optimization)
	SemanticMode SemanticQueryMode `json:"semantic_mode"`

	// SemanticQuery Optimized query for vector/semantic search. Content style depends on semantic_mode: keywords for 'rewrite', hypothetical answer for 'hypothetical'
	SemanticQuery string `json:"semantic_query"`

	// StepBackQuery Broader background query for context (only present when strategy is 'step_back')
	StepBackQuery string `json:"step_back_query,omitempty,omitzero"`

	// Strategy Strategy for query transformation and retrieval:
	// - simple: Direct query with multi-phrase expansion. Best for straightforward factual queries.
	// - decompose: Break complex queries into sub-questions, retrieve for each. Best for multi-part questions.
	// - step_back: Generate broader background query first, then specific query. Best for questions needing context.
	// - hyde: Generate hypothetical answer document, embed that for retrieval. Best for abstract/conceptual questions.
	Strategy QueryStrategy `json:"strategy"`

	// SubQuestions Decomposed sub-questions (only present when strategy is 'decompose')
	SubQuestions []string `json:"sub_questions,omitempty,omitzero"`
}

// ClusterBackupRequest defines model for ClusterBackupRequest.
type ClusterBackupRequest struct {
	// BackupId Unique identifier for this backup. Used to reference the backup for restore operations.
	// Choose a meaningful name that includes date/version information.
	BackupId string `json:"backup_id"`

	// Location Storage location for the backup. Supports multiple backends:
	// - Local filesystem: `file:///path/to/backup`
	// - Amazon S3: `s3://bucket-name/path/to/backup`
	//
	// The backup includes all table data, indexes, and metadata.
	Location string `json:"location"`

	// TableNames Optional list of tables to backup. If omitted, all tables are backed up.
	TableNames []string `json:"table_names,omitempty,omitzero"`
}

// ClusterBackupResponse defines model for ClusterBackupResponse.
type ClusterBackupResponse struct {
	// BackupId The backup identifier
	BackupId string `json:"backup_id"`

	// Status Overall backup status
	Status ClusterBackupResponseStatus `json:"status"`

	// Tables Status of each table backup
	Tables []TableBackupStatus `json:"tables"`
}

// ClusterBackupResponseStatus Overall backup status
type ClusterBackupResponseStatus string

// ClusterHealth Overall health status of the cluster
type ClusterHealth string

// ClusterRestoreRequest defines model for ClusterRestoreRequest.
type ClusterRestoreRequest struct {
	// BackupId Unique identifier of the backup to restore from.
	BackupId string `json:"backup_id"`

	// Location Storage location where the backup is stored.
	Location string `json:"location"`

	// RestoreMode How to handle existing tables:
	// - `fail_if_exists`: Abort if any table already exists (default)
	// - `skip_if_exists`: Skip existing tables, restore others
	// - `overwrite`: Drop and recreate existing tables
	RestoreMode ClusterRestoreRequestRestoreMode `json:"restore_mode,omitempty,omitzero"`

	// TableNames Optional list of tables to restore. If omitted, all tables in the backup are restored.
	TableNames []string `json:"table_names,omitempty,omitzero"`
}

// ClusterRestoreRequestRestoreMode How to handle existing tables:
// - `fail_if_exists`: Abort if any table already exists (default)
// - `skip_if_exists`: Skip existing tables, restore others
// - `overwrite`: Drop and recreate existing tables
type ClusterRestoreRequestRestoreMode string

// ClusterRestoreResponse defines model for ClusterRestoreResponse.
type ClusterRestoreResponse struct {
	// Status Overall restore status
	Status ClusterRestoreResponseStatus `json:"status"`

	// Tables Status of each table restore
	Tables []TableRestoreStatus `json:"tables"`
}

// ClusterRestoreResponseStatus Overall restore status
type ClusterRestoreResponseStatus string

// ClusterStatus defines model for ClusterStatus.
type ClusterStatus struct {
	// AuthEnabled Indicates whether authentication is enabled for the cluster
	AuthEnabled bool `json:"auth_enabled,omitempty"`

	// Health Overall health status of the cluster
	Health ClusterHealth `json:"health"`

	// Message Optional message providing details about the health status
	Message              string                 `json:"message,omitempty,omitzero"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CohereEmbedderConfig Configuration for the Cohere embedding provider.
//
// API key via `api_key` field or `COHERE_API_KEY` environment variable.
//
// **Example Models:** embed-english-v3.0 (default, 1024 dims), embed-multilingual-v3.0
//
// **Docs:** https://docs.cohere.com/reference/embed
type CohereEmbedderConfig struct {
	// ApiKey The Cohere API key. Can also be set via COHERE_API_KEY environment variable.
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// InputType Specifies the type of input for optimized embeddings.
	InputType CohereEmbedderConfigInputType `json:"input_type,omitempty,omitzero"`

	// Model The name of the Cohere embedding model to use.
	Model string `json:"model"`

	// Truncate How to handle inputs longer than the max token length.
	Truncate CohereEmbedderConfigTruncate `json:"truncate,omitempty,omitzero"`
}

// CohereEmbedderConfigInputType Specifies the type of input for optimized embeddings.
type CohereEmbedderConfigInputType string

// CohereEmbedderConfigTruncate How to handle inputs longer than the max token length.
type CohereEmbedderConfigTruncate string

// CohereGeneratorConfig Configuration for the Cohere generative AI provider (Command models).
//
// API key via `api_key` field or `COHERE_API_KEY` environment variable.
//
// **Example Models:** command-r-plus (default), command-r, command-a-03-2025
//
// **Docs:** https://docs.cohere.com/reference/chat
type CohereGeneratorConfig struct {
	// ApiKey The Cohere API key. If not provided, falls back to COHERE_API_KEY environment variable.
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// FrequencyPenalty Penalty for token frequency (0.0-1.0).
	FrequencyPenalty float32 `json:"frequency_penalty,omitempty,omitzero"`

	// MaxTokens Maximum number of tokens to generate in the response.
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Model The name of the Cohere model to use.
	Model string `json:"model"`

	// PresencePenalty Penalty for token presence (0.0-1.0).
	PresencePenalty float32 `json:"presence_penalty,omitempty,omitzero"`

	// Temperature Controls randomness in generation (0.0-1.0). Higher values make output more random.
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// TopK Top-k sampling parameter. Only sample from the top K options for each subsequent token.
	TopK int `json:"top_k,omitempty,omitzero"`

	// TopP Nucleus sampling parameter (0.0-1.0). Alternative to temperature.
	TopP float32 `json:"top_p,omitempty,omitzero"`
}

// CohereRerankerConfig Configuration for the Cohere reranking provider.
//
// API key via `api_key` field or `COHERE_API_KEY` environment variable.
//
// **Example Models:** rerank-english-v3.0 (default), rerank-multilingual-v3.0
//
// **Docs:** https://docs.cohere.com/reference/rerank
type CohereRerankerConfig struct {
	// ApiKey The Cohere API key. Can also be set via COHERE_API_KEY environment variable.
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// MaxChunksPerDoc Maximum number of chunks per document for long document handling.
	MaxChunksPerDoc int `json:"max_chunks_per_doc,omitempty,omitzero"`

	// Model The name of the Cohere reranking model to use.
	Model string `json:"model"`

	// TopN Number of most relevant documents to return. If not specified, returns all documents with scores.
	TopN int `json:"top_n,omitempty,omitzero"`
}

// ConfidenceStepConfig Configuration for confidence assessment. Evaluates answer quality and
// resource relevance. Can use a model calibrated for scoring tasks.
type ConfidenceStepConfig struct {
	// Chain Chain of generators to try in order. Mutually exclusive with 'generator'.
	Chain []ChainLink `json:"chain,omitempty,omitzero"`

	// Context Custom guidance for confidence assessment approach
	Context string `json:"context,omitempty,omitzero"`

	// Enabled Enable confidence scoring
	Enabled bool `json:"enabled,omitempty,omitzero"`

	// Generator A unified configuration for a generative AI provider.
	//
	// Generators can be configured with custom prompts using templates. Templates use
	// Handlebars syntax and support various built-in helpers for formatting and data manipulation.
	//
	// **Template System:**
	// - **Syntax**: Handlebars templating (https://handlebarsjs.com/guide/)
	// - **Caching**: Templates are automatically cached with configurable TTL (default: 5 minutes)
	// - **Context**: Templates receive the full context data passed to the generator
	//
	// **Built-in Helpers:**
	//
	// 1. **scrubHtml** - Remove script/style tags and extract clean text from HTML
	//    ```handlebars
	//    {{scrubHtml html_content}}
	//    ```
	//    - Removes `<script>` and `<style>` tags
	//    - Adds newlines after block elements (p, div, h1-h6, li, etc.)
	//    - Returns plain text with preserved readability
	//    - Useful for cleaning web content before summarization
	//
	// 2. **eq** - Equality comparison for conditionals
	//    ```handlebars
	//    {{#if (eq status "active")}}Active{{/if}}
	//    {{#if (eq @key "special")}}Special field{{/if}}
	//    ```
	//    - Use in `{{#if}}` blocks for conditional logic
	//    - Compares any two values for equality
	//
	// 3. **media** - GenKit dotprompt media directive for multimodal content
	//    ```handlebars
	//    {{media url=imageDataURI}}
	//    {{media url=this.image_url}}
	//    {{media url="https://example.com/image.jpg"}}
	//    {{media url="s3://endpoint/bucket/image.png"}}
	//    {{media url="file:///path/to/image.jpg"}}
	//    ```
	//
	//    **Supported URL Schemes:**
	//    - `data:` - Base64 encoded data URIs (e.g., `data:image/jpeg;base64,...`)
	//    - `http://` / `https://` - Web URLs with automatic content type detection
	//    - `file://` - Local filesystem paths
	//    - `s3://` - S3-compatible storage (format: `s3://endpoint/bucket/key`)
	//
	//    **Automatic Content Processing:**
	//    - **Images**: Downloaded, resized (if needed), converted to data URIs
	//    - **PDFs**: Text extracted or first page rendered as image
	//    - **HTML**: Readable text extracted using Mozilla Readability
	//
	//    **Security Controls:**
	//    Downloads are protected by content security settings (see Configuration Reference):
	//    - Allowed host whitelist
	//    - Private IP blocking (prevents SSRF attacks)
	//    - Download size limits (default: 100MB)
	//    - Download timeouts (default: 30s)
	//    - Image dimension limits (default: 2048px, auto-resized)
	//
	//    See: https://antfly.io/docs/configuration#security--cors
	//
	// 4. **encodeToon** - Encode data in TOON format (Token-Oriented Object Notation)
	//    ```handlebars
	//    {{encodeToon this.fields}}
	//    {{encodeToon this.fields lengthMarker=false indent=4}}
	//    {{encodeToon this.fields delimiter="\t"}}
	//    ```
	//
	//    **What is TOON?**
	//    TOON is a compact, human-readable format designed for passing structured data to LLMs.
	//    It provides **30-60% token reduction** compared to JSON while maintaining high LLM
	//    comprehension accuracy.
	//
	//    **Key Features:**
	//    - Compact syntax using `:` for key-value pairs
	//    - Array length markers: `tags[#3]: ai,search,ml`
	//    - Tabular format for uniform data structures
	//    - Optimized for LLM parsing and understanding
	//    - Maintains human readability
	//
	//    **Benefits:**
	//    - **Lower API costs** - Reduced token usage means lower LLM API costs
	//    - **Faster responses** - Less tokens to process
	//    - **More context** - Fit more documents within token limits
	//
	//    **Options:**
	//    - `lengthMarker` (bool): Add # prefix to array counts like `[#3]` (default: true)
	//    - `indent` (int): Indentation spacing for nested objects (default: 2)
	//    - `delimiter` (string): Field separator for tabular arrays (default: none, use `"\t"` for tabs)
	//
	//    **Example output:**
	//    ```
	//    title: Introduction to Vector Search
	//    author: Jane Doe
	//    tags[#3]: ai,search,ml
	//    metadata:
	//      edition: 2
	//      pages: 450
	//    ```
	//
	//    **Default in RAG:** TOON is the default format for document rendering in RAG queries.
	//
	//    **References:**
	//    - TOON Specification: https://github.com/toon-format/toon
	//    - Go Implementation: https://github.com/alpkeskin/gotoon
	//
	// **Template Examples:**
	//
	// RAG summarization with document references:
	// ```handlebars
	// Based on these documents, provide a comprehensive summary:
	//
	// {{#each documents}}
	// Document {{this.id}}:
	// {{scrubHtml this.content}}
	//
	// {{/each}}
	//
	// Valid document IDs: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
	// ```
	//
	// Conditional formatting:
	// ```handlebars
	// {{#if system_prompt}}System: {{system_prompt}}{{/if}}
	//
	// User Query: {{query}}
	//
	// {{#if context}}
	// Context:
	// {{#each context}}
	// - {{this}}
	// {{/each}}
	// {{/if}}
	// ```
	//
	// Multimodal prompt with images:
	// ```handlebars
	// Analyze this image:
	// {{media url=image_url}}
	//
	// Focus on: {{focus_area}}
	// ```
	//
	// Structured data encoding:
	// ```handlebars
	// User Profile:
	// {{encodeToon user_data indent=2 lengthMarker=true}}
	//
	// Please analyze this profile.
	// ```
	//
	// **Common Use Cases:**
	// - **RAG (Retrieval-Augmented Generation)**: Format retrieved documents with citations
	// - **Summarization**: Clean HTML content and structure summaries
	// - **Query Classification**: Format queries with metadata for better classification
	// - **Multimodal**: Include images/audio/video in prompts
	// - **Data Formatting**: Convert structured data to readable text
	//
	// **Best Practices:**
	// - Keep templates simple - complex logic belongs in application code
	// - Use clear, descriptive field names in context
	// - Handle missing fields gracefully (templates use "missingkey=zero" by default)
	// - Test templates with representative data before production use
	Generator GeneratorConfig `json:"generator,omitempty,omitzero"`
}

// ConjunctionQuery defines model for ConjunctionQuery.
type ConjunctionQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost     Boost   `json:"boost,omitzero"`
	Conjuncts []Query `json:"conjuncts"`
}

// CreateTableRequest defines model for CreateTableRequest.
type CreateTableRequest struct {
	// Description Optional human-readable description of the table and its purpose.
	// Useful for documentation and team collaboration.
	Description string `json:"description,omitempty,omitzero"`

	// Indexes Map of index name to index configuration. Indexes enable different query capabilities:
	// - Full-text indexes for BM25 search
	// - Vector indexes for semantic similarity
	// - Multimodal indexes for images/audio/video
	//
	// You can add multiple indexes to support different query patterns.
	Indexes map[string]IndexConfig `json:"indexes,omitempty,omitzero"`

	// NumShards Number of shards to create for the table. Data is partitioned across shards based on key ranges.
	//
	// **Sizing Guidelines:**
	// - Small datasets (<100K docs): 1-3 shards
	// - Medium datasets (100K-1M docs): 3-10 shards
	// - Large datasets (>1M docs): 10+ shards
	//
	// More shards enable better parallelism but increase overhead. Choose based on expected data size and query patterns.
	//
	// **When to Add More Shards:**
	//
	// Antfly supports **online shard reallocation** without downtime. Add more shards when:
	// - Individual shards exceed size thresholds (configurable)
	// - Query latency increases due to large shard size
	// - Need better parallelism for write-heavy workloads
	//
	// Use the internal `/reallocate` endpoint to trigger automatic shard splitting:
	// ```bash
	// POST /_internal/v1/reallocate
	// ```
	//
	// This enqueues a reallocation request that the leader processes asynchronously, splitting
	// large shards and redistributing data without service interruption.
	//
	// **Advantages over Elasticsearch:**
	// - Automatic shard splitting (no manual reindexing required)
	// - Online operation (no downtime)
	// - Transparent to applications (keys remain accessible during reallocation)
	NumShards uint `json:"num_shards,omitempty,omitzero"`

	// Schema Schema definition for a table with multiple document types
	Schema TableSchema `json:"schema,omitempty,omitzero"`
}

// CreateUserRequest defines model for CreateUserRequest.
type CreateUserRequest struct {
	// InitialPolicies Optional list of initial permissions for the user.
	InitialPolicies []Permission `json:"initial_policies,omitzero"`
	Password        string       `json:"password"`

	// Username Username for the new user. If provided in the path, this field can be omitted or must match the path parameter.
	Username string `json:"username,omitempty,omitzero"`
}

// Credentials defines model for Credentials.
type Credentials struct {
	// AccessKeyId AWS access key ID. Supports keystore syntax for secret lookup. Falls back to AWS_ACCESS_KEY_ID environment variable if not set.
	AccessKeyId string `json:"access_key_id,omitempty,omitzero"`

	// Endpoint S3-compatible endpoint (e.g., 's3.amazonaws.com' or 'localhost:9000' for MinIO)
	Endpoint string `json:"endpoint,omitempty,omitzero"`

	// SecretAccessKey AWS secret access key. Supports keystore syntax for secret lookup. Falls back to AWS_SECRET_ACCESS_KEY environment variable if not set.
	SecretAccessKey string `json:"secret_access_key,omitempty,omitzero"`

	// SessionToken Optional AWS session token for temporary credentials. Supports keystore syntax for secret lookup.
	SessionToken string `json:"session_token,omitempty,omitzero"`

	// UseSsl Enable SSL/TLS for S3 connections (default: true for AWS, false for local MinIO)
	UseSsl bool `json:"use_ssl,omitempty,omitzero"`
}

// DateRangeStringQuery defines model for DateRangeStringQuery.
type DateRangeStringQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost          Boost     `json:"boost,omitzero"`
	DatetimeParser string    `json:"datetime_parser,omitempty,omitzero"`
	End            time.Time `json:"end,omitempty,omitzero"`
	Field          string    `json:"field,omitempty,omitzero"`
	InclusiveEnd   bool      `json:"inclusive_end,omitzero"`
	InclusiveStart bool      `json:"inclusive_start,omitzero"`
	Start          time.Time `json:"start,omitempty,omitzero"`
}

// DisjunctionQuery defines model for DisjunctionQuery.
type DisjunctionQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost     Boost   `json:"boost,omitzero"`
	Disjuncts []Query `json:"disjuncts"`
	Min       float64 `json:"min,omitempty,omitzero"`
}

// DistanceRange defines model for DistanceRange.
type DistanceRange struct {
	// From Minimum distance (inclusive)
	From *float64 `json:"from,omitempty"`

	// Name Name of the distance range bucket
	Name string `json:"name"`

	// To Maximum distance (exclusive)
	To *float64 `json:"to,omitempty"`
}

// DistanceUnit Distance unit for geo aggregations:
// - m: meters
// - km: kilometers
// - mi: miles
// - ft: feet
// - yd: yards
type DistanceUnit string

// DocIdQuery defines model for DocIdQuery.
type DocIdQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost Boost    `json:"boost,omitzero"`
	Ids   []string `json:"ids"`
}

// DocumentSchema Defines the structure of a document type
type DocumentSchema struct {
	// Description A description of the document type.
	Description string `json:"description,omitempty,omitzero"`

	// Schema A valid JSON Schema defining the document's structure.
	// This is used to infer indexing rules and field types.
	Schema map[string]interface{} `json:"schema,omitempty,omitzero"`
}

// DuckDuckGoSearchConfig defines model for DuckDuckGoSearchConfig.
type DuckDuckGoSearchConfig struct {
	// Language Preferred language for results (e.g., 'en', 'es', 'fr')
	Language string `json:"language,omitempty,omitzero"`

	// MaxResults Maximum number of search results to return
	MaxResults int `json:"max_results,omitempty,omitzero"`

	// NoHtml Remove HTML from results
	NoHtml bool `json:"no_html,omitempty,omitzero"`

	// NoRedirect Skip HTTP redirect for bang queries
	NoRedirect bool `json:"no_redirect,omitempty,omitzero"`

	// Provider The web search provider to use.
	//
	// - **google**: Google Custom Search API (requires CSE setup)
	// - **bing**: Microsoft Bing Web Search API
	// - **serper**: Serper.dev Google Search API (simpler setup)
	// - **tavily**: Tavily AI Search API (optimized for RAG)
	// - **brave**: Brave Search API
	// - **duckduckgo**: DuckDuckGo Instant Answer API (limited, no API key)
	Provider WebSearchProvider `json:"provider"`

	// Region Preferred region for results (e.g., 'us', 'uk', 'de')
	Region string `json:"region,omitempty,omitzero"`

	// SafeSearch Enable safe search filtering
	SafeSearch *bool `json:"safe_search,omitempty"`

	// TimeoutMs Request timeout in milliseconds
	TimeoutMs int `json:"timeout_ms,omitempty,omitzero"`
}

// DynamicTemplate A rule for mapping dynamically detected fields. Templates are checked in order
// and the first matching template's mapping is used.
type DynamicTemplate struct {
	// Mapping Field mapping to apply when a dynamic template matches
	Mapping TemplateFieldMapping `json:"mapping,omitempty,omitzero"`

	// Match Glob pattern for field name (last path element).
	// Supports * and ** wildcards. Example: "*_text" matches "title_text", "body_text"
	Match string `json:"match,omitempty,omitzero"`

	// MatchMappingType Filter by detected JSON type
	MatchMappingType DynamicTemplateMatchMappingType `json:"match_mapping_type,omitempty,omitzero"`

	// Name Optional identifier for the template (useful for debugging)
	Name string `json:"name,omitempty,omitzero"`

	// PathMatch Glob pattern for the full dotted path. Supports ** for matching multiple segments.
	// Example: "metadata.**" matches "metadata.author", "metadata.tags.primary"
	PathMatch string `json:"path_match,omitempty,omitzero"`

	// PathUnmatch Path exclusion pattern. If it matches the full path, the template is skipped.
	PathUnmatch string `json:"path_unmatch,omitempty,omitzero"`

	// Unmatch Exclusion pattern for field name. If it matches, the template is skipped.
	// Example: "skip_*" would exclude fields like "skip_this"
	Unmatch string `json:"unmatch,omitempty,omitzero"`
}

// DynamicTemplateMatchMappingType Filter by detected JSON type
type DynamicTemplateMatchMappingType string

// Edge A typed, weighted connection between documents
type Edge struct {
	// CreatedAt When the edge was created
	CreatedAt time.Time `json:"created_at,omitempty,omitzero"`

	// Metadata Optional edge metadata
	Metadata map[string]interface{} `json:"metadata,omitempty,omitzero"`

	// Source Base64-encoded source document key
	Source []byte `json:"source"`

	// Target Base64-encoded target document key
	Target []byte `json:"target"`

	// Type Edge type (e.g., "cites", "similar_to", "authored_by")
	Type string `json:"type"`

	// UpdatedAt When the edge was last updated
	UpdatedAt time.Time `json:"updated_at,omitempty,omitzero"`

	// Weight Edge weight/confidence (0.0 to 1.0)
	Weight float64 `json:"weight"`
}

// EdgeDirection Direction of edges to query:
// - out: Outgoing edges from the node
// - in: Incoming edges to the node
// - both: Both outgoing and incoming edges
type EdgeDirection string

// EdgeTypeConfig Configuration for a specific edge type
type EdgeTypeConfig struct {
	// AllowSelfLoops Whether to allow edges from a node to itself
	AllowSelfLoops bool `json:"allow_self_loops,omitempty,omitzero"`

	// Field Document field containing target node key(s) for automatic edge creation.
	// Supports string (single target) or array of strings (multiple targets).
	// When omitted, edges must be provided explicitly via _edges.
	Field string `json:"field,omitempty,omitzero"`

	// MaxWeight Maximum allowed edge weight
	MaxWeight float64 `json:"max_weight,omitempty,omitzero"`

	// MinWeight Minimum allowed edge weight
	MinWeight float64 `json:"min_weight,omitempty,omitzero"`

	// Name Edge type name (e.g., 'cites', 'similar_to')
	Name string `json:"name"`

	// RequiredMetadata Required metadata fields for this edge type
	RequiredMetadata []string `json:"required_metadata,omitempty,omitzero"`

	// Topology Topology constraint for this edge type:
	// - tree: Single parent per node, no cycles
	// - graph: No constraints (default)
	Topology EdgeTypeConfigTopology `json:"topology,omitempty,omitzero"`
}

// EdgeTypeConfigTopology Topology constraint for this edge type:
// - tree: Single parent per node, no cycles
// - graph: No constraints (default)
type EdgeTypeConfigTopology string

// EdgesResponse defines model for EdgesResponse.
type EdgesResponse struct {
	// Count Total number of edges returned
	Count int    `json:"count,omitempty,omitzero"`
	Edges []Edge `json:"edges,omitempty,omitzero"`
}

// EmbedderConfig defines model for EmbedderConfig.
type EmbedderConfig struct {
	// Provider The embedding provider to use.
	Provider EmbedderProvider `json:"provider"`
	union    json.RawMessage
}

// EmbedderProvider The embedding provider to use.
type EmbedderProvider string

// EmbeddingIndexConfig defines model for EmbeddingIndexConfig.
type EmbeddingIndexConfig struct {
	// Chunker A unified configuration for a chunking provider.
	Chunker ChunkerConfig `json:"chunker,omitempty,omitzero"`

	// Dimension Vector dimension
	Dimension int `json:"dimension"`

	// Embedder A unified configuration for an embedding provider.
	//
	// Embedders can be configured with templates to customize how documents are
	// converted to text before embedding. Templates use Handlebars syntax and
	// support various built-in helpers.
	//
	// **Template System:**
	// - **Syntax**: Handlebars templating (https://handlebarsjs.com/guide/)
	// - **Caching**: Templates are automatically cached with configurable TTL (default: 5 minutes)
	// - **Context**: Templates receive the full document as context
	//
	// **Built-in Helpers:**
	//
	// 1. **scrubHtml** - Remove script/style tags and extract clean text from HTML
	//    ```handlebars
	//    {{scrubHtml html_content}}
	//    ```
	//    - Removes `<script>` and `<style>` tags
	//    - Adds newlines after block elements (p, div, h1-h6, li, etc.)
	//    - Returns plain text with preserved readability
	//
	// 2. **eq** - Equality comparison for conditionals
	//    ```handlebars
	//    {{#if (eq status "active")}}Active user{{/if}}
	//    {{#if (eq @key "special")}}Special field{{/if}}
	//    ```
	//
	// 3. **media** - GenKit dotprompt media directive for multimodal content
	//    ```handlebars
	//    {{media url=imageDataURI}}
	//    {{media url=this.image_url}}
	//    {{media url="https://example.com/image.jpg"}}
	//    {{media url="s3://endpoint/bucket/image.png"}}
	//    {{media url="file:///path/to/image.jpg"}}
	//    ```
	//
	//    **Supported URL Schemes:**
	//    - `data:` - Base64 encoded data URIs (e.g., `data:image/jpeg;base64,...`)
	//    - `http://` / `https://` - Web URLs with automatic content type detection
	//    - `file://` - Local filesystem paths
	//    - `s3://` - S3-compatible storage (format: `s3://endpoint/bucket/key`)
	//
	//    **Automatic Content Processing:**
	//    - **Images**: Downloaded, resized (if needed), converted to data URIs
	//    - **PDFs**: Text extracted or first page rendered as image
	//    - **HTML**: Readable text extracted using Mozilla Readability
	//
	//    **Security Controls:**
	//    Downloads are protected by content security settings (see Configuration Reference):
	//    - Allowed host whitelist
	//    - Private IP blocking (prevents SSRF attacks)
	//    - Download size limits (default: 100MB)
	//    - Download timeouts (default: 30s)
	//    - Image dimension limits (default: 2048px, auto-resized)
	//
	//    See: https://antfly.io/docs/configuration#security--cors
	//
	// 4. **encodeToon** - Encode data in TOON format (Token-Oriented Object Notation)
	//    ```handlebars
	//    {{encodeToon this.fields}}
	//    {{encodeToon this.fields lengthMarker=false indent=4}}
	//    {{encodeToon this.fields delimiter="\t"}}
	//    ```
	//
	//    **What is TOON?**
	//    TOON is a compact, human-readable format designed for passing structured data to LLMs.
	//    It provides **30-60% token reduction** compared to JSON while maintaining high LLM
	//    comprehension accuracy.
	//
	//    **Key Features:**
	//    - Compact syntax using `:` for key-value pairs
	//    - Array length markers: `tags[#3]: ai,search,ml`
	//    - Tabular format for uniform data structures
	//    - Optimized for LLM parsing and understanding
	//    - Maintains human readability
	//
	//    **Benefits:**
	//    - **Lower API costs** - Reduced token usage means lower LLM API costs
	//    - **Faster responses** - Less tokens to process
	//    - **More context** - Fit more documents within token limits
	//
	//    **Options:**
	//    - `lengthMarker` (bool): Add # prefix to array counts like `[#3]` (default: true)
	//    - `indent` (int): Indentation spacing for nested objects (default: 2)
	//    - `delimiter` (string): Field separator for tabular arrays (default: none, use `"\t"` for tabs)
	//
	//    **Example output:**
	//    ```
	//    title: Introduction to Vector Search
	//    author: Jane Doe
	//    tags[#3]: ai,search,ml
	//    metadata:
	//      edition: 2
	//      pages: 450
	//    ```
	//
	//    **Default in RAG:** TOON is the default format for document rendering in RAG queries.
	//
	//    **References:**
	//    - TOON Specification: https://github.com/toon-format/toon
	//    - Go Implementation: https://github.com/alpkeskin/gotoon
	//
	// **Template Examples:**
	//
	// Document with metadata:
	// ```handlebars
	// Title: {{metadata.title}}
	// Date: {{metadata.date}}
	// Tags: {{#each metadata.tags}}{{this}}, {{/each}}
	//
	// {{content}}
	// ```
	//
	// HTML content extraction:
	// ```handlebars
	// Product: {{name}}
	// Description: {{scrubHtml description_html}}
	// Price: ${{price}}
	// ```
	//
	// Multimodal with image:
	// ```handlebars
	// Product: {{title}}
	// {{media url=image}}
	// Description: {{description}}
	// ```
	//
	// Conditional formatting:
	// ```handlebars
	// {{title}}
	// {{#if author}}By: {{author}}{{/if}}
	// {{#if (eq category "premium")}}â­ Premium Content{{/if}}
	// {{body}}
	// ```
	//
	// **Environment Variables:**
	// - `GEMINI_API_KEY` - API key for Google AI
	// - `OPENAI_API_KEY` - API key for OpenAI
	// - `OPENAI_BASE_URL` - Base URL for OpenAI-compatible APIs
	// - `OLLAMA_HOST` - Ollama server URL (e.g., http://localhost:11434)
	//
	// **Importing Pre-computed Embeddings:**
	//
	// You can import existing embeddings (from OpenAI, Cohere, or any provider) by including
	// them directly in your documents using the `_embeddings` field. This bypasses the
	// embedding generation step and writes vectors directly to the index.
	//
	// **Steps:**
	// 1. Create the index first with the appropriate dimension
	// 2. Write documents with `_embeddings: { "<indexName>": [...<embedding>...] }`
	//
	// **Example:**
	// ```json
	// {
	//   "title": "My Document",
	//   "content": "Document text...",
	//   "_embeddings": {
	//     "my_vector_index": [0.1, 0.2, 0.3, ...]
	//   }
	// }
	// ```
	//
	// **Use Cases:**
	// - Migrating from another vector database with existing embeddings
	// - Using embeddings generated by external systems
	// - Importing pre-computed OpenAI, Cohere, or other provider embeddings
	// - Batch processing embeddings offline before ingestion
	Embedder EmbedderConfig `json:"embedder,omitempty,omitzero"`

	// Field Field to extract embeddings from
	Field string `json:"field,omitempty,omitzero"`

	// MemOnly Whether to use in-memory only storage
	MemOnly bool `json:"mem_only,omitempty,omitzero"`

	// Summarizer A unified configuration for a generative AI provider.
	//
	// Generators can be configured with custom prompts using templates. Templates use
	// Handlebars syntax and support various built-in helpers for formatting and data manipulation.
	//
	// **Template System:**
	// - **Syntax**: Handlebars templating (https://handlebarsjs.com/guide/)
	// - **Caching**: Templates are automatically cached with configurable TTL (default: 5 minutes)
	// - **Context**: Templates receive the full context data passed to the generator
	//
	// **Built-in Helpers:**
	//
	// 1. **scrubHtml** - Remove script/style tags and extract clean text from HTML
	//    ```handlebars
	//    {{scrubHtml html_content}}
	//    ```
	//    - Removes `<script>` and `<style>` tags
	//    - Adds newlines after block elements (p, div, h1-h6, li, etc.)
	//    - Returns plain text with preserved readability
	//    - Useful for cleaning web content before summarization
	//
	// 2. **eq** - Equality comparison for conditionals
	//    ```handlebars
	//    {{#if (eq status "active")}}Active{{/if}}
	//    {{#if (eq @key "special")}}Special field{{/if}}
	//    ```
	//    - Use in `{{#if}}` blocks for conditional logic
	//    - Compares any two values for equality
	//
	// 3. **media** - GenKit dotprompt media directive for multimodal content
	//    ```handlebars
	//    {{media url=imageDataURI}}
	//    {{media url=this.image_url}}
	//    {{media url="https://example.com/image.jpg"}}
	//    {{media url="s3://endpoint/bucket/image.png"}}
	//    {{media url="file:///path/to/image.jpg"}}
	//    ```
	//
	//    **Supported URL Schemes:**
	//    - `data:` - Base64 encoded data URIs (e.g., `data:image/jpeg;base64,...`)
	//    - `http://` / `https://` - Web URLs with automatic content type detection
	//    - `file://` - Local filesystem paths
	//    - `s3://` - S3-compatible storage (format: `s3://endpoint/bucket/key`)
	//
	//    **Automatic Content Processing:**
	//    - **Images**: Downloaded, resized (if needed), converted to data URIs
	//    - **PDFs**: Text extracted or first page rendered as image
	//    - **HTML**: Readable text extracted using Mozilla Readability
	//
	//    **Security Controls:**
	//    Downloads are protected by content security settings (see Configuration Reference):
	//    - Allowed host whitelist
	//    - Private IP blocking (prevents SSRF attacks)
	//    - Download size limits (default: 100MB)
	//    - Download timeouts (default: 30s)
	//    - Image dimension limits (default: 2048px, auto-resized)
	//
	//    See: https://antfly.io/docs/configuration#security--cors
	//
	// 4. **encodeToon** - Encode data in TOON format (Token-Oriented Object Notation)
	//    ```handlebars
	//    {{encodeToon this.fields}}
	//    {{encodeToon this.fields lengthMarker=false indent=4}}
	//    {{encodeToon this.fields delimiter="\t"}}
	//    ```
	//
	//    **What is TOON?**
	//    TOON is a compact, human-readable format designed for passing structured data to LLMs.
	//    It provides **30-60% token reduction** compared to JSON while maintaining high LLM
	//    comprehension accuracy.
	//
	//    **Key Features:**
	//    - Compact syntax using `:` for key-value pairs
	//    - Array length markers: `tags[#3]: ai,search,ml`
	//    - Tabular format for uniform data structures
	//    - Optimized for LLM parsing and understanding
	//    - Maintains human readability
	//
	//    **Benefits:**
	//    - **Lower API costs** - Reduced token usage means lower LLM API costs
	//    - **Faster responses** - Less tokens to process
	//    - **More context** - Fit more documents within token limits
	//
	//    **Options:**
	//    - `lengthMarker` (bool): Add # prefix to array counts like `[#3]` (default: true)
	//    - `indent` (int): Indentation spacing for nested objects (default: 2)
	//    - `delimiter` (string): Field separator for tabular arrays (default: none, use `"\t"` for tabs)
	//
	//    **Example output:**
	//    ```
	//    title: Introduction to Vector Search
	//    author: Jane Doe
	//    tags[#3]: ai,search,ml
	//    metadata:
	//      edition: 2
	//      pages: 450
	//    ```
	//
	//    **Default in RAG:** TOON is the default format for document rendering in RAG queries.
	//
	//    **References:**
	//    - TOON Specification: https://github.com/toon-format/toon
	//    - Go Implementation: https://github.com/alpkeskin/gotoon
	//
	// **Template Examples:**
	//
	// RAG summarization with document references:
	// ```handlebars
	// Based on these documents, provide a comprehensive summary:
	//
	// {{#each documents}}
	// Document {{this.id}}:
	// {{scrubHtml this.content}}
	//
	// {{/each}}
	//
	// Valid document IDs: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
	// ```
	//
	// Conditional formatting:
	// ```handlebars
	// {{#if system_prompt}}System: {{system_prompt}}{{/if}}
	//
	// User Query: {{query}}
	//
	// {{#if context}}
	// Context:
	// {{#each context}}
	// - {{this}}
	// {{/each}}
	// {{/if}}
	// ```
	//
	// Multimodal prompt with images:
	// ```handlebars
	// Analyze this image:
	// {{media url=image_url}}
	//
	// Focus on: {{focus_area}}
	// ```
	//
	// Structured data encoding:
	// ```handlebars
	// User Profile:
	// {{encodeToon user_data indent=2 lengthMarker=true}}
	//
	// Please analyze this profile.
	// ```
	//
	// **Common Use Cases:**
	// - **RAG (Retrieval-Augmented Generation)**: Format retrieved documents with citations
	// - **Summarization**: Clean HTML content and structure summaries
	// - **Query Classification**: Format queries with metadata for better classification
	// - **Multimodal**: Include images/audio/video in prompts
	// - **Data Formatting**: Convert structured data to readable text
	//
	// **Best Practices:**
	// - Keep templates simple - complex logic belongs in application code
	// - Use clear, descriptive field names in context
	// - Handle missing fields gracefully (templates use "missingkey=zero" by default)
	// - Test templates with representative data before production use
	Summarizer GeneratorConfig `json:"summarizer,omitempty,omitzero"`

	// Template Handlebars template for generating prompts. See https://handlebarsjs.com/guide/ for more information.
	Template string `json:"template,omitempty,omitzero"`
}

// EmbeddingIndexStats defines model for EmbeddingIndexStats.
type EmbeddingIndexStats struct {
	// DiskUsage Size of the index in bytes
	DiskUsage uint64 `json:"disk_usage,omitempty,omitzero"`

	// Error Error message if stats could not be retrieved
	Error string `json:"error,omitempty,omitzero"`

	// TotalIndexed Number of vectors in the index
	TotalIndexed uint64 `json:"total_indexed,omitempty,omitzero"`

	// TotalNodes Total number of nodes in the index
	TotalNodes uint64 `json:"total_nodes,omitempty,omitzero"`
}

// Error defines model for Error.
type Error struct {
	Error string `json:"error"`
}

// EvalConfig Configuration for inline evaluation of query results.
// Add to RAGRequest, QueryRequest, or AnswerAgentRequest.
type EvalConfig struct {
	// Evaluators List of evaluators to run
	Evaluators []EvaluatorName `json:"evaluators,omitempty,omitzero"`

	// GroundTruth Ground truth data for evaluation
	GroundTruth GroundTruth `json:"ground_truth,omitempty,omitzero"`

	// Judge A unified configuration for a generative AI provider.
	//
	// Generators can be configured with custom prompts using templates. Templates use
	// Handlebars syntax and support various built-in helpers for formatting and data manipulation.
	//
	// **Template System:**
	// - **Syntax**: Handlebars templating (https://handlebarsjs.com/guide/)
	// - **Caching**: Templates are automatically cached with configurable TTL (default: 5 minutes)
	// - **Context**: Templates receive the full context data passed to the generator
	//
	// **Built-in Helpers:**
	//
	// 1. **scrubHtml** - Remove script/style tags and extract clean text from HTML
	//    ```handlebars
	//    {{scrubHtml html_content}}
	//    ```
	//    - Removes `<script>` and `<style>` tags
	//    - Adds newlines after block elements (p, div, h1-h6, li, etc.)
	//    - Returns plain text with preserved readability
	//    - Useful for cleaning web content before summarization
	//
	// 2. **eq** - Equality comparison for conditionals
	//    ```handlebars
	//    {{#if (eq status "active")}}Active{{/if}}
	//    {{#if (eq @key "special")}}Special field{{/if}}
	//    ```
	//    - Use in `{{#if}}` blocks for conditional logic
	//    - Compares any two values for equality
	//
	// 3. **media** - GenKit dotprompt media directive for multimodal content
	//    ```handlebars
	//    {{media url=imageDataURI}}
	//    {{media url=this.image_url}}
	//    {{media url="https://example.com/image.jpg"}}
	//    {{media url="s3://endpoint/bucket/image.png"}}
	//    {{media url="file:///path/to/image.jpg"}}
	//    ```
	//
	//    **Supported URL Schemes:**
	//    - `data:` - Base64 encoded data URIs (e.g., `data:image/jpeg;base64,...`)
	//    - `http://` / `https://` - Web URLs with automatic content type detection
	//    - `file://` - Local filesystem paths
	//    - `s3://` - S3-compatible storage (format: `s3://endpoint/bucket/key`)
	//
	//    **Automatic Content Processing:**
	//    - **Images**: Downloaded, resized (if needed), converted to data URIs
	//    - **PDFs**: Text extracted or first page rendered as image
	//    - **HTML**: Readable text extracted using Mozilla Readability
	//
	//    **Security Controls:**
	//    Downloads are protected by content security settings (see Configuration Reference):
	//    - Allowed host whitelist
	//    - Private IP blocking (prevents SSRF attacks)
	//    - Download size limits (default: 100MB)
	//    - Download timeouts (default: 30s)
	//    - Image dimension limits (default: 2048px, auto-resized)
	//
	//    See: https://antfly.io/docs/configuration#security--cors
	//
	// 4. **encodeToon** - Encode data in TOON format (Token-Oriented Object Notation)
	//    ```handlebars
	//    {{encodeToon this.fields}}
	//    {{encodeToon this.fields lengthMarker=false indent=4}}
	//    {{encodeToon this.fields delimiter="\t"}}
	//    ```
	//
	//    **What is TOON?**
	//    TOON is a compact, human-readable format designed for passing structured data to LLMs.
	//    It provides **30-60% token reduction** compared to JSON while maintaining high LLM
	//    comprehension accuracy.
	//
	//    **Key Features:**
	//    - Compact syntax using `:` for key-value pairs
	//    - Array length markers: `tags[#3]: ai,search,ml`
	//    - Tabular format for uniform data structures
	//    - Optimized for LLM parsing and understanding
	//    - Maintains human readability
	//
	//    **Benefits:**
	//    - **Lower API costs** - Reduced token usage means lower LLM API costs
	//    - **Faster responses** - Less tokens to process
	//    - **More context** - Fit more documents within token limits
	//
	//    **Options:**
	//    - `lengthMarker` (bool): Add # prefix to array counts like `[#3]` (default: true)
	//    - `indent` (int): Indentation spacing for nested objects (default: 2)
	//    - `delimiter` (string): Field separator for tabular arrays (default: none, use `"\t"` for tabs)
	//
	//    **Example output:**
	//    ```
	//    title: Introduction to Vector Search
	//    author: Jane Doe
	//    tags[#3]: ai,search,ml
	//    metadata:
	//      edition: 2
	//      pages: 450
	//    ```
	//
	//    **Default in RAG:** TOON is the default format for document rendering in RAG queries.
	//
	//    **References:**
	//    - TOON Specification: https://github.com/toon-format/toon
	//    - Go Implementation: https://github.com/alpkeskin/gotoon
	//
	// **Template Examples:**
	//
	// RAG summarization with document references:
	// ```handlebars
	// Based on these documents, provide a comprehensive summary:
	//
	// {{#each documents}}
	// Document {{this.id}}:
	// {{scrubHtml this.content}}
	//
	// {{/each}}
	//
	// Valid document IDs: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
	// ```
	//
	// Conditional formatting:
	// ```handlebars
	// {{#if system_prompt}}System: {{system_prompt}}{{/if}}
	//
	// User Query: {{query}}
	//
	// {{#if context}}
	// Context:
	// {{#each context}}
	// - {{this}}
	// {{/each}}
	// {{/if}}
	// ```
	//
	// Multimodal prompt with images:
	// ```handlebars
	// Analyze this image:
	// {{media url=image_url}}
	//
	// Focus on: {{focus_area}}
	// ```
	//
	// Structured data encoding:
	// ```handlebars
	// User Profile:
	// {{encodeToon user_data indent=2 lengthMarker=true}}
	//
	// Please analyze this profile.
	// ```
	//
	// **Common Use Cases:**
	// - **RAG (Retrieval-Augmented Generation)**: Format retrieved documents with citations
	// - **Summarization**: Clean HTML content and structure summaries
	// - **Query Classification**: Format queries with metadata for better classification
	// - **Multimodal**: Include images/audio/video in prompts
	// - **Data Formatting**: Convert structured data to readable text
	//
	// **Best Practices:**
	// - Keep templates simple - complex logic belongs in application code
	// - Use clear, descriptive field names in context
	// - Handle missing fields gracefully (templates use "missingkey=zero" by default)
	// - Test templates with representative data before production use
	Judge GeneratorConfig `json:"judge,omitempty,omitzero"`

	// Options Options for evaluation behavior
	Options EvalOptions `json:"options,omitempty,omitzero"`
}

// EvalOptions Options for evaluation behavior
type EvalOptions struct {
	// K K value for @K metrics (precision@k, recall@k, ndcg@k)
	K int `json:"k,omitempty,omitzero"`

	// PassThreshold Score threshold for pass/fail determination
	PassThreshold float32 `json:"pass_threshold,omitempty,omitzero"`

	// TimeoutSeconds Timeout for evaluation in seconds
	TimeoutSeconds int `json:"timeout_seconds,omitempty,omitzero"`
}

// EvalRequest Standalone evaluation request for POST /eval endpoint.
// Useful for testing evaluators without running a query.
type EvalRequest struct {
	// Context Retrieved documents/context
	Context []map[string]interface{} `json:"context,omitempty,omitzero"`

	// Evaluators List of evaluators to run
	Evaluators []EvaluatorName `json:"evaluators"`

	// GroundTruth Ground truth data for evaluation
	GroundTruth GroundTruth `json:"ground_truth,omitempty,omitzero"`

	// Judge A unified configuration for a generative AI provider.
	//
	// Generators can be configured with custom prompts using templates. Templates use
	// Handlebars syntax and support various built-in helpers for formatting and data manipulation.
	//
	// **Template System:**
	// - **Syntax**: Handlebars templating (https://handlebarsjs.com/guide/)
	// - **Caching**: Templates are automatically cached with configurable TTL (default: 5 minutes)
	// - **Context**: Templates receive the full context data passed to the generator
	//
	// **Built-in Helpers:**
	//
	// 1. **scrubHtml** - Remove script/style tags and extract clean text from HTML
	//    ```handlebars
	//    {{scrubHtml html_content}}
	//    ```
	//    - Removes `<script>` and `<style>` tags
	//    - Adds newlines after block elements (p, div, h1-h6, li, etc.)
	//    - Returns plain text with preserved readability
	//    - Useful for cleaning web content before summarization
	//
	// 2. **eq** - Equality comparison for conditionals
	//    ```handlebars
	//    {{#if (eq status "active")}}Active{{/if}}
	//    {{#if (eq @key "special")}}Special field{{/if}}
	//    ```
	//    - Use in `{{#if}}` blocks for conditional logic
	//    - Compares any two values for equality
	//
	// 3. **media** - GenKit dotprompt media directive for multimodal content
	//    ```handlebars
	//    {{media url=imageDataURI}}
	//    {{media url=this.image_url}}
	//    {{media url="https://example.com/image.jpg"}}
	//    {{media url="s3://endpoint/bucket/image.png"}}
	//    {{media url="file:///path/to/image.jpg"}}
	//    ```
	//
	//    **Supported URL Schemes:**
	//    - `data:` - Base64 encoded data URIs (e.g., `data:image/jpeg;base64,...`)
	//    - `http://` / `https://` - Web URLs with automatic content type detection
	//    - `file://` - Local filesystem paths
	//    - `s3://` - S3-compatible storage (format: `s3://endpoint/bucket/key`)
	//
	//    **Automatic Content Processing:**
	//    - **Images**: Downloaded, resized (if needed), converted to data URIs
	//    - **PDFs**: Text extracted or first page rendered as image
	//    - **HTML**: Readable text extracted using Mozilla Readability
	//
	//    **Security Controls:**
	//    Downloads are protected by content security settings (see Configuration Reference):
	//    - Allowed host whitelist
	//    - Private IP blocking (prevents SSRF attacks)
	//    - Download size limits (default: 100MB)
	//    - Download timeouts (default: 30s)
	//    - Image dimension limits (default: 2048px, auto-resized)
	//
	//    See: https://antfly.io/docs/configuration#security--cors
	//
	// 4. **encodeToon** - Encode data in TOON format (Token-Oriented Object Notation)
	//    ```handlebars
	//    {{encodeToon this.fields}}
	//    {{encodeToon this.fields lengthMarker=false indent=4}}
	//    {{encodeToon this.fields delimiter="\t"}}
	//    ```
	//
	//    **What is TOON?**
	//    TOON is a compact, human-readable format designed for passing structured data to LLMs.
	//    It provides **30-60% token reduction** compared to JSON while maintaining high LLM
	//    comprehension accuracy.
	//
	//    **Key Features:**
	//    - Compact syntax using `:` for key-value pairs
	//    - Array length markers: `tags[#3]: ai,search,ml`
	//    - Tabular format for uniform data structures
	//    - Optimized for LLM parsing and understanding
	//    - Maintains human readability
	//
	//    **Benefits:**
	//    - **Lower API costs** - Reduced token usage means lower LLM API costs
	//    - **Faster responses** - Less tokens to process
	//    - **More context** - Fit more documents within token limits
	//
	//    **Options:**
	//    - `lengthMarker` (bool): Add # prefix to array counts like `[#3]` (default: true)
	//    - `indent` (int): Indentation spacing for nested objects (default: 2)
	//    - `delimiter` (string): Field separator for tabular arrays (default: none, use `"\t"` for tabs)
	//
	//    **Example output:**
	//    ```
	//    title: Introduction to Vector Search
	//    author: Jane Doe
	//    tags[#3]: ai,search,ml
	//    metadata:
	//      edition: 2
	//      pages: 450
	//    ```
	//
	//    **Default in RAG:** TOON is the default format for document rendering in RAG queries.
	//
	//    **References:**
	//    - TOON Specification: https://github.com/toon-format/toon
	//    - Go Implementation: https://github.com/alpkeskin/gotoon
	//
	// **Template Examples:**
	//
	// RAG summarization with document references:
	// ```handlebars
	// Based on these documents, provide a comprehensive summary:
	//
	// {{#each documents}}
	// Document {{this.id}}:
	// {{scrubHtml this.content}}
	//
	// {{/each}}
	//
	// Valid document IDs: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
	// ```
	//
	// Conditional formatting:
	// ```handlebars
	// {{#if system_prompt}}System: {{system_prompt}}{{/if}}
	//
	// User Query: {{query}}
	//
	// {{#if context}}
	// Context:
	// {{#each context}}
	// - {{this}}
	// {{/each}}
	// {{/if}}
	// ```
	//
	// Multimodal prompt with images:
	// ```handlebars
	// Analyze this image:
	// {{media url=image_url}}
	//
	// Focus on: {{focus_area}}
	// ```
	//
	// Structured data encoding:
	// ```handlebars
	// User Profile:
	// {{encodeToon user_data indent=2 lengthMarker=true}}
	//
	// Please analyze this profile.
	// ```
	//
	// **Common Use Cases:**
	// - **RAG (Retrieval-Augmented Generation)**: Format retrieved documents with citations
	// - **Summarization**: Clean HTML content and structure summaries
	// - **Query Classification**: Format queries with metadata for better classification
	// - **Multimodal**: Include images/audio/video in prompts
	// - **Data Formatting**: Convert structured data to readable text
	//
	// **Best Practices:**
	// - Keep templates simple - complex logic belongs in application code
	// - Use clear, descriptive field names in context
	// - Handle missing fields gracefully (templates use "missingkey=zero" by default)
	// - Test templates with representative data before production use
	Judge GeneratorConfig `json:"judge,omitempty,omitzero"`

	// Options Options for evaluation behavior
	Options EvalOptions `json:"options,omitempty,omitzero"`

	// Output Generated output to evaluate (optional for retrieval-only)
	Output string `json:"output,omitempty,omitzero"`

	// Query Original query/input to evaluate
	Query string `json:"query,omitempty,omitzero"`

	// RetrievedIds IDs of retrieved documents (for retrieval metrics)
	RetrievedIds []string `json:"retrieved_ids,omitempty,omitzero"`
}

// EvalResult Complete evaluation result
type EvalResult struct {
	// DurationMs Total evaluation duration in milliseconds
	DurationMs int `json:"duration_ms,omitempty,omitzero"`

	// Scores Scores organized by category
	Scores EvalScores `json:"scores,omitempty,omitzero"`

	// Summary Aggregate statistics across all evaluators
	Summary EvalSummary `json:"summary,omitempty,omitzero"`
}

// EvalScores Scores organized by category
type EvalScores struct {
	// Generation Generation quality scores (faithfulness, relevance, etc.)
	Generation map[string]EvaluatorScore `json:"generation,omitempty,omitzero"`

	// Retrieval Retrieval metric scores (recall, precision, ndcg, etc.)
	Retrieval map[string]EvaluatorScore `json:"retrieval,omitempty,omitzero"`
}

// EvalSummary Aggregate statistics across all evaluators
type EvalSummary struct {
	// AverageScore Average score across all evaluators
	AverageScore float32 `json:"average_score,omitempty,omitzero"`

	// Failed Number of evaluators that failed
	Failed int `json:"failed,omitempty,omitzero"`

	// Passed Number of evaluators that passed
	Passed int `json:"passed,omitempty,omitzero"`

	// Total Total number of evaluators run
	Total int `json:"total,omitempty,omitzero"`
}

// EvaluatorName Available evaluator types:
//
// **Retrieval metrics** (require ground_truth.relevant_ids):
// - recall: Recall@k - fraction of relevant docs retrieved
// - precision: Precision@k - fraction of retrieved docs that are relevant
// - ndcg: Normalized Discounted Cumulative Gain
// - mrr: Mean Reciprocal Rank
// - map: Mean Average Precision
//
// **LLM-as-judge metrics** (require judge config):
// - relevance: Is output relevant to query? (works on retrieval-only too)
// - faithfulness: Is output grounded in context?
// - completeness: Does output fully address query?
// - coherence: Is output well-structured?
// - safety: Is output safe/appropriate?
// - helpfulness: Is output useful?
// - correctness: Is output factually correct? (uses expectations)
// - citation_quality: Are citations accurate?
type EvaluatorName string

// EvaluatorScore Result from a single evaluator
type EvaluatorScore struct {
	// Metadata Additional evaluator-specific data
	Metadata map[string]interface{} `json:"metadata,omitempty,omitzero"`

	// Pass Whether the evaluation passed the threshold
	Pass bool `json:"pass,omitempty,omitzero"`

	// Reason Human-readable explanation of the result
	Reason string `json:"reason,omitempty,omitzero"`

	// Score Numeric score (0-1)
	Score float32 `json:"score,omitempty,omitzero"`
}

// FailedOperation defines model for FailedOperation.
type FailedOperation struct {
	Error     string                   `json:"error,omitempty,omitzero"`
	Id        string                   `json:"id,omitempty,omitzero"`
	Operation FailedOperationOperation `json:"operation,omitempty,omitzero"`
}

// FailedOperationOperation defines model for FailedOperation.Operation.
type FailedOperationOperation string

// FetchConfig Configuration for URL content fetching.
//
// Uses lib/scraping for downloading and processing. Supports:
// - HTTP/HTTPS URLs with security validation
// - HTML pages (extracts readable text via go-readability)
// - PDF files (extracts text)
// - Images (returns as data URIs)
// - Plain text files
// - S3 URLs (requires s3_credentials)
//
// Security features (from lib/scraping.ContentSecurityConfig):
// - Allowed host whitelist
// - Private IP blocking (SSRF prevention)
// - Download size limits
// - Timeout controls
type FetchConfig struct {
	// AllowedHosts Whitelist of allowed hostnames for fetching.
	// If empty, all hosts are allowed (except private IPs).
	// Example: ["docs.example.com", "api.example.com"]
	AllowedHosts []string `json:"allowed_hosts,omitempty,omitzero"`

	// BlockPrivateIps Block requests to private IP ranges (SSRF prevention).
	// Blocked: 127.0.0.0/8, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16
	BlockPrivateIps *bool `json:"block_private_ips,omitempty"`

	// MaxContentLength Maximum content length in characters (truncated if exceeded)
	MaxContentLength int `json:"max_content_length,omitempty,omitzero"`

	// MaxDownloadSizeBytes Maximum download size in bytes (default: 100MB)
	MaxDownloadSizeBytes int         `json:"max_download_size_bytes,omitempty,omitzero"`
	S3Credentials        Credentials `json:"s3_credentials,omitempty,omitzero"`

	// TimeoutSeconds Download timeout in seconds
	TimeoutSeconds int `json:"timeout_seconds,omitempty,omitzero"`
}

// FieldStatistics Statistics about a specific field.
type FieldStatistics struct {
	// AvgSize Average size in bytes for variable-length fields.
	AvgSize int `json:"avg_size,omitempty,omitzero"`

	// Cardinality Approximate number of unique values (via HyperLogLog).
	Cardinality int64 `json:"cardinality,omitempty,omitzero"`

	// MaxValue Maximum value for numeric/date fields.
	MaxValue interface{} `json:"max_value,omitempty,omitzero"`

	// MinValue Minimum value for numeric/date fields.
	MinValue interface{} `json:"min_value,omitempty,omitzero"`

	// NullCount Number of rows with null values for this field.
	NullCount int64 `json:"null_count,omitempty,omitzero"`
}

// FilterSpec A filter specification to apply to search queries
type FilterSpec struct {
	// Field Field name to filter on
	Field string `json:"field"`

	// Operator Filter operator:
	// - eq: Equals
	// - ne: Not equals
	// - gt/gte: Greater than (or equal)
	// - lt/lte: Less than (or equal)
	// - contains: Contains substring
	// - prefix: Starts with
	// - range: Between two values (value should be array [min, max])
	// - in: Value in list (value should be array)
	Operator FilterSpecOperator `json:"operator"`

	// Value Filter value (string, number, boolean, or array for range/in operators)
	Value interface{} `json:"value"`
}

// FilterSpecOperator Filter operator:
// - eq: Equals
// - ne: Not equals
// - gt/gte: Greater than (or equal)
// - lt/lte: Less than (or equal)
// - contains: Contains substring
// - prefix: Starts with
// - range: Between two values (value should be array [min, max])
// - in: Value in list (value should be array)
type FilterSpecOperator string

// FollowupStepConfig Configuration for generating follow-up questions. Uses a separate generator
// call which can use a cheaper/faster model.
type FollowupStepConfig struct {
	// Chain Chain of generators to try in order. Mutually exclusive with 'generator'.
	Chain []ChainLink `json:"chain,omitempty,omitzero"`

	// Context Custom guidance for follow-up question focus and style
	Context string `json:"context,omitempty,omitzero"`

	// Count Number of follow-up questions to generate
	Count int `json:"count,omitempty,omitzero"`

	// Enabled Enable follow-up question generation
	Enabled bool `json:"enabled,omitempty,omitzero"`

	// Generator A unified configuration for a generative AI provider.
	//
	// Generators can be configured with custom prompts using templates. Templates use
	// Handlebars syntax and support various built-in helpers for formatting and data manipulation.
	//
	// **Template System:**
	// - **Syntax**: Handlebars templating (https://handlebarsjs.com/guide/)
	// - **Caching**: Templates are automatically cached with configurable TTL (default: 5 minutes)
	// - **Context**: Templates receive the full context data passed to the generator
	//
	// **Built-in Helpers:**
	//
	// 1. **scrubHtml** - Remove script/style tags and extract clean text from HTML
	//    ```handlebars
	//    {{scrubHtml html_content}}
	//    ```
	//    - Removes `<script>` and `<style>` tags
	//    - Adds newlines after block elements (p, div, h1-h6, li, etc.)
	//    - Returns plain text with preserved readability
	//    - Useful for cleaning web content before summarization
	//
	// 2. **eq** - Equality comparison for conditionals
	//    ```handlebars
	//    {{#if (eq status "active")}}Active{{/if}}
	//    {{#if (eq @key "special")}}Special field{{/if}}
	//    ```
	//    - Use in `{{#if}}` blocks for conditional logic
	//    - Compares any two values for equality
	//
	// 3. **media** - GenKit dotprompt media directive for multimodal content
	//    ```handlebars
	//    {{media url=imageDataURI}}
	//    {{media url=this.image_url}}
	//    {{media url="https://example.com/image.jpg"}}
	//    {{media url="s3://endpoint/bucket/image.png"}}
	//    {{media url="file:///path/to/image.jpg"}}
	//    ```
	//
	//    **Supported URL Schemes:**
	//    - `data:` - Base64 encoded data URIs (e.g., `data:image/jpeg;base64,...`)
	//    - `http://` / `https://` - Web URLs with automatic content type detection
	//    - `file://` - Local filesystem paths
	//    - `s3://` - S3-compatible storage (format: `s3://endpoint/bucket/key`)
	//
	//    **Automatic Content Processing:**
	//    - **Images**: Downloaded, resized (if needed), converted to data URIs
	//    - **PDFs**: Text extracted or first page rendered as image
	//    - **HTML**: Readable text extracted using Mozilla Readability
	//
	//    **Security Controls:**
	//    Downloads are protected by content security settings (see Configuration Reference):
	//    - Allowed host whitelist
	//    - Private IP blocking (prevents SSRF attacks)
	//    - Download size limits (default: 100MB)
	//    - Download timeouts (default: 30s)
	//    - Image dimension limits (default: 2048px, auto-resized)
	//
	//    See: https://antfly.io/docs/configuration#security--cors
	//
	// 4. **encodeToon** - Encode data in TOON format (Token-Oriented Object Notation)
	//    ```handlebars
	//    {{encodeToon this.fields}}
	//    {{encodeToon this.fields lengthMarker=false indent=4}}
	//    {{encodeToon this.fields delimiter="\t"}}
	//    ```
	//
	//    **What is TOON?**
	//    TOON is a compact, human-readable format designed for passing structured data to LLMs.
	//    It provides **30-60% token reduction** compared to JSON while maintaining high LLM
	//    comprehension accuracy.
	//
	//    **Key Features:**
	//    - Compact syntax using `:` for key-value pairs
	//    - Array length markers: `tags[#3]: ai,search,ml`
	//    - Tabular format for uniform data structures
	//    - Optimized for LLM parsing and understanding
	//    - Maintains human readability
	//
	//    **Benefits:**
	//    - **Lower API costs** - Reduced token usage means lower LLM API costs
	//    - **Faster responses** - Less tokens to process
	//    - **More context** - Fit more documents within token limits
	//
	//    **Options:**
	//    - `lengthMarker` (bool): Add # prefix to array counts like `[#3]` (default: true)
	//    - `indent` (int): Indentation spacing for nested objects (default: 2)
	//    - `delimiter` (string): Field separator for tabular arrays (default: none, use `"\t"` for tabs)
	//
	//    **Example output:**
	//    ```
	//    title: Introduction to Vector Search
	//    author: Jane Doe
	//    tags[#3]: ai,search,ml
	//    metadata:
	//      edition: 2
	//      pages: 450
	//    ```
	//
	//    **Default in RAG:** TOON is the default format for document rendering in RAG queries.
	//
	//    **References:**
	//    - TOON Specification: https://github.com/toon-format/toon
	//    - Go Implementation: https://github.com/alpkeskin/gotoon
	//
	// **Template Examples:**
	//
	// RAG summarization with document references:
	// ```handlebars
	// Based on these documents, provide a comprehensive summary:
	//
	// {{#each documents}}
	// Document {{this.id}}:
	// {{scrubHtml this.content}}
	//
	// {{/each}}
	//
	// Valid document IDs: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
	// ```
	//
	// Conditional formatting:
	// ```handlebars
	// {{#if system_prompt}}System: {{system_prompt}}{{/if}}
	//
	// User Query: {{query}}
	//
	// {{#if context}}
	// Context:
	// {{#each context}}
	// - {{this}}
	// {{/each}}
	// {{/if}}
	// ```
	//
	// Multimodal prompt with images:
	// ```handlebars
	// Analyze this image:
	// {{media url=image_url}}
	//
	// Focus on: {{focus_area}}
	// ```
	//
	// Structured data encoding:
	// ```handlebars
	// User Profile:
	// {{encodeToon user_data indent=2 lengthMarker=true}}
	//
	// Please analyze this profile.
	// ```
	//
	// **Common Use Cases:**
	// - **RAG (Retrieval-Augmented Generation)**: Format retrieved documents with citations
	// - **Summarization**: Clean HTML content and structure summaries
	// - **Query Classification**: Format queries with metadata for better classification
	// - **Multimodal**: Include images/audio/video in prompts
	// - **Data Formatting**: Convert structured data to readable text
	//
	// **Best Practices:**
	// - Keep templates simple - complex logic belongs in application code
	// - Use clear, descriptive field names in context
	// - Handle missing fields gracefully (templates use "missingkey=zero" by default)
	// - Test templates with representative data before production use
	Generator GeneratorConfig `json:"generator,omitempty,omitzero"`
}

// ForeignColumn defines model for ForeignColumn.
type ForeignColumn struct {
	// Name Column name in the foreign table.
	Name string `json:"name"`

	// Nullable Whether the column allows NULL values.
	Nullable bool `json:"nullable,omitempty,omitzero"`

	// Type Column data type. Used for filter validation and type coercion.
	// Common types: text, integer, bigint, float, boolean, timestamp, uuid, jsonb.
	Type string `json:"type"`
}

// ForeignSource defines model for ForeignSource.
type ForeignSource struct {
	// Columns Optional column definitions for the foreign table. If omitted, columns are
	// auto-discovered from `information_schema.columns` on first query.
	Columns []ForeignColumn `json:"columns,omitempty,omitzero"`

	// Dsn Data source name (connection string) for the foreign database.
	// Supports `${secret:key_name}` references that resolve from the Antfly keystore
	// or environment variables.
	Dsn string `json:"dsn"`

	// PostgresTable Name of the table or view in the foreign PostgreSQL database to query.
	PostgresTable string `json:"postgres_table"`

	// Type Type of the foreign data source. Currently only "postgres" is supported.
	Type ForeignSourceType `json:"type"`
}

// ForeignSourceType Type of the foreign data source. Currently only "postgres" is supported.
type ForeignSourceType string

// Fuzziness The fuzziness of the query. Can be an integer or "auto".
type Fuzziness struct {
	union json.RawMessage
}

// Fuzziness0 defines model for .
type Fuzziness0 = int32

// Fuzziness1 defines model for Fuzziness.1.
type Fuzziness1 string

// FuzzyQuery defines model for FuzzyQuery.
type FuzzyQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost Boost  `json:"boost,omitzero"`
	Field string `json:"field,omitempty,omitzero"`

	// Fuzziness The fuzziness of the query. Can be an integer or "auto".
	Fuzziness    Fuzziness `json:"fuzziness,omitempty,omitzero"`
	PrefixLength int32     `json:"prefix_length,omitempty,omitzero"`
	Term         string    `json:"term"`
}

// GenerationStepConfig Configuration for the generation step. This step generates the final
// response from retrieved documents using the reasoning as context.
type GenerationStepConfig struct {
	// Chain Chain of generators to try in order. Mutually exclusive with 'generator'.
	Chain []ChainLink `json:"chain,omitempty,omitzero"`

	// Enabled Enable generation from retrieved documents
	Enabled bool `json:"enabled,omitempty,omitzero"`

	// GenerationContext Custom guidance for generation tone, detail level, and style
	GenerationContext string `json:"generation_context,omitempty,omitzero"`

	// Generator A unified configuration for a generative AI provider.
	//
	// Generators can be configured with custom prompts using templates. Templates use
	// Handlebars syntax and support various built-in helpers for formatting and data manipulation.
	//
	// **Template System:**
	// - **Syntax**: Handlebars templating (https://handlebarsjs.com/guide/)
	// - **Caching**: Templates are automatically cached with configurable TTL (default: 5 minutes)
	// - **Context**: Templates receive the full context data passed to the generator
	//
	// **Built-in Helpers:**
	//
	// 1. **scrubHtml** - Remove script/style tags and extract clean text from HTML
	//    ```handlebars
	//    {{scrubHtml html_content}}
	//    ```
	//    - Removes `<script>` and `<style>` tags
	//    - Adds newlines after block elements (p, div, h1-h6, li, etc.)
	//    - Returns plain text with preserved readability
	//    - Useful for cleaning web content before summarization
	//
	// 2. **eq** - Equality comparison for conditionals
	//    ```handlebars
	//    {{#if (eq status "active")}}Active{{/if}}
	//    {{#if (eq @key "special")}}Special field{{/if}}
	//    ```
	//    - Use in `{{#if}}` blocks for conditional logic
	//    - Compares any two values for equality
	//
	// 3. **media** - GenKit dotprompt media directive for multimodal content
	//    ```handlebars
	//    {{media url=imageDataURI}}
	//    {{media url=this.image_url}}
	//    {{media url="https://example.com/image.jpg"}}
	//    {{media url="s3://endpoint/bucket/image.png"}}
	//    {{media url="file:///path/to/image.jpg"}}
	//    ```
	//
	//    **Supported URL Schemes:**
	//    - `data:` - Base64 encoded data URIs (e.g., `data:image/jpeg;base64,...`)
	//    - `http://` / `https://` - Web URLs with automatic content type detection
	//    - `file://` - Local filesystem paths
	//    - `s3://` - S3-compatible storage (format: `s3://endpoint/bucket/key`)
	//
	//    **Automatic Content Processing:**
	//    - **Images**: Downloaded, resized (if needed), converted to data URIs
	//    - **PDFs**: Text extracted or first page rendered as image
	//    - **HTML**: Readable text extracted using Mozilla Readability
	//
	//    **Security Controls:**
	//    Downloads are protected by content security settings (see Configuration Reference):
	//    - Allowed host whitelist
	//    - Private IP blocking (prevents SSRF attacks)
	//    - Download size limits (default: 100MB)
	//    - Download timeouts (default: 30s)
	//    - Image dimension limits (default: 2048px, auto-resized)
	//
	//    See: https://antfly.io/docs/configuration#security--cors
	//
	// 4. **encodeToon** - Encode data in TOON format (Token-Oriented Object Notation)
	//    ```handlebars
	//    {{encodeToon this.fields}}
	//    {{encodeToon this.fields lengthMarker=false indent=4}}
	//    {{encodeToon this.fields delimiter="\t"}}
	//    ```
	//
	//    **What is TOON?**
	//    TOON is a compact, human-readable format designed for passing structured data to LLMs.
	//    It provides **30-60% token reduction** compared to JSON while maintaining high LLM
	//    comprehension accuracy.
	//
	//    **Key Features:**
	//    - Compact syntax using `:` for key-value pairs
	//    - Array length markers: `tags[#3]: ai,search,ml`
	//    - Tabular format for uniform data structures
	//    - Optimized for LLM parsing and understanding
	//    - Maintains human readability
	//
	//    **Benefits:**
	//    - **Lower API costs** - Reduced token usage means lower LLM API costs
	//    - **Faster responses** - Less tokens to process
	//    - **More context** - Fit more documents within token limits
	//
	//    **Options:**
	//    - `lengthMarker` (bool): Add # prefix to array counts like `[#3]` (default: true)
	//    - `indent` (int): Indentation spacing for nested objects (default: 2)
	//    - `delimiter` (string): Field separator for tabular arrays (default: none, use `"\t"` for tabs)
	//
	//    **Example output:**
	//    ```
	//    title: Introduction to Vector Search
	//    author: Jane Doe
	//    tags[#3]: ai,search,ml
	//    metadata:
	//      edition: 2
	//      pages: 450
	//    ```
	//
	//    **Default in RAG:** TOON is the default format for document rendering in RAG queries.
	//
	//    **References:**
	//    - TOON Specification: https://github.com/toon-format/toon
	//    - Go Implementation: https://github.com/alpkeskin/gotoon
	//
	// **Template Examples:**
	//
	// RAG summarization with document references:
	// ```handlebars
	// Based on these documents, provide a comprehensive summary:
	//
	// {{#each documents}}
	// Document {{this.id}}:
	// {{scrubHtml this.content}}
	//
	// {{/each}}
	//
	// Valid document IDs: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
	// ```
	//
	// Conditional formatting:
	// ```handlebars
	// {{#if system_prompt}}System: {{system_prompt}}{{/if}}
	//
	// User Query: {{query}}
	//
	// {{#if context}}
	// Context:
	// {{#each context}}
	// - {{this}}
	// {{/each}}
	// {{/if}}
	// ```
	//
	// Multimodal prompt with images:
	// ```handlebars
	// Analyze this image:
	// {{media url=image_url}}
	//
	// Focus on: {{focus_area}}
	// ```
	//
	// Structured data encoding:
	// ```handlebars
	// User Profile:
	// {{encodeToon user_data indent=2 lengthMarker=true}}
	//
	// Please analyze this profile.
	// ```
	//
	// **Common Use Cases:**
	// - **RAG (Retrieval-Augmented Generation)**: Format retrieved documents with citations
	// - **Summarization**: Clean HTML content and structure summaries
	// - **Query Classification**: Format queries with metadata for better classification
	// - **Multimodal**: Include images/audio/video in prompts
	// - **Data Formatting**: Convert structured data to readable text
	//
	// **Best Practices:**
	// - Keep templates simple - complex logic belongs in application code
	// - Use clear, descriptive field names in context
	// - Handle missing fields gracefully (templates use "missingkey=zero" by default)
	// - Test templates with representative data before production use
	Generator GeneratorConfig `json:"generator,omitempty,omitzero"`

	// SystemPrompt Custom system prompt for answer generation
	SystemPrompt string `json:"system_prompt,omitempty,omitzero"`
}

// GeneratorConfig defines model for GeneratorConfig.
type GeneratorConfig struct {
	// Provider The generative AI provider to use.
	Provider GeneratorProvider `json:"provider"`
	union    json.RawMessage
}

// GeneratorProvider The generative AI provider to use.
type GeneratorProvider string

// GeoBoundingBoxQuery defines model for GeoBoundingBoxQuery.
type GeoBoundingBoxQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost Boost `json:"boost,omitzero"`

	// BottomRight [lon, lat]
	BottomRight []float64 `json:"bottom_right"`
	Field       string    `json:"field,omitempty,omitzero"`

	// TopLeft [lon, lat]
	TopLeft []float64 `json:"top_left"`
}

// GeoBoundingPolygonQuery defines model for GeoBoundingPolygonQuery.
type GeoBoundingPolygonQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost         Boost      `json:"boost,omitzero"`
	Field         string     `json:"field,omitempty,omitzero"`
	PolygonPoints []GeoPoint `json:"polygon_points"`
}

// GeoDistanceQuery defines model for GeoDistanceQuery.
type GeoDistanceQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost    Boost  `json:"boost,omitzero"`
	Distance string `json:"distance"`
	Field    string `json:"field,omitempty,omitzero"`

	// Location [lon, lat]
	Location []float64 `json:"location"`
}

// GeoPoint defines model for GeoPoint.
type GeoPoint struct {
	Lat float64 `json:"lat,omitempty,omitzero"`
	Lon float64 `json:"lon,omitempty,omitzero"`
}

// GeoShape A GeoJSON shape object. This is a simplified representation.
type GeoShape struct {
	Coordinates []interface{} `json:"coordinates"`
	Type        string        `json:"type"`
}

// GeoShapeGeometry defines model for GeoShapeGeometry.
type GeoShapeGeometry struct {
	Relation GeoShapeGeometryRelation `json:"relation"`

	// Shape A GeoJSON shape object. This is a simplified representation.
	Shape GeoShape `json:"shape"`
}

// GeoShapeGeometryRelation defines model for GeoShapeGeometry.Relation.
type GeoShapeGeometryRelation string

// GeoShapeQuery defines model for GeoShapeQuery.
type GeoShapeQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost    Boost            `json:"boost,omitzero"`
	Field    string           `json:"field,omitempty,omitzero"`
	Geometry GeoShapeGeometry `json:"geometry"`
}

// GoogleEmbedderConfig Configuration for the Google AI (Gemini) embedding provider.
//
// API key via `api_key` field or `GEMINI_API_KEY` environment variable.
//
// **Example Models:** gemini-embedding-001 (default, 3072 dims)
//
// **Docs:** https://ai.google.dev/gemini-api/docs/embeddings
type GoogleEmbedderConfig struct {
	// ApiKey The Google API key. Can also be set via GEMINI_API_KEY environment variable.
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// Dimension The dimension of the embedding vector (768, 1536, or 3072 recommended).
	Dimension int `json:"dimension,omitempty,omitzero"`

	// Location The Google Cloud location (e.g., 'us-central1'). Required for Vertex AI, optional for Gemini API.
	Location string `json:"location,omitempty,omitzero"`

	// Model The name of the embedding model to use.
	Model string `json:"model"`

	// ProjectId The Google Cloud project ID (optional for Gemini API, required for Vertex AI).
	ProjectId string `json:"project_id,omitempty,omitzero"`

	// Url The URL of the Google API endpoint (optional, uses default if not specified).
	Url string `json:"url,omitempty,omitzero"`
}

// GoogleGeneratorConfig Configuration for the Google generative AI provider (Gemini).
//
// **Example Models:** gemini-2.5-flash (default), gemini-2.5-pro, gemini-3.0-pro
//
// **Docs:** https://ai.google.dev/gemini-api/docs/models
type GoogleGeneratorConfig struct {
	// ApiKey The Google API key.
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// Location The Google Cloud location (e.g., 'us-central1').
	Location string `json:"location,omitempty,omitzero"`

	// MaxTokens Maximum number of tokens to generate.
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Model The name of the generative model to use (e.g., 'gemini-2.5-flash', 'gemini-2.5-pro', 'gemini-3.0-pro').
	Model string `json:"model"`

	// ProjectId The Google Cloud project ID.
	ProjectId string `json:"project_id,omitempty,omitzero"`

	// Temperature Controls randomness in generation (0.0-2.0).
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// TopK Top-k sampling parameter.
	TopK int `json:"top_k,omitempty,omitzero"`

	// TopP Nucleus sampling parameter.
	TopP float32 `json:"top_p,omitempty,omitzero"`

	// Url The URL of the Google API endpoint.
	Url string `json:"url,omitempty,omitzero"`
}

// GoogleSearchConfig defines model for GoogleSearchConfig.
type GoogleSearchConfig struct {
	// ApiKey Google API key (or set GOOGLE_CSE_API_KEY env var)
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// CseId Custom Search Engine ID (or set GOOGLE_CSE_ID env var)
	CseId string `json:"cse_id,omitempty,omitzero"`

	// DateRestrict Restrict results by date (e.g., 'd7' for last 7 days, 'm1' for last month)
	DateRestrict string `json:"date_restrict,omitempty,omitzero"`

	// Language Preferred language for results (e.g., 'en', 'es', 'fr')
	Language string `json:"language,omitempty,omitzero"`

	// MaxResults Maximum number of search results to return
	MaxResults int `json:"max_results,omitempty,omitzero"`

	// Provider The web search provider to use.
	//
	// - **google**: Google Custom Search API (requires CSE setup)
	// - **bing**: Microsoft Bing Web Search API
	// - **serper**: Serper.dev Google Search API (simpler setup)
	// - **tavily**: Tavily AI Search API (optimized for RAG)
	// - **brave**: Brave Search API
	// - **duckduckgo**: DuckDuckGo Instant Answer API (limited, no API key)
	Provider WebSearchProvider `json:"provider"`

	// Region Preferred region for results (e.g., 'us', 'uk', 'de')
	Region string `json:"region,omitempty,omitzero"`

	// SafeSearch Enable safe search filtering
	SafeSearch *bool `json:"safe_search,omitempty"`

	// SearchType Type of search to perform
	SearchType GoogleSearchConfigSearchType `json:"search_type,omitempty,omitzero"`

	// TimeoutMs Request timeout in milliseconds
	TimeoutMs int `json:"timeout_ms,omitempty,omitzero"`
}

// GoogleSearchConfigSearchType Type of search to perform
type GoogleSearchConfigSearchType string

// GraphIndexV0Config Configuration for graph_v0 index type
type GraphIndexV0Config struct {
	// EdgeTypes List of edge types with their configurations
	EdgeTypes []EdgeTypeConfig `json:"edge_types,omitempty,omitzero"`

	// MaxEdgesPerDocument Maximum number of edges per document (0 = unlimited)
	MaxEdgesPerDocument int `json:"max_edges_per_document,omitempty,omitzero"`

	// Summarizer A unified configuration for a generative AI provider.
	//
	// Generators can be configured with custom prompts using templates. Templates use
	// Handlebars syntax and support various built-in helpers for formatting and data manipulation.
	//
	// **Template System:**
	// - **Syntax**: Handlebars templating (https://handlebarsjs.com/guide/)
	// - **Caching**: Templates are automatically cached with configurable TTL (default: 5 minutes)
	// - **Context**: Templates receive the full context data passed to the generator
	//
	// **Built-in Helpers:**
	//
	// 1. **scrubHtml** - Remove script/style tags and extract clean text from HTML
	//    ```handlebars
	//    {{scrubHtml html_content}}
	//    ```
	//    - Removes `<script>` and `<style>` tags
	//    - Adds newlines after block elements (p, div, h1-h6, li, etc.)
	//    - Returns plain text with preserved readability
	//    - Useful for cleaning web content before summarization
	//
	// 2. **eq** - Equality comparison for conditionals
	//    ```handlebars
	//    {{#if (eq status "active")}}Active{{/if}}
	//    {{#if (eq @key "special")}}Special field{{/if}}
	//    ```
	//    - Use in `{{#if}}` blocks for conditional logic
	//    - Compares any two values for equality
	//
	// 3. **media** - GenKit dotprompt media directive for multimodal content
	//    ```handlebars
	//    {{media url=imageDataURI}}
	//    {{media url=this.image_url}}
	//    {{media url="https://example.com/image.jpg"}}
	//    {{media url="s3://endpoint/bucket/image.png"}}
	//    {{media url="file:///path/to/image.jpg"}}
	//    ```
	//
	//    **Supported URL Schemes:**
	//    - `data:` - Base64 encoded data URIs (e.g., `data:image/jpeg;base64,...`)
	//    - `http://` / `https://` - Web URLs with automatic content type detection
	//    - `file://` - Local filesystem paths
	//    - `s3://` - S3-compatible storage (format: `s3://endpoint/bucket/key`)
	//
	//    **Automatic Content Processing:**
	//    - **Images**: Downloaded, resized (if needed), converted to data URIs
	//    - **PDFs**: Text extracted or first page rendered as image
	//    - **HTML**: Readable text extracted using Mozilla Readability
	//
	//    **Security Controls:**
	//    Downloads are protected by content security settings (see Configuration Reference):
	//    - Allowed host whitelist
	//    - Private IP blocking (prevents SSRF attacks)
	//    - Download size limits (default: 100MB)
	//    - Download timeouts (default: 30s)
	//    - Image dimension limits (default: 2048px, auto-resized)
	//
	//    See: https://antfly.io/docs/configuration#security--cors
	//
	// 4. **encodeToon** - Encode data in TOON format (Token-Oriented Object Notation)
	//    ```handlebars
	//    {{encodeToon this.fields}}
	//    {{encodeToon this.fields lengthMarker=false indent=4}}
	//    {{encodeToon this.fields delimiter="\t"}}
	//    ```
	//
	//    **What is TOON?**
	//    TOON is a compact, human-readable format designed for passing structured data to LLMs.
	//    It provides **30-60% token reduction** compared to JSON while maintaining high LLM
	//    comprehension accuracy.
	//
	//    **Key Features:**
	//    - Compact syntax using `:` for key-value pairs
	//    - Array length markers: `tags[#3]: ai,search,ml`
	//    - Tabular format for uniform data structures
	//    - Optimized for LLM parsing and understanding
	//    - Maintains human readability
	//
	//    **Benefits:**
	//    - **Lower API costs** - Reduced token usage means lower LLM API costs
	//    - **Faster responses** - Less tokens to process
	//    - **More context** - Fit more documents within token limits
	//
	//    **Options:**
	//    - `lengthMarker` (bool): Add # prefix to array counts like `[#3]` (default: true)
	//    - `indent` (int): Indentation spacing for nested objects (default: 2)
	//    - `delimiter` (string): Field separator for tabular arrays (default: none, use `"\t"` for tabs)
	//
	//    **Example output:**
	//    ```
	//    title: Introduction to Vector Search
	//    author: Jane Doe
	//    tags[#3]: ai,search,ml
	//    metadata:
	//      edition: 2
	//      pages: 450
	//    ```
	//
	//    **Default in RAG:** TOON is the default format for document rendering in RAG queries.
	//
	//    **References:**
	//    - TOON Specification: https://github.com/toon-format/toon
	//    - Go Implementation: https://github.com/alpkeskin/gotoon
	//
	// **Template Examples:**
	//
	// RAG summarization with document references:
	// ```handlebars
	// Based on these documents, provide a comprehensive summary:
	//
	// {{#each documents}}
	// Document {{this.id}}:
	// {{scrubHtml this.content}}
	//
	// {{/each}}
	//
	// Valid document IDs: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
	// ```
	//
	// Conditional formatting:
	// ```handlebars
	// {{#if system_prompt}}System: {{system_prompt}}{{/if}}
	//
	// User Query: {{query}}
	//
	// {{#if context}}
	// Context:
	// {{#each context}}
	// - {{this}}
	// {{/each}}
	// {{/if}}
	// ```
	//
	// Multimodal prompt with images:
	// ```handlebars
	// Analyze this image:
	// {{media url=image_url}}
	//
	// Focus on: {{focus_area}}
	// ```
	//
	// Structured data encoding:
	// ```handlebars
	// User Profile:
	// {{encodeToon user_data indent=2 lengthMarker=true}}
	//
	// Please analyze this profile.
	// ```
	//
	// **Common Use Cases:**
	// - **RAG (Retrieval-Augmented Generation)**: Format retrieved documents with citations
	// - **Summarization**: Clean HTML content and structure summaries
	// - **Query Classification**: Format queries with metadata for better classification
	// - **Multimodal**: Include images/audio/video in prompts
	// - **Data Formatting**: Convert structured data to readable text
	//
	// **Best Practices:**
	// - Keep templates simple - complex logic belongs in application code
	// - Use clear, descriptive field names in context
	// - Handle missing fields gracefully (templates use "missingkey=zero" by default)
	// - Test templates with representative data before production use
	Summarizer GeneratorConfig `json:"summarizer,omitempty,omitzero"`

	// Template Handlebars template for generating summarizer input text.
	// Uses document fields as template variables.
	// Same pattern as EmbeddingIndexConfig.template.
	Template string `json:"template,omitempty,omitzero"`
}

// GraphIndexV0Stats Statistics for graph_v0 index
type GraphIndexV0Stats struct {
	// EdgeTypes Count of edges per edge type
	EdgeTypes map[string]uint64 `json:"edge_types,omitempty,omitzero"`

	// Error Error message if stats could not be retrieved
	Error string `json:"error,omitempty,omitzero"`

	// TotalEdges Total number of edges in the graph
	TotalEdges uint64 `json:"total_edges,omitempty,omitzero"`
}

// GraphNodeSelector Defines how to select start/target nodes for graph queries
type GraphNodeSelector struct {
	// Keys Explicit list of node keys
	Keys []string `json:"keys,omitempty,omitzero"`

	// Limit Maximum number of nodes to select from the referenced results
	Limit int `json:"limit,omitempty,omitzero"`

	// NodeFilter Filter nodes during graph traversal using existing query primitives
	NodeFilter NodeFilter `json:"node_filter,omitempty,omitzero"`

	// ResultRef Reference to search results to use as nodes:
	// - "$full_text_results" - use full-text search results
	// - "$aknn_results.index_name" - use vector search results from specific index
	ResultRef string `json:"result_ref,omitempty,omitzero"`
}

// GraphQuery Declarative graph query to execute after full-text/vector searches
type GraphQuery struct {
	// Fields Which fields to return from documents
	Fields []string `json:"fields,omitempty,omitzero"`

	// IncludeDocuments Fetch full documents for graph results
	IncludeDocuments bool `json:"include_documents,omitempty,omitzero"`

	// IncludeEdges Include edge details for each node
	IncludeEdges bool `json:"include_edges,omitempty,omitzero"`

	// IndexName Graph index name (must be graph_v0 type)
	IndexName string `json:"index_name"`

	// Params Parameters for graph traversal and pathfinding
	Params GraphQueryParams `json:"params,omitempty,omitzero"`

	// Pattern Pattern steps for pattern query type
	Pattern []PatternStep `json:"pattern,omitempty,omitzero"`

	// ReturnAliases Which aliases to return from pattern query (empty = all)
	ReturnAliases []string `json:"return_aliases,omitempty,omitzero"`

	// StartNodes Defines how to select start/target nodes for graph queries
	StartNodes GraphNodeSelector `json:"start_nodes,omitempty,omitzero"`

	// TargetNodes Defines how to select start/target nodes for graph queries
	TargetNodes GraphNodeSelector `json:"target_nodes,omitempty,omitzero"`

	// Type Type of graph query to execute
	Type GraphQueryType `json:"type"`
}

// GraphQueryParams Parameters for graph traversal and pathfinding
type GraphQueryParams struct {
	// Algorithm Graph algorithm to run (e.g., 'pagerank', 'betweenness')
	Algorithm string `json:"algorithm,omitempty,omitzero"`

	// AlgorithmParams Parameters for the graph algorithm
	AlgorithmParams map[string]interface{} `json:"algorithm_params,omitempty,omitzero"`

	// DeduplicateNodes Remove duplicate nodes (traversal)
	DeduplicateNodes bool `json:"deduplicate_nodes,omitempty,omitzero"`

	// Direction Direction of edges to query:
	// - out: Outgoing edges from the node
	// - in: Incoming edges to the node
	// - both: Both outgoing and incoming edges
	Direction EdgeDirection `json:"direction,omitempty,omitzero"`

	// EdgeTypes Filter by edge types
	EdgeTypes []string `json:"edge_types,omitempty,omitzero"`

	// IncludePaths Include path information (traversal)
	IncludePaths bool `json:"include_paths,omitempty,omitzero"`

	// K Number of paths to find (k-shortest-paths)
	K int `json:"k,omitempty,omitzero"`

	// MaxDepth Maximum traversal depth
	MaxDepth int `json:"max_depth,omitempty,omitzero"`

	// MaxResults Maximum number of results (traversal)
	MaxResults int `json:"max_results,omitempty,omitzero"`

	// MaxWeight Maximum edge weight
	MaxWeight float64 `json:"max_weight,omitempty,omitzero"`

	// MinWeight Minimum edge weight
	MinWeight float64 `json:"min_weight,omitempty,omitzero"`

	// NodeFilter Filter nodes during graph traversal using existing query primitives
	NodeFilter NodeFilter `json:"node_filter,omitempty,omitzero"`

	// WeightMode Path weighting algorithm for pathfinding:
	// - min_hops: Minimize number of edges
	// - min_weight: Minimize sum of edge weights
	// - max_weight: Maximize product of edge weights
	WeightMode PathWeightMode `json:"weight_mode,omitempty,omitzero"`
}

// GraphQueryResult Results of a graph query
type GraphQueryResult struct {
	// Matches Pattern matches (for pattern queries)
	Matches []PatternMatch `json:"matches,omitempty,omitzero"`

	// Nodes Result nodes
	Nodes []GraphResultNode `json:"nodes,omitempty,omitzero"`

	// Paths Result paths (for pathfinding queries)
	Paths []Path `json:"paths,omitempty,omitzero"`

	// Took Query execution time
	Took time.Duration `json:"took,omitempty,omitzero"`

	// Total Total number of results
	Total int `json:"total"`

	// Type Type of graph query to execute
	Type GraphQueryType `json:"type"`
}

// GraphQueryType Type of graph query to execute
type GraphQueryType string

// GraphResultNode A node in graph query results
type GraphResultNode struct {
	// Depth Distance from start node
	Depth int `json:"depth,omitempty,omitzero"`

	// Distance Weighted distance
	Distance float64 `json:"distance,omitempty,omitzero"`

	// Document Full document (if include_documents=true)
	Document map[string]interface{} `json:"document,omitempty,omitzero"`

	// Edges Connected edges (when include_edges=true)
	Edges []Edge `json:"edges,omitempty,omitzero"`

	// Key Document key
	Key string `json:"key"`

	// Path Keys in path from start to this node
	Path []string `json:"path,omitempty,omitzero"`

	// PathEdges Edges in path from start to this node
	PathEdges []PathEdge `json:"path_edges,omitempty,omitzero"`
}

// GroundTruth Ground truth data for evaluation
type GroundTruth struct {
	// Expectations Context for evaluators about what to expect in the response.
	// Provides guidance for LLM judges (e.g., "Should mention pricing tiers").
	Expectations string `json:"expectations,omitempty,omitzero"`

	// RelevantIds Document IDs known to be relevant (for retrieval metrics)
	RelevantIds []string `json:"relevant_ids,omitempty,omitzero"`
}

// IPRangeQuery defines model for IPRangeQuery.
type IPRangeQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost Boost  `json:"boost,omitzero"`
	Cidr  string `json:"cidr"`
	Field string `json:"field,omitempty,omitzero"`
}

// IndexConfig Configuration for an index
type IndexConfig struct {
	// Description Optional description of the index and its purpose
	Description string `json:"description,omitempty,omitzero"`

	// Enrichments List of enrichment names to apply to documents before indexing. Enrichments must be defined at the table level.
	Enrichments []string `json:"enrichments,omitempty,omitzero"`

	// Name Name of the index
	Name string `json:"name"`

	// Type The type of the index.
	Type  IndexType `json:"type"`
	union json.RawMessage
}

// IndexStats Statistics for an index
type IndexStats struct {
	union json.RawMessage
}

// IndexStatus defines model for IndexStatus.
type IndexStatus struct {
	// Config Configuration for an index
	Config      IndexConfig           `json:"config"`
	ShardStatus map[string]IndexStats `json:"shard_status"`

	// Status Statistics for an index
	Status IndexStats `json:"status"`
}

// IndexType The type of the index.
type IndexType string

// JoinClause Configuration for joining data from another table.
// Supports inner, left, and right joins with automatic strategy selection.
type JoinClause struct {
	// JoinType Type of join to perform:
	// - `inner`: Only return rows with matches in both tables
	// - `left`: Return all rows from left table, NULL for non-matching right rows
	// - `right`: Return all rows from right table, NULL for non-matching left rows
	JoinType JoinType `json:"join_type,omitempty,omitzero"`

	// NestedJoin Optional nested join for multi-way joins.
	// The nested join operates on the result of the current join.
	NestedJoin *JoinClause `json:"nested_join"`

	// On Condition for matching rows between tables.
	On JoinCondition `json:"on"`

	// RightFields Fields to include from the right table in the result.
	// If not specified, all fields from the right table are included.
	// Fields are prefixed with the right table name in the result.
	RightFields []string `json:"right_fields,omitempty,omitzero"`

	// RightFilters Filters to apply to a table before joining.
	RightFilters JoinFilters `json:"right_filters,omitempty,omitzero"`

	// RightTable Name of the table to join with.
	RightTable string `json:"right_table"`

	// StrategyHint Strategy for executing the join:
	// - `broadcast`: Broadcast small table to all shards of large table.
	//   Best for dimension tables < 10MB. O(small_table) memory per shard.
	// - `index_lookup`: Use batch key lookups via indexes.
	//   Best for selective joins with indexed join keys. Low memory overhead.
	// - `shuffle`: Hash-partition both tables by join key.
	//   Best for large-large table joins. Requires data movement.
	StrategyHint JoinStrategy `json:"strategy_hint,omitempty,omitzero"`
}

// JoinCondition Condition for matching rows between tables.
type JoinCondition struct {
	// LeftField Field from the left (primary) table to match on.
	LeftField string `json:"left_field"`

	// Operator Comparison operator for join condition:
	// - `eq`: Equal (default)
	// - `neq`: Not equal
	// - `lt`: Less than
	// - `lte`: Less than or equal
	// - `gt`: Greater than
	// - `gte`: Greater than or equal
	Operator JoinOperator `json:"operator,omitempty,omitzero"`

	// RightField Field from the right (joined) table to match on.
	RightField string `json:"right_field"`
}

// JoinFilters Filters to apply to a table before joining.
type JoinFilters struct {
	// FilterPrefix Key prefix filter for the table.
	FilterPrefix []byte `json:"filter_prefix,omitempty,omitzero"`

	// FilterQuery Bleve query to filter rows before joining.
	FilterQuery json.RawMessage `json:"filter_query,omitempty,omitzero"`

	// Limit Maximum number of rows to include from this table.
	Limit int `json:"limit,omitempty,omitzero"`
}

// JoinOperator Comparison operator for join condition:
// - `eq`: Equal (default)
// - `neq`: Not equal
// - `lt`: Less than
// - `lte`: Less than or equal
// - `gt`: Greater than
// - `gte`: Greater than or equal
type JoinOperator string

// JoinResult Statistics and metadata about join execution.
type JoinResult struct {
	// JoinTimeMs Time spent executing the join in milliseconds.
	JoinTimeMs int64 `json:"join_time_ms,omitempty,omitzero"`

	// LeftRowsScanned Number of rows scanned from the left table.
	LeftRowsScanned int64 `json:"left_rows_scanned,omitempty,omitzero"`

	// RightRowsScanned Number of rows scanned from the right table.
	RightRowsScanned int64 `json:"right_rows_scanned,omitempty,omitzero"`

	// RowsMatched Number of rows that matched the join condition.
	RowsMatched int64 `json:"rows_matched,omitempty,omitzero"`

	// RowsUnmatchedLeft Number of left rows without a match (for left/full joins).
	RowsUnmatchedLeft int64 `json:"rows_unmatched_left,omitempty,omitzero"`

	// RowsUnmatchedRight Number of right rows without a match (for right/full joins).
	RowsUnmatchedRight int64 `json:"rows_unmatched_right,omitempty,omitzero"`

	// StrategyUsed Strategy for executing the join:
	// - `broadcast`: Broadcast small table to all shards of large table.
	//   Best for dimension tables < 10MB. O(small_table) memory per shard.
	// - `index_lookup`: Use batch key lookups via indexes.
	//   Best for selective joins with indexed join keys. Low memory overhead.
	// - `shuffle`: Hash-partition both tables by join key.
	//   Best for large-large table joins. Requires data movement.
	StrategyUsed JoinStrategy `json:"strategy_used,omitempty,omitzero"`
}

// JoinStrategy Strategy for executing the join:
//   - `broadcast`: Broadcast small table to all shards of large table.
//     Best for dimension tables < 10MB. O(small_table) memory per shard.
//   - `index_lookup`: Use batch key lookups via indexes.
//     Best for selective joins with indexed join keys. Low memory overhead.
//   - `shuffle`: Hash-partition both tables by join key.
//     Best for large-large table joins. Requires data movement.
type JoinStrategy string

// JoinType Type of join to perform:
// - `inner`: Only return rows with matches in both tables
// - `left`: Return all rows from left table, NULL for non-matching right rows
// - `right`: Return all rows from right table, NULL for non-matching left rows
type JoinType string

// KeyRange Key range processed in this request
type KeyRange struct {
	From string `json:"from,omitempty,omitzero"`
	To   string `json:"to,omitempty,omitzero"`
}

// LinearMergePageStatus Status of a linear merge page operation:
// - "success": All records in batch processed successfully
// - "partial": Processing stopped at shard boundary, client should retry with next_cursor
// - "error": Fatal error occurred, no records processed successfully
type LinearMergePageStatus string

// LinearMergeRequest Linear merge operation for syncing sorted records from external sources.
// Use this to keep Antfly in sync with an external database or data source.
//
// **How it works:**
// 1. Send sorted records from your external source
// 2. Server upserts records that exist in your batch
// 3. Server deletes Antfly records in the key range that are absent from your batch
// 4. If stopped at shard boundary, use next_cursor for next request
//
// **WARNING:** Not safe for concurrent operations with overlapping key ranges.
type LinearMergeRequest struct {
	// DryRun If true, returns what would be deleted without making changes.
	//
	// Use cases:
	// - Validate sync behavior before committing
	// - Check which records will be removed
	// - Test key range boundaries
	//
	// Response includes deleted_ids array when dry_run=true.
	DryRun bool `json:"dry_run,omitempty,omitzero"`

	// LastMergedId ID of last record from previous merge request.
	// - First request: Use empty string ""
	// - Subsequent requests: Use next_cursor from previous response
	// - Defines lower bound of key range to process
	//
	// This enables pagination for large datasets.
	LastMergedId string `json:"last_merged_id,omitempty,omitzero"`

	// Records Map of resource ID to resource object: {"resource_id_1": {...}, "resource_id_2": {...}}
	//
	// Requirements:
	// - Keys must be sorted lexicographically by your client
	// - Server will process keys in sorted order
	// - Use consistent key naming (e.g., all start with same prefix)
	//
	// This format avoids duplicate IDs and matches Antfly's batch write interface.
	Records map[string]interface{} `json:"records"`

	// SyncLevel Synchronization level for batch operations:
	// - "propose": Wait for Raft proposal acceptance (fastest, default)
	// - "write": Wait for Pebble KV write
	// - "full_text": Wait for full-text index WAL write
	// - "enrichments": Pre-compute enrichments before Raft proposal (synchronous enrichment generation)
	// - "aknn": Wait for vector index write with best-effort synchronous embedding (falls back to async on timeout, slowest, most durable)
	SyncLevel SyncLevel `json:"sync_level,omitempty,omitzero"`
}

// LinearMergeResult defines model for LinearMergeResult.
type LinearMergeResult struct {
	// Deleted Records deleted or would be deleted (if dry_run=true)
	Deleted int `json:"deleted"`

	// DeletedIds IDs that were deleted (or would be deleted if dry_run=true). Only included if dry_run=true.
	DeletedIds []string          `json:"deleted_ids,omitempty,omitzero"`
	Failed     []FailedOperation `json:"failed,omitempty,omitzero"`

	// KeyRange Key range processed in this request
	KeyRange KeyRange `json:"key_range,omitempty,omitzero"`

	// KeysScanned Total number of keys scanned from Antfly during range query
	KeysScanned int `json:"keys_scanned,omitempty,omitzero"`

	// Message Additional information (e.g., "stopped at shard boundary", "dry run - no changes made")
	Message string `json:"message,omitempty,omitzero"`

	// NextCursor ID of last record in this batch (use for next request)
	NextCursor string `json:"next_cursor"`

	// Skipped Records skipped because content hash matched (unchanged)
	Skipped int `json:"skipped"`

	// Status Status of a linear merge page operation:
	// - "success": All records in batch processed successfully
	// - "partial": Processing stopped at shard boundary, client should retry with next_cursor
	// - "error": Fatal error occurred, no records processed successfully
	Status LinearMergePageStatus `json:"status"`
	Took   time.Duration         `json:"took,omitempty,omitzero"`

	// Upserted Records inserted or updated (0 if dry_run=true)
	Upserted int `json:"upserted"`
}

// MatchAllQuery defines model for MatchAllQuery.
type MatchAllQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost    Boost                  `json:"boost,omitzero"`
	MatchAll map[string]interface{} `json:"match_all"`
}

// MatchNoneQuery defines model for MatchNoneQuery.
type MatchNoneQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost     Boost                  `json:"boost,omitzero"`
	MatchNone map[string]interface{} `json:"match_none"`
}

// MatchPhraseQuery defines model for MatchPhraseQuery.
type MatchPhraseQuery struct {
	Analyzer string `json:"analyzer,omitempty,omitzero"`

	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost Boost  `json:"boost,omitzero"`
	Field string `json:"field,omitempty,omitzero"`

	// Fuzziness The fuzziness of the query. Can be an integer or "auto".
	Fuzziness   Fuzziness `json:"fuzziness,omitempty,omitzero"`
	MatchPhrase string    `json:"match_phrase"`
}

// MatchQuery defines model for MatchQuery.
type MatchQuery struct {
	Analyzer string `json:"analyzer,omitempty,omitzero"`

	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost Boost  `json:"boost,omitzero"`
	Field string `json:"field,omitempty,omitzero"`

	// Fuzziness The fuzziness of the query. Can be an integer or "auto".
	Fuzziness    Fuzziness          `json:"fuzziness,omitempty,omitzero"`
	Match        string             `json:"match"`
	Operator     MatchQueryOperator `json:"operator,omitempty,omitzero"`
	PrefixLength int32              `json:"prefix_length,omitempty,omitzero"`
}

// MatchQueryOperator defines model for MatchQuery.Operator.
type MatchQueryOperator string

// MergeStrategy Merge strategy for combining results from the semantic_search and full_text_search.
// rrf: Reciprocal Rank Fusion - combines scores using reciprocal rank formula
// rsf: Relative Score Fusion - normalizes scores by min/max within a window and combines weighted scores
// failover: Use full_text_search if embedding generation fails
type MergeStrategy string

// MultiBatchRequest Cross-table batch operations in a single atomic transaction.
//
// Groups batch operations by table name. All operations across all tables
// are committed atomically using distributed 2-phase commit (2PC).
//
// **Atomicity**: Either all operations across all tables succeed, or none do.
// This enables use cases like transferring a record from one table to another,
// or maintaining referential integrity across tables.
type MultiBatchRequest struct {
	// SyncLevel Synchronization level for batch operations:
	// - "propose": Wait for Raft proposal acceptance (fastest, default)
	// - "write": Wait for Pebble KV write
	// - "full_text": Wait for full-text index WAL write
	// - "enrichments": Pre-compute enrichments before Raft proposal (synchronous enrichment generation)
	// - "aknn": Wait for vector index write with best-effort synchronous embedding (falls back to async on timeout, slowest, most durable)
	SyncLevel SyncLevel `json:"sync_level,omitempty,omitzero"`

	// Tables Map of table names to batch operations for that table.
	// Each entry follows the same format as a single-table BatchRequest.
	Tables map[string]BatchRequest `json:"tables"`
}

// MultiBatchResponse Response for a cross-table batch operation. Contains per-table results.
type MultiBatchResponse struct {
	// Tables Per-table batch results
	Tables map[string]BatchResponse `json:"tables,omitempty,omitzero"`
}

// MultiPhraseQuery defines model for MultiPhraseQuery.
type MultiPhraseQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost Boost  `json:"boost,omitzero"`
	Field string `json:"field,omitempty,omitzero"`

	// Fuzziness The fuzziness of the query. Can be an integer or "auto".
	Fuzziness Fuzziness  `json:"fuzziness,omitempty,omitzero"`
	Terms     [][]string `json:"terms"`
}

// NodeFilter Filter nodes during graph traversal using existing query primitives
type NodeFilter struct {
	// FilterPrefix Filter by key prefix
	FilterPrefix string `json:"filter_prefix,omitempty,omitzero"`

	// FilterQuery Bleve query to filter nodes (same syntax as search filter_query)
	FilterQuery map[string]interface{} `json:"filter_query,omitempty,omitzero"`
}

// NumericRangeQuery defines model for NumericRangeQuery.
type NumericRangeQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost        Boost   `json:"boost,omitzero"`
	Field        string  `json:"field,omitempty,omitzero"`
	InclusiveMax bool    `json:"inclusive_max,omitzero"`
	InclusiveMin bool    `json:"inclusive_min,omitzero"`
	Max          float64 `json:"max,omitzero"`
	Min          float64 `json:"min,omitzero"`
}

// OllamaEmbedderConfig Configuration for the Ollama embedding provider.
//
// Local embeddings for privacy and offline use. URL via `url` field or `OLLAMA_HOST` env var.
//
// **Example Models:** nomic-embed-text (768 dims), mxbai-embed-large (1024 dims), all-minilm (384 dims)
//
// **Docs:** https://ollama.com/search?c=embedding
type OllamaEmbedderConfig struct {
	// Model The name of the Ollama model to use (e.g., 'nomic-embed-text', 'mxbai-embed-large').
	Model string `json:"model"`

	// Url The URL of the Ollama API endpoint. Can also be set via OLLAMA_HOST environment variable.
	Url string `json:"url,omitempty,omitzero"`
}

// OllamaGeneratorConfig Configuration for the Ollama generative AI provider.
//
// Ollama provides local LLM inference for privacy and offline use.
//
// **Example Models:** llama3.3:70b, qwen2.5:72b, deepseek-r1:70b, mistral:7b, llava:34b
//
// **Docs:** https://ollama.com/library
type OllamaGeneratorConfig struct {
	// MaxTokens Maximum number of tokens to generate.
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Model The name of the Ollama model to use (e.g., 'llama3.3:70b', 'qwen2.5:72b', 'deepseek-coder:33b').
	Model string `json:"model"`

	// Temperature Controls randomness in generation (0.0-2.0).
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// TopK Top-k sampling parameter.
	TopK int `json:"top_k,omitempty,omitzero"`

	// TopP Nucleus sampling parameter.
	TopP float32 `json:"top_p,omitempty,omitzero"`

	// Url The URL of the Ollama API endpoint.
	Url string `json:"url,omitempty,omitzero"`
}

// OllamaRerankerConfig Configuration for the Ollama reranking provider.
type OllamaRerankerConfig struct {
	// Model The name of the Ollama model to use for reranking.
	Model string `json:"model"`

	// Url The URL of the Ollama API endpoint.
	Url string `json:"url,omitempty,omitzero"`
}

// OpenAIEmbedderConfig Configuration for the OpenAI embedding provider.
//
// API key via `api_key` field or `OPENAI_API_KEY` environment variable.
// Supports OpenAI-compatible APIs via `url` field.
//
// **Example Models:** text-embedding-3-small (default, 1536 dims), text-embedding-3-large (3072 dims)
//
// **Docs:** https://platform.openai.com/docs/guides/embeddings
type OpenAIEmbedderConfig struct {
	// ApiKey The OpenAI API key. Can also be set via OPENAI_API_KEY environment variable.
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// Dimensions Output dimension for the embedding (uses MRL for dimension reduction). Recommended: 256, 512, 1024, 1536, or 3072.
	Dimensions int `json:"dimensions,omitempty,omitzero"`

	// Model The name of the OpenAI model to use.
	Model string `json:"model"`

	// Url The URL of the OpenAI API endpoint. Defaults to OpenAI's API. Can be set via OPENAI_BASE_URL environment variable.
	Url string `json:"url,omitempty,omitzero"`
}

// OpenAIGeneratorConfig Configuration for the OpenAI generative AI provider.
//
// **Example Models:** gpt-4.1 (default), gpt-4.1-mini, o3, o4-mini
//
// **Docs:** https://platform.openai.com/docs/models
type OpenAIGeneratorConfig struct {
	// ApiKey The OpenAI API key.
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// FrequencyPenalty Penalty for token frequency (-2.0 to 2.0).
	FrequencyPenalty float32 `json:"frequency_penalty,omitempty,omitzero"`

	// MaxTokens Maximum number of tokens to generate.
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Model The name of the OpenAI model to use (e.g., 'gpt-4.1', 'gpt-4.1-mini', 'o4-mini').
	Model string `json:"model"`

	// PresencePenalty Penalty for token presence (-2.0 to 2.0).
	PresencePenalty float32 `json:"presence_penalty,omitempty,omitzero"`

	// Temperature Controls randomness in generation (0.0-2.0).
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// TopP Nucleus sampling parameter.
	TopP float32 `json:"top_p,omitempty,omitzero"`

	// Url The URL of the OpenAI API endpoint.
	Url string `json:"url,omitempty,omitzero"`
}

// OpenRouterEmbedderConfig Configuration for the OpenRouter embedding provider.
//
// OpenRouter provides a unified API for multiple embedding models from different providers.
// API key via `api_key` field or `OPENROUTER_API_KEY` environment variable.
//
// **Example Models:** openai/text-embedding-3-small (default), openai/text-embedding-3-large,
// google/gemini-embedding-001, qwen/qwen3-embedding-8b
//
// **Docs:** https://openrouter.ai/docs/api/reference/embeddings
type OpenRouterEmbedderConfig struct {
	// ApiKey The OpenRouter API key. Can also be set via OPENROUTER_API_KEY environment variable.
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// Dimensions Output dimension for the embedding (if supported by the model).
	Dimensions int `json:"dimensions,omitempty,omitzero"`

	// Model The OpenRouter model identifier (e.g., 'openai/text-embedding-3-small', 'google/gemini-embedding-001').
	Model string `json:"model"`
}

// OpenRouterGeneratorConfig Configuration for the OpenRouter generative AI provider.
//
// OpenRouter provides a unified API for multiple LLM providers with automatic fallback routing.
// API key via `api_key` field or `OPENROUTER_API_KEY` environment variable.
//
// **Model Selection:**
// - Use `model` for a single model (e.g., "openai/gpt-4.1", "anthropic/claude-sonnet-4-5-20250929")
// - Use `models` array for fallback routing - OpenRouter tries models in order until one succeeds
//
// **Example Models:** openai/gpt-4.1, anthropic/claude-sonnet-4-5-20250929, google/gemini-2.5-flash,
// meta-llama/llama-3.3-70b-instruct
//
// **Docs:** https://openrouter.ai/docs/api/api-reference/chat/send-chat-completion-request
type OpenRouterGeneratorConfig struct {
	// ApiKey The OpenRouter API key. Can also be set via OPENROUTER_API_KEY environment variable.
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// FrequencyPenalty Penalty for token frequency (-2.0 to 2.0).
	FrequencyPenalty float32 `json:"frequency_penalty,omitempty,omitzero"`

	// MaxTokens Maximum number of tokens to generate in the response.
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Model Single model identifier (e.g., 'openai/gpt-4.1'). Either model or models must be provided.
	Model string `json:"model,omitempty,omitzero"`

	// Models Array of model identifiers for fallback routing. OpenRouter tries each model in order
	// until one succeeds. Either model or models must be provided.
	Models []string `json:"models,omitempty,omitzero"`

	// PresencePenalty Penalty for token presence (-2.0 to 2.0).
	PresencePenalty float32 `json:"presence_penalty,omitempty,omitzero"`

	// Temperature Controls randomness in generation (0.0-2.0). Higher values make output more random.
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// TopP Nucleus sampling parameter (0.0-1.0). Alternative to temperature.
	TopP float32 `json:"top_p,omitempty,omitzero"`
}

// Path defines model for Path.
type Path struct {
	Edges  []PathEdge `json:"edges,omitempty,omitzero"`
	Length int        `json:"length,omitempty,omitzero"`

	// Nodes Ordered list of node keys (base64-encoded)
	Nodes       []string `json:"nodes,omitempty,omitzero"`
	TotalWeight float64  `json:"total_weight,omitempty,omitzero"`
}

// PathEdge defines model for PathEdge.
type PathEdge struct {
	Metadata map[string]interface{} `json:"metadata,omitempty,omitzero"`
	Source   string                 `json:"source,omitempty,omitzero"`
	Target   string                 `json:"target,omitempty,omitzero"`
	Type     string                 `json:"type,omitempty,omitzero"`
	Weight   float64                `json:"weight,omitempty,omitzero"`
}

// PathFindRequest defines model for PathFindRequest.
type PathFindRequest struct {
	// Direction Direction of edges to query:
	// - out: Outgoing edges from the node
	// - in: Incoming edges to the node
	// - both: Both outgoing and incoming edges
	Direction EdgeDirection `json:"direction,omitempty,omitzero"`

	// EdgeTypes Filter by specific edge types
	EdgeTypes []string `json:"edge_types,omitempty,omitzero"`
	K         int      `json:"k,omitempty,omitzero"`
	MaxDepth  int      `json:"max_depth,omitempty,omitzero"`
	MaxWeight float64  `json:"max_weight,omitempty,omitzero"`
	MinWeight float64  `json:"min_weight,omitempty,omitzero"`

	// Source Source node key (base64-encoded)
	Source string `json:"source"`

	// Target Target node key (base64-encoded)
	Target string `json:"target"`

	// WeightMode Algorithm for path finding:
	// - min_hops: Shortest path by hop count (breadth-first search, ignores weights)
	// - max_weight: Path with maximum product of edge weights (strongest connection chain)
	// - min_weight: Path with minimum sum of edge weights (lowest cost route)
	WeightMode PathFindWeightMode `json:"weight_mode,omitempty,omitzero"`
}

// PathFindResult defines model for PathFindResult.
type PathFindResult struct {
	Paths        []Path  `json:"paths,omitempty,omitzero"`
	PathsFound   int     `json:"paths_found,omitempty,omitzero"`
	SearchTimeMs float64 `json:"search_time_ms,omitempty,omitzero"`
	Source       string  `json:"source,omitempty,omitzero"`
	Target       string  `json:"target,omitempty,omitzero"`

	// WeightMode Algorithm for path finding:
	// - min_hops: Shortest path by hop count (breadth-first search, ignores weights)
	// - max_weight: Path with maximum product of edge weights (strongest connection chain)
	// - min_weight: Path with minimum sum of edge weights (lowest cost route)
	WeightMode PathFindWeightMode `json:"weight_mode,omitempty,omitzero"`
}

// PathFindWeightMode Algorithm for path finding:
// - min_hops: Shortest path by hop count (breadth-first search, ignores weights)
// - max_weight: Path with maximum product of edge weights (strongest connection chain)
// - min_weight: Path with minimum sum of edge weights (lowest cost route)
type PathFindWeightMode string

// PathWeightMode Path weighting algorithm for pathfinding:
// - min_hops: Minimize number of edges
// - min_weight: Minimize sum of edge weights
// - max_weight: Maximize product of edge weights
type PathWeightMode string

// PatternEdgeStep Edge constraints in a pattern step
type PatternEdgeStep struct {
	// Direction Direction of edges to query:
	// - out: Outgoing edges from the node
	// - in: Incoming edges to the node
	// - both: Both outgoing and incoming edges
	Direction EdgeDirection `json:"direction,omitempty,omitzero"`

	// MaxHops Maximum number of hops (>1 = variable-length path)
	MaxHops int `json:"max_hops,omitempty,omitzero"`

	// MaxWeight Maximum edge weight filter
	MaxWeight float64 `json:"max_weight,omitempty,omitzero"`

	// MinHops Minimum number of hops (1 = direct edge)
	MinHops int `json:"min_hops,omitempty,omitzero"`

	// MinWeight Minimum edge weight filter
	MinWeight float64 `json:"min_weight,omitempty,omitzero"`

	// Types Edge types to traverse (empty = any)
	Types []string `json:"types,omitempty,omitzero"`
}

// PatternMatch A single match from a pattern query
type PatternMatch struct {
	// Bindings Map of alias to matched node
	Bindings map[string]GraphResultNode `json:"bindings,omitempty,omitzero"`

	// Path Edges traversed in this match
	Path []PathEdge `json:"path,omitempty,omitzero"`
}

// PatternStep A step in a graph pattern query
type PatternStep struct {
	// Alias Name for this node (reuse alias for cycle detection)
	Alias string `json:"alias,omitempty,omitzero"`

	// Edge Edge constraints in a pattern step
	Edge PatternEdgeStep `json:"edge,omitempty,omitzero"`

	// NodeFilter Filter nodes during graph traversal using existing query primitives
	NodeFilter NodeFilter `json:"node_filter,omitempty,omitzero"`
}

// Permission defines model for Permission.
type Permission struct {
	// Resource Resource name (e.g., table name, target username, or '*' for global).
	Resource string `json:"resource"`

	// ResourceType Type of the resource, e.g., table, user, or global ('*').
	ResourceType ResourceType `json:"resource_type"`

	// Type Type of permission.
	Type PermissionType `json:"type"`
}

// PermissionType Type of permission.
type PermissionType string

// PhraseQuery defines model for PhraseQuery.
type PhraseQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost Boost  `json:"boost,omitzero"`
	Field string `json:"field,omitempty,omitzero"`

	// Fuzziness The fuzziness of the query. Can be an integer or "auto".
	Fuzziness Fuzziness `json:"fuzziness,omitempty,omitzero"`
	Terms     []string  `json:"terms"`
}

// PrefixQuery defines model for PrefixQuery.
type PrefixQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost  Boost  `json:"boost,omitzero"`
	Field  string `json:"field,omitempty,omitzero"`
	Prefix string `json:"prefix"`
}

// Pruner Configuration for pruning search results based on score quality.
// Helps filter out low-relevance results in RAG pipelines by detecting
// score gaps or deviations from top results.
type Pruner struct {
	// MaxScoreGapPercent Stop returning results when score drops more than this percentage
	// from the previous result. Detects "elbows" in score distribution.
	// For example, 30.0 stops when score drops 30% from previous result.
	MaxScoreGapPercent float64 `json:"max_score_gap_percent,omitempty,omitzero"`

	// MinAbsoluteScore Hard minimum score threshold. Results with scores below this value
	// are excluded regardless of other pruning settings.
	MinAbsoluteScore float64 `json:"min_absolute_score,omitempty,omitzero"`

	// MinScoreRatio Keep only results with score >= max_score * min_score_ratio.
	// For example, 0.5 keeps results scoring at least half of the top result.
	// Applied after fusion scoring.
	MinScoreRatio float64 `json:"min_score_ratio,omitempty,omitzero"`

	// RequireMultiIndex Only keep results that appear in multiple indexes (both full-text
	// and vector search). Useful for increasing precision by requiring
	// agreement between different retrieval methods.
	RequireMultiIndex bool `json:"require_multi_index,omitempty,omitzero"`

	// StdDevThreshold Keep results within N standard deviations below the mean score.
	// For example, 1.0 keeps results with score >= mean - 1*stddev.
	// Useful for statistical outlier detection in result sets.
	StdDevThreshold float64 `json:"std_dev_threshold,omitempty,omitzero"`
}

// Query defines model for Query.
type Query struct {
	union json.RawMessage
}

// QueryBuilderRequest defines model for QueryBuilderRequest.
type QueryBuilderRequest struct {
	// Generator A unified configuration for a generative AI provider.
	//
	// Generators can be configured with custom prompts using templates. Templates use
	// Handlebars syntax and support various built-in helpers for formatting and data manipulation.
	//
	// **Template System:**
	// - **Syntax**: Handlebars templating (https://handlebarsjs.com/guide/)
	// - **Caching**: Templates are automatically cached with configurable TTL (default: 5 minutes)
	// - **Context**: Templates receive the full context data passed to the generator
	//
	// **Built-in Helpers:**
	//
	// 1. **scrubHtml** - Remove script/style tags and extract clean text from HTML
	//    ```handlebars
	//    {{scrubHtml html_content}}
	//    ```
	//    - Removes `<script>` and `<style>` tags
	//    - Adds newlines after block elements (p, div, h1-h6, li, etc.)
	//    - Returns plain text with preserved readability
	//    - Useful for cleaning web content before summarization
	//
	// 2. **eq** - Equality comparison for conditionals
	//    ```handlebars
	//    {{#if (eq status "active")}}Active{{/if}}
	//    {{#if (eq @key "special")}}Special field{{/if}}
	//    ```
	//    - Use in `{{#if}}` blocks for conditional logic
	//    - Compares any two values for equality
	//
	// 3. **media** - GenKit dotprompt media directive for multimodal content
	//    ```handlebars
	//    {{media url=imageDataURI}}
	//    {{media url=this.image_url}}
	//    {{media url="https://example.com/image.jpg"}}
	//    {{media url="s3://endpoint/bucket/image.png"}}
	//    {{media url="file:///path/to/image.jpg"}}
	//    ```
	//
	//    **Supported URL Schemes:**
	//    - `data:` - Base64 encoded data URIs (e.g., `data:image/jpeg;base64,...`)
	//    - `http://` / `https://` - Web URLs with automatic content type detection
	//    - `file://` - Local filesystem paths
	//    - `s3://` - S3-compatible storage (format: `s3://endpoint/bucket/key`)
	//
	//    **Automatic Content Processing:**
	//    - **Images**: Downloaded, resized (if needed), converted to data URIs
	//    - **PDFs**: Text extracted or first page rendered as image
	//    - **HTML**: Readable text extracted using Mozilla Readability
	//
	//    **Security Controls:**
	//    Downloads are protected by content security settings (see Configuration Reference):
	//    - Allowed host whitelist
	//    - Private IP blocking (prevents SSRF attacks)
	//    - Download size limits (default: 100MB)
	//    - Download timeouts (default: 30s)
	//    - Image dimension limits (default: 2048px, auto-resized)
	//
	//    See: https://antfly.io/docs/configuration#security--cors
	//
	// 4. **encodeToon** - Encode data in TOON format (Token-Oriented Object Notation)
	//    ```handlebars
	//    {{encodeToon this.fields}}
	//    {{encodeToon this.fields lengthMarker=false indent=4}}
	//    {{encodeToon this.fields delimiter="\t"}}
	//    ```
	//
	//    **What is TOON?**
	//    TOON is a compact, human-readable format designed for passing structured data to LLMs.
	//    It provides **30-60% token reduction** compared to JSON while maintaining high LLM
	//    comprehension accuracy.
	//
	//    **Key Features:**
	//    - Compact syntax using `:` for key-value pairs
	//    - Array length markers: `tags[#3]: ai,search,ml`
	//    - Tabular format for uniform data structures
	//    - Optimized for LLM parsing and understanding
	//    - Maintains human readability
	//
	//    **Benefits:**
	//    - **Lower API costs** - Reduced token usage means lower LLM API costs
	//    - **Faster responses** - Less tokens to process
	//    - **More context** - Fit more documents within token limits
	//
	//    **Options:**
	//    - `lengthMarker` (bool): Add # prefix to array counts like `[#3]` (default: true)
	//    - `indent` (int): Indentation spacing for nested objects (default: 2)
	//    - `delimiter` (string): Field separator for tabular arrays (default: none, use `"\t"` for tabs)
	//
	//    **Example output:**
	//    ```
	//    title: Introduction to Vector Search
	//    author: Jane Doe
	//    tags[#3]: ai,search,ml
	//    metadata:
	//      edition: 2
	//      pages: 450
	//    ```
	//
	//    **Default in RAG:** TOON is the default format for document rendering in RAG queries.
	//
	//    **References:**
	//    - TOON Specification: https://github.com/toon-format/toon
	//    - Go Implementation: https://github.com/alpkeskin/gotoon
	//
	// **Template Examples:**
	//
	// RAG summarization with document references:
	// ```handlebars
	// Based on these documents, provide a comprehensive summary:
	//
	// {{#each documents}}
	// Document {{this.id}}:
	// {{scrubHtml this.content}}
	//
	// {{/each}}
	//
	// Valid document IDs: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
	// ```
	//
	// Conditional formatting:
	// ```handlebars
	// {{#if system_prompt}}System: {{system_prompt}}{{/if}}
	//
	// User Query: {{query}}
	//
	// {{#if context}}
	// Context:
	// {{#each context}}
	// - {{this}}
	// {{/each}}
	// {{/if}}
	// ```
	//
	// Multimodal prompt with images:
	// ```handlebars
	// Analyze this image:
	// {{media url=image_url}}
	//
	// Focus on: {{focus_area}}
	// ```
	//
	// Structured data encoding:
	// ```handlebars
	// User Profile:
	// {{encodeToon user_data indent=2 lengthMarker=true}}
	//
	// Please analyze this profile.
	// ```
	//
	// **Common Use Cases:**
	// - **RAG (Retrieval-Augmented Generation)**: Format retrieved documents with citations
	// - **Summarization**: Clean HTML content and structure summaries
	// - **Query Classification**: Format queries with metadata for better classification
	// - **Multimodal**: Include images/audio/video in prompts
	// - **Data Formatting**: Convert structured data to readable text
	//
	// **Best Practices:**
	// - Keep templates simple - complex logic belongs in application code
	// - Use clear, descriptive field names in context
	// - Handle missing fields gracefully (templates use "missingkey=zero" by default)
	// - Test templates with representative data before production use
	Generator GeneratorConfig `json:"generator,omitempty,omitzero"`

	// Intent Natural language description of the search intent
	Intent string `json:"intent"`

	// SchemaFields List of searchable field names to consider. Overrides table schema if provided.
	SchemaFields []string `json:"schema_fields,omitempty,omitzero"`

	// Table Name of the table to build query for. If provided, uses table schema for field context.
	Table string `json:"table,omitempty,omitzero"`
}

// QueryBuilderResult defines model for QueryBuilderResult.
type QueryBuilderResult struct {
	// Confidence Model's confidence in the generated query (0.0-1.0)
	Confidence float64 `json:"confidence,omitempty,omitzero"`

	// Explanation Human-readable explanation of what the query does and why it was structured this way
	Explanation string `json:"explanation,omitempty,omitzero"`

	// Query Generated search query in simplified DSL format.
	// Can be used directly in QueryRequest.full_text_search or filter_query.
	Query map[string]interface{} `json:"query"`

	// Warnings Any issues, limitations, or assumptions made when generating the query
	Warnings []string `json:"warnings,omitempty,omitzero"`
}

// QueryHit A single query result hit
type QueryHit struct {
	// ID ID of the record.
	ID string `json:"_id"`

	// IndexScores Scores partitioned by index when using RRF search.
	IndexScores map[string]interface{} `json:"_index_scores,omitempty,omitzero"`

	// Score Relevance score of the hit.
	Score  float64                `json:"_score"`
	Source map[string]interface{} `json:"_source,omitempty,omitzero"`
}

// QueryHits A list of query hits.
type QueryHits struct {
	Hits []QueryHit `json:"hits"`

	// MaxScore Maximum score of the results.
	MaxScore float64 `json:"max_score,omitempty,omitzero"`

	// Total Total number of hits available.
	Total uint64 `json:"total,omitempty"`
}

// QueryRequest defines model for QueryRequest.
type QueryRequest struct {
	// Aggregations Aggregation requests for computing metrics and bucketing results.
	// Each key is a user-defined name for the aggregation, and the value specifies the aggregation configuration.
	//
	// Supports metric aggregations (sum, avg, min, max, count, stats, cardinality),
	// bucketing aggregations (terms, range, date_range, histogram, date_histogram),
	// geo aggregations (geohash_grid, geo_distance), and analytics (significant_terms).
	//
	// Example:
	// ```json
	// {
	//   "price_stats": {
	//     "type": "stats",
	//     "field": "price"
	//   },
	//   "categories": {
	//     "type": "terms",
	//     "field": "category",
	//     "size": 10
	//   }
	// }
	// ```
	Aggregations map[string]AggregationRequest `json:"aggregations,omitempty,omitzero"`
	Analyses     *Analyses                     `json:"analyses,omitempty"`

	// Count If true, returns only the total count of matching documents without retrieving the actual documents.
	// Useful for pagination and displaying result counts.
	Count bool `json:"count,omitempty,omitzero"`

	// DistanceOver Minimum distance threshold for semantic similarity search. Results with distance
	// less than this value are excluded.
	//
	// Useful for excluding near-exact duplicates or finding dissimilar documents.
	DistanceOver *float32 `json:"distance_over,omitempty"`

	// DistanceUnder Maximum distance threshold for semantic similarity search. Results with distance
	// greater than this value are excluded. Lower distances indicate higher similarity.
	//
	// Useful for filtering out low-confidence matches.
	DistanceUnder *float32 `json:"distance_under,omitempty"`

	// DocumentRenderer Optional Handlebars template string for rendering document content in RAG queries.
	// Template has access to document fields via `{{this.fields.fieldName}}`.
	//
	// **Default**: Uses TOON (Token-Oriented Object Notation) format for 30-60% token reduction:
	// ```handlebars
	// {{encodeToon this.fields}}
	// ```
	//
	// **Available Helpers**:
	// - `encodeToon` - Renders fields in compact TOON format with configurable options:
	//   - `lengthMarker` (bool): Add # prefix to array counts (default: true)
	//   - `indent` (int): Indentation spacing (default: 2)
	//   - `delimiter` (string): Field separator for tabular arrays
	// - `scrubHtml` - Removes HTML tags and extracts text
	// - `media` - Wraps data URIs for GenKit multimodal support
	// - `eq` - Equality comparison for conditionals
	//
	// **Examples**:
	// - Basic TOON: `{{encodeToon this.fields}}`
	// - Compact TOON: `{{encodeToon this.fields lengthMarker=false indent=0}}`
	// - Tabular data: `{{encodeToon this.fields delimiter="\t"}}`
	// - Custom template: `Title: {{this.fields.title}}\nBody: {{this.fields.body}}`
	// - Traditional format: `{{#each this.fields}}{{@key}}: {{this}}\n{{/each}}`
	//
	// TOON format produces compact, LLM-optimized output like:
	// ```
	// title: Introduction to Vector Search
	// author: Jane Doe
	// tags[#3]: ai,search,ml
	// ```
	//
	// **References**:
	// - TOON Specification: https://github.com/toon-format/toon
	// - Go Implementation: https://github.com/alpkeskin/gotoon
	DocumentRenderer string `json:"document_renderer,omitempty,omitzero"`

	// EmbeddingTemplate Optional Handlebars template for multimodal embedding of the semantic_search query.
	// The template has access to `this` which contains the semantic_search string value.
	//
	// Use this when you want to embed multimodal content (images, PDFs, etc.) instead of
	// just text. The template is rendered using dotprompt with access to remote content helpers.
	//
	// **Available Helpers**:
	// - `remoteMedia url=<url>` - Fetches and embeds remote images/media
	// - `remotePDF url=<url>` - Fetches and extracts content from PDFs
	// - `remoteText url=<url>` - Fetches and includes remote text content
	//
	// **Examples**:
	// - PDF search: `{{remotePDF url=this}}`
	// - Image search: `{{remoteMedia url=this}}`
	// - Mixed: `Search for: {{this}} {{#if this}}{{remoteMedia url=this}}{{/if}}`
	//
	// When not specified, the semantic_search string is embedded as plain text.
	EmbeddingTemplate string `json:"embedding_template,omitempty,omitzero"`

	// Embeddings Pre-computed embeddings to use for semantic searches instead of embedding the semantic_search string.
	// The keys are the index names, and values are the embedding vectors.
	//
	// Use when you've already generated embeddings on the client side to avoid redundant embedding calls.
	Embeddings map[string][]float32 `json:"embeddings,omitempty,omitzero"`

	// ExclusionQuery Bleve query applied as a NOT condition. Documents matching this query are excluded
	// from results. Applied before scoring.
	//
	// See bleve-query-openapi.yaml for complete type definitions.
	//
	// Use for:
	// - Excluding drafts: `"status:draft"`
	// - Removing deprecated content: `"deprecated:true"`
	// - Filtering out archived items: `"status:archived"`
	ExclusionQuery json.RawMessage `json:"exclusion_query,omitempty,omitzero"`

	// ExpandStrategy Strategy for merging graph results with search results:
	// - union: Include nodes from both search and graph results
	// - intersection: Only include nodes appearing in both
	ExpandStrategy QueryRequestExpandStrategy `json:"expand_strategy,omitempty,omitzero"`

	// Fields List of fields to include in the results. If not specified, all fields are returned.
	// Use to reduce response size and improve performance.
	Fields []string `json:"fields,omitempty,omitzero"`

	// FilterPrefix Filter results by key prefix. Only returns documents whose keys start with this string.
	// Applied before scoring to improve performance.
	//
	// Common use cases:
	// - Multi-tenant filtering: `"tenant:acme:"`
	// - User-specific data: `"user:123:"`
	// - Document type filtering: `"article:"`
	FilterPrefix []byte `json:"filter_prefix,omitempty,omitzero"`

	// FilterQuery Bleve query applied as an AND condition. Documents must match both the main query
	// and this filter. Applied before scoring for better performance.
	//
	// See bleve-query-openapi.yaml for complete type definitions.
	//
	// Use for:
	// - Status filtering: `"status:published"`
	// - Date ranges: `"created_at:>2023-01-01"`
	// - Category filtering: `"category:technology AND language:en"`
	FilterQuery json.RawMessage `json:"filter_query,omitempty,omitzero"`

	// ForeignSources Map of table name to foreign data source configuration for query-time federated access.
	// When a table name referenced in this query (or in a join's `right_table`) appears as a key
	// here, the query is routed to the external database instead of Antfly shards.
	//
	// This enables joining Antfly search results with structured relational data (customer records,
	// product catalogs, etc.) without ingesting that data into Antfly.
	//
	// **Supported operations on foreign tables:** filter_query, field selection, limit/offset.
	// **Not supported:** full_text_search, semantic_search, graph_searches, aggregations, reranker.
	//
	// **Example - Join Antfly products with Postgres customers:**
	// ```json
	// {
	//   "table": "products",
	//   "full_text_search": {"query": "category:electronics"},
	//   "join": {
	//     "right_table": "pg_customers",
	//     "on": {"left_field": "customer_id", "right_field": "id"}
	//   },
	//   "foreign_sources": {
	//     "pg_customers": {
	//       "type": "postgres",
	//       "dsn": "${secret:pg_dsn}",
	//       "postgres_table": "customers"
	//     }
	//   }
	// }
	// ```
	ForeignSources map[string]ForeignSource `json:"foreign_sources,omitempty,omitzero"`

	// FullTextSearch Bleve query for full-text search. Supports all Bleve query types.
	//
	// See bleve-query-openapi.yaml for complete type definitions.
	//
	// Examples:
	// - Simple: `{"query": "computer"}`
	// - Field-specific: `{"query": "body:computer"}`
	// - Boolean: `{"query": "artificial AND intelligence"}`
	// - Range: `{"query": "year:>2020"}`
	// - Phrase: `{"query": "\"exact phrase\""}`
	FullTextSearch json.RawMessage `json:"full_text_search,omitempty,omitzero"`

	// GraphSearches Declarative graph queries to execute after full-text/vector searches.
	// Results can reference search results using node selectors like $full_text_results.
	GraphSearches map[string]GraphQuery `json:"graph_searches,omitempty,omitzero"`

	// Indexes List of vector index names to use for semantic search. Required when using semantic_search.
	// Multiple indexes can be specified, and their results will be merged using RRF.
	Indexes []string `json:"indexes,omitempty,omitzero"`

	// Join Configuration for joining data from another table.
	// Supports inner, left, and right joins with automatic strategy selection.
	Join JoinClause `json:"join,omitempty,omitzero"`

	// Limit Maximum number of results to return. For semantic_search, this is the topk parameter.
	// Default varies by query type (typically 10).
	Limit int `json:"limit,omitempty,omitzero"`

	// MergeStrategy Merge strategy for combining results from the semantic_search and full_text_search.
	// rrf: Reciprocal Rank Fusion - combines scores using reciprocal rank formula
	// rsf: Relative Score Fusion - normalizes scores by min/max within a window and combines weighted scores
	// failover: Use full_text_search if embedding generation fails
	MergeStrategy MergeStrategy `json:"merge_strategy,omitempty,omitzero"`

	// Offset Number of results to skip for pagination. Only available for full_text_search queries.
	// Not supported for semantic_search due to vector index limitations.
	Offset int `json:"offset,omitempty,omitzero"`

	// OrderBy Sort order for results. Map of field names to boolean (true = descending, false = ascending).
	// Only applicable for full_text_search queries. Semantic searches are always sorted by similarity score.
	OrderBy map[string]bool `json:"order_by,omitempty,omitzero"`

	// Pruner Configuration for pruning search results based on score quality.
	// Helps filter out low-relevance results in RAG pipelines by detecting
	// score gaps or deviations from top results.
	Pruner Pruner `json:"pruner,omitempty,omitzero"`

	// Reranker A unified configuration for a reranking provider.
	Reranker *RerankerConfig `json:"reranker,omitempty"`

	// SemanticSearch Natural language query for vector similarity search. Results are ranked by semantic similarity
	// to the query and can be combined with full_text_search using Reciprocal Rank Fusion (RRF).
	//
	// The semantic_search string is automatically embedded using the configured embedding model
	// for the specified indexes. Use `embedding_template` for multimodal queries.
	SemanticSearch string `json:"semantic_search,omitempty,omitzero"`

	// Table Name of the table to query. Optional for global queries.
	Table string `json:"table,omitempty,omitzero"`
}

// QueryRequestExpandStrategy Strategy for merging graph results with search results:
// - union: Include nodes from both search and graph results
// - intersection: Only include nodes appearing in both
type QueryRequestExpandStrategy string

// QueryResponses Responses from multiple query operations.
type QueryResponses struct {
	Responses []QueryResult `json:"responses,omitempty,omitzero"`
}

// QueryResult Result of a query operation as an array of results and a count.
type QueryResult struct {
	// Aggregations Aggregation results keyed by the user-defined aggregation names from the request.
	// Contains computed metrics or buckets depending on the aggregation type.
	Aggregations map[string]AggregationResult `json:"aggregations,omitempty,omitzero"`

	// Analyses Analysis results like PCA and t-SNE per index embeddings.
	Analyses map[string]AnalysesResult `json:"analyses,omitempty,omitzero"`

	// Error Error message if the query failed.
	Error string `json:"error,omitempty,omitzero"`

	// GraphResults Results from declarative graph queries.
	GraphResults map[string]GraphQueryResult `json:"graph_results,omitempty,omitzero"`

	// Hits A list of query hits.
	Hits QueryHits `json:"hits"`

	// JoinResult Statistics and metadata about join execution.
	JoinResult JoinResult `json:"join_result,omitempty,omitzero"`

	// Status HTTP status code of the query operation.
	Status int32 `json:"status"`

	// Table Which table this result came from
	Table string `json:"table,omitempty,omitzero"`

	// Took Duration of the query in milliseconds.
	Took time.Duration `json:"took"`
}

// QueryStrategy Strategy for query transformation and retrieval:
// - simple: Direct query with multi-phrase expansion. Best for straightforward factual queries.
// - decompose: Break complex queries into sub-questions, retrieve for each. Best for multi-part questions.
// - step_back: Generate broader background query first, then specific query. Best for questions needing context.
// - hyde: Generate hypothetical answer document, embed that for retrieval. Best for abstract/conceptual questions.
type QueryStrategy string

// QueryStringQuery defines model for QueryStringQuery.
type QueryStringQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost Boost  `json:"boost,omitzero"`
	Query string `json:"query"`
}

// RegexpQuery defines model for RegexpQuery.
type RegexpQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost  Boost  `json:"boost,omitzero"`
	Field  string `json:"field,omitempty,omitzero"`
	Regexp string `json:"regexp"`
}

// RerankerConfig defines model for RerankerConfig.
type RerankerConfig struct {
	// Field Field name to extract from documents for reranking.
	Field string `json:"field,omitempty,omitzero"`

	// Provider The reranking provider to use.
	Provider RerankerProvider `json:"provider"`

	// Template Handlebars template to render document text for reranking.
	Template string `json:"template,omitempty,omitzero"`
	union    json.RawMessage
}

// RerankerProvider The reranking provider to use.
type RerankerProvider string

// ResourceType Type of the resource, e.g., table, user, or global ('*').
type ResourceType string

// RestoreRequest defines model for RestoreRequest.
type RestoreRequest = BackupRequest

// RetrievalAgentRequest Request for the retrieval agent. Queries define which tables and indexes
// to search, each as a QueryRequest with optional tree search configuration.
//
// **Pipeline mode** (default, max_iterations=0): Queries are executed
// directly without an LLM tool-calling loop.
//
// **Agentic mode** (max_iterations > 0): The LLM decides which tools to
// call, using the queries to determine available tables and indexes.
type RetrievalAgentRequest struct {
	// AccumulatedFilters Pre-applied filters from prior interactions. These are applied to
	// all search tool invocations.
	AccumulatedFilters []FilterSpec `json:"accumulated_filters,omitempty,omitzero"`

	// AgentKnowledge Domain-specific knowledge to include in the agent's system prompt.
	// Useful for providing context about the document collection.
	AgentKnowledge string `json:"agent_knowledge,omitempty,omitzero"`

	// Chain Chain of generators
	Chain []ChainLink `json:"chain,omitempty,omitzero"`

	// Context Prior messages for multi-turn clarification.
	// Deprecated: use `messages` instead.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Context []ChatMessage `json:"context,omitempty,omitzero"`

	// DocumentRenderer Handlebars template for rendering documents in the generation prompt.
	// Default uses TOON format for token efficiency.
	// Requires steps.generation to be set.
	DocumentRenderer string `json:"document_renderer,omitempty,omitzero"`

	// Generator A unified configuration for a generative AI provider.
	//
	// Generators can be configured with custom prompts using templates. Templates use
	// Handlebars syntax and support various built-in helpers for formatting and data manipulation.
	//
	// **Template System:**
	// - **Syntax**: Handlebars templating (https://handlebarsjs.com/guide/)
	// - **Caching**: Templates are automatically cached with configurable TTL (default: 5 minutes)
	// - **Context**: Templates receive the full context data passed to the generator
	//
	// **Built-in Helpers:**
	//
	// 1. **scrubHtml** - Remove script/style tags and extract clean text from HTML
	//    ```handlebars
	//    {{scrubHtml html_content}}
	//    ```
	//    - Removes `<script>` and `<style>` tags
	//    - Adds newlines after block elements (p, div, h1-h6, li, etc.)
	//    - Returns plain text with preserved readability
	//    - Useful for cleaning web content before summarization
	//
	// 2. **eq** - Equality comparison for conditionals
	//    ```handlebars
	//    {{#if (eq status "active")}}Active{{/if}}
	//    {{#if (eq @key "special")}}Special field{{/if}}
	//    ```
	//    - Use in `{{#if}}` blocks for conditional logic
	//    - Compares any two values for equality
	//
	// 3. **media** - GenKit dotprompt media directive for multimodal content
	//    ```handlebars
	//    {{media url=imageDataURI}}
	//    {{media url=this.image_url}}
	//    {{media url="https://example.com/image.jpg"}}
	//    {{media url="s3://endpoint/bucket/image.png"}}
	//    {{media url="file:///path/to/image.jpg"}}
	//    ```
	//
	//    **Supported URL Schemes:**
	//    - `data:` - Base64 encoded data URIs (e.g., `data:image/jpeg;base64,...`)
	//    - `http://` / `https://` - Web URLs with automatic content type detection
	//    - `file://` - Local filesystem paths
	//    - `s3://` - S3-compatible storage (format: `s3://endpoint/bucket/key`)
	//
	//    **Automatic Content Processing:**
	//    - **Images**: Downloaded, resized (if needed), converted to data URIs
	//    - **PDFs**: Text extracted or first page rendered as image
	//    - **HTML**: Readable text extracted using Mozilla Readability
	//
	//    **Security Controls:**
	//    Downloads are protected by content security settings (see Configuration Reference):
	//    - Allowed host whitelist
	//    - Private IP blocking (prevents SSRF attacks)
	//    - Download size limits (default: 100MB)
	//    - Download timeouts (default: 30s)
	//    - Image dimension limits (default: 2048px, auto-resized)
	//
	//    See: https://antfly.io/docs/configuration#security--cors
	//
	// 4. **encodeToon** - Encode data in TOON format (Token-Oriented Object Notation)
	//    ```handlebars
	//    {{encodeToon this.fields}}
	//    {{encodeToon this.fields lengthMarker=false indent=4}}
	//    {{encodeToon this.fields delimiter="\t"}}
	//    ```
	//
	//    **What is TOON?**
	//    TOON is a compact, human-readable format designed for passing structured data to LLMs.
	//    It provides **30-60% token reduction** compared to JSON while maintaining high LLM
	//    comprehension accuracy.
	//
	//    **Key Features:**
	//    - Compact syntax using `:` for key-value pairs
	//    - Array length markers: `tags[#3]: ai,search,ml`
	//    - Tabular format for uniform data structures
	//    - Optimized for LLM parsing and understanding
	//    - Maintains human readability
	//
	//    **Benefits:**
	//    - **Lower API costs** - Reduced token usage means lower LLM API costs
	//    - **Faster responses** - Less tokens to process
	//    - **More context** - Fit more documents within token limits
	//
	//    **Options:**
	//    - `lengthMarker` (bool): Add # prefix to array counts like `[#3]` (default: true)
	//    - `indent` (int): Indentation spacing for nested objects (default: 2)
	//    - `delimiter` (string): Field separator for tabular arrays (default: none, use `"\t"` for tabs)
	//
	//    **Example output:**
	//    ```
	//    title: Introduction to Vector Search
	//    author: Jane Doe
	//    tags[#3]: ai,search,ml
	//    metadata:
	//      edition: 2
	//      pages: 450
	//    ```
	//
	//    **Default in RAG:** TOON is the default format for document rendering in RAG queries.
	//
	//    **References:**
	//    - TOON Specification: https://github.com/toon-format/toon
	//    - Go Implementation: https://github.com/alpkeskin/gotoon
	//
	// **Template Examples:**
	//
	// RAG summarization with document references:
	// ```handlebars
	// Based on these documents, provide a comprehensive summary:
	//
	// {{#each documents}}
	// Document {{this.id}}:
	// {{scrubHtml this.content}}
	//
	// {{/each}}
	//
	// Valid document IDs: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
	// ```
	//
	// Conditional formatting:
	// ```handlebars
	// {{#if system_prompt}}System: {{system_prompt}}{{/if}}
	//
	// User Query: {{query}}
	//
	// {{#if context}}
	// Context:
	// {{#each context}}
	// - {{this}}
	// {{/each}}
	// {{/if}}
	// ```
	//
	// Multimodal prompt with images:
	// ```handlebars
	// Analyze this image:
	// {{media url=image_url}}
	//
	// Focus on: {{focus_area}}
	// ```
	//
	// Structured data encoding:
	// ```handlebars
	// User Profile:
	// {{encodeToon user_data indent=2 lengthMarker=true}}
	//
	// Please analyze this profile.
	// ```
	//
	// **Common Use Cases:**
	// - **RAG (Retrieval-Augmented Generation)**: Format retrieved documents with citations
	// - **Summarization**: Clean HTML content and structure summaries
	// - **Query Classification**: Format queries with metadata for better classification
	// - **Multimodal**: Include images/audio/video in prompts
	// - **Data Formatting**: Convert structured data to readable text
	//
	// **Best Practices:**
	// - Keep templates simple - complex logic belongs in application code
	// - Use clear, descriptive field names in context
	// - Handle missing fields gracefully (templates use "missingkey=zero" by default)
	// - Test templates with representative data before production use
	Generator GeneratorConfig `json:"generator,omitempty,omitzero"`

	// MaxContextTokens Maximum tokens for document context in tool responses. Documents
	// exceeding this limit are pruned to fit.
	MaxContextTokens int `json:"max_context_tokens,omitempty,omitzero"`

	// MaxIterations Maximum number of tool-calling rounds. Controls how many times the
	// LLM can invoke tools before being forced to return results.
	//
	// - 0: Pipeline mode â€” execute provided queries directly, no LLM loop
	// - 1+: Agentic mode â€” LLM decides which tools to call
	MaxIterations int `json:"max_iterations,omitempty,omitzero"`

	// Messages Conversation messages for multi-turn interaction
	Messages []ChatMessage `json:"messages,omitempty,omitzero"`

	// Queries Queries to execute. Each query carries its own table via the
	// QueryRequest table field.
	//
	// In pipeline mode (max_iterations=0), these are executed directly.
	// In agentic mode, these declare which table and indexes are available.
	Queries []RetrievalQueryRequest `json:"queries"`

	// Query User's natural language query
	Query string `json:"query"`

	// ReserveTokens Tokens to reserve for system prompt, answer generation, and other overhead.
	// Subtracted from max_context_tokens to determine available context budget.
	// Defaults to 4000 if max_context_tokens is set.
	ReserveTokens int `json:"reserve_tokens,omitempty,omitzero"`

	// Steps Configuration for the retrieval agent's pipeline steps and tool-use behavior.
	// Each step can have its own generator (or chain of generators) and step-specific options.
	// If a step is not configured, it is skipped (retrieval always runs).
	Steps RetrievalAgentSteps `json:"steps,omitempty,omitzero"`

	// Stream Enable SSE streaming vs JSON response
	Stream bool `json:"stream,omitempty,omitzero"`
}

// RetrievalAgentResult Result from the retrieval agent
type RetrievalAgentResult struct {
	// AppliedFilters Filters that were applied during retrieval
	AppliedFilters []FilterSpec `json:"applied_filters,omitempty,omitzero"`

	// ClarificationRequest Request for clarification from the user
	ClarificationRequest ClarificationRequest `json:"clarification_request,omitempty,omitzero"`

	// Classification Query classification and transformation result combining all query enhancements including strategy selection and semantic optimization
	Classification ClassificationTransformationResult `json:"classification,omitempty,omitzero"`

	// ContextRelevance Relevance of retrieved documents to the query (requires steps.confidence)
	ContextRelevance float32 `json:"context_relevance,omitempty,omitzero"`

	// EvalResult Complete evaluation result
	EvalResult EvalResult `json:"eval_result,omitempty,omitzero"`

	// FollowupQuestions Suggested follow-up questions (requires steps.followup)
	FollowupQuestions []string `json:"followup_questions,omitempty,omitzero"`

	// Generation Generated response in markdown format. Present when steps.generation
	// was configured.
	Generation string `json:"generation,omitempty,omitzero"`

	// GenerationConfidence Confidence in the generated response (requires steps.confidence)
	GenerationConfidence float32 `json:"generation_confidence,omitempty,omitzero"`

	// Hits Retrieved query hits
	Hits []QueryHit `json:"hits"`

	// Messages Conversation messages including tool calls and responses.
	// Can be passed back in subsequent requests for multi-turn interaction.
	Messages []ChatMessage `json:"messages,omitempty,omitzero"`

	// ReasoningChain Steps taken during retrieval (tool calls, actions)
	ReasoningChain []RetrievalReasoningStep `json:"reasoning_chain,omitempty,omitzero"`

	// State Current state of the retrieval agent:
	// - tool_calling: Agent is actively calling tools to find documents
	// - complete: Retrieval finished
	// - awaiting_clarification: Paused waiting for user input
	State RetrievalAgentState `json:"state"`

	// StrategyUsed Strategy for document retrieval:
	// - semantic: Vector similarity search using embeddings
	// - bm25: Full-text search using BM25 scoring
	// - metadata: Structured query on document fields
	// - tree: Iterative tree navigation with summarization
	// - graph: Relationship-based traversal
	// - hybrid: Combine multiple strategies with RRF or rerank
	StrategyUsed RetrievalStrategy `json:"strategy_used,omitempty,omitzero"`

	// ToolCallsMade Total number of tool calls made during retrieval
	ToolCallsMade int `json:"tool_calls_made,omitempty,omitzero"`
}

// RetrievalAgentState Current state of the retrieval agent:
// - tool_calling: Agent is actively calling tools to find documents
// - complete: Retrieval finished
// - awaiting_clarification: Paused waiting for user input
type RetrievalAgentState string

// RetrievalAgentSteps Configuration for the retrieval agent's pipeline steps and tool-use behavior.
// Each step can have its own generator (or chain of generators) and step-specific options.
// If a step is not configured, it is skipped (retrieval always runs).
type RetrievalAgentSteps struct {
	// Classification Configuration for the classification step. This step analyzes the query,
	// selects the optimal retrieval strategy, and generates semantic transformations.
	Classification ClassificationStepConfig `json:"classification,omitempty,omitzero"`

	// Confidence Configuration for confidence assessment. Evaluates answer quality and
	// resource relevance. Can use a model calibrated for scoring tasks.
	Confidence ConfidenceStepConfig `json:"confidence,omitempty,omitzero"`

	// Eval Configuration for inline evaluation of query results.
	// Add to RAGRequest, QueryRequest, or AnswerAgentRequest.
	Eval EvalConfig `json:"eval,omitempty,omitzero"`

	// Followup Configuration for generating follow-up questions. Uses a separate generator
	// call which can use a cheaper/faster model.
	Followup FollowupStepConfig `json:"followup,omitempty,omitzero"`

	// Generation Configuration for the generation step. This step generates the final
	// response from retrieved documents using the reasoning as context.
	Generation GenerationStepConfig `json:"generation,omitempty,omitzero"`

	// Tools Configuration for chat agent tools.
	//
	// If `enabled_tools` is empty/omitted, defaults to: add_filter, ask_clarification, search.
	//
	// For models that don't support native tool calling (e.g., Ollama),
	// a prompt-based fallback is used with structured output parsing.
	Tools ChatToolsConfig `json:"tools,omitempty,omitzero"`
}

// RetrievalQueryRequest defines model for RetrievalQueryRequest.
type RetrievalQueryRequest struct {
	// Aggregations Aggregation requests for computing metrics and bucketing results.
	// Each key is a user-defined name for the aggregation, and the value specifies the aggregation configuration.
	//
	// Supports metric aggregations (sum, avg, min, max, count, stats, cardinality),
	// bucketing aggregations (terms, range, date_range, histogram, date_histogram),
	// geo aggregations (geohash_grid, geo_distance), and analytics (significant_terms).
	//
	// Example:
	// ```json
	// {
	//   "price_stats": {
	//     "type": "stats",
	//     "field": "price"
	//   },
	//   "categories": {
	//     "type": "terms",
	//     "field": "category",
	//     "size": 10
	//   }
	// }
	// ```
	Aggregations map[string]AggregationRequest `json:"aggregations,omitempty,omitzero"`
	Analyses     *Analyses                     `json:"analyses,omitempty"`

	// Count If true, returns only the total count of matching documents without retrieving the actual documents.
	// Useful for pagination and displaying result counts.
	Count bool `json:"count,omitempty,omitzero"`

	// DistanceOver Minimum distance threshold for semantic similarity search. Results with distance
	// less than this value are excluded.
	//
	// Useful for excluding near-exact duplicates or finding dissimilar documents.
	DistanceOver *float32 `json:"distance_over,omitempty"`

	// DistanceUnder Maximum distance threshold for semantic similarity search. Results with distance
	// greater than this value are excluded. Lower distances indicate higher similarity.
	//
	// Useful for filtering out low-confidence matches.
	DistanceUnder *float32 `json:"distance_under,omitempty"`

	// DocumentRenderer Optional Handlebars template string for rendering document content in RAG queries.
	// Template has access to document fields via `{{this.fields.fieldName}}`.
	//
	// **Default**: Uses TOON (Token-Oriented Object Notation) format for 30-60% token reduction:
	// ```handlebars
	// {{encodeToon this.fields}}
	// ```
	//
	// **Available Helpers**:
	// - `encodeToon` - Renders fields in compact TOON format with configurable options:
	//   - `lengthMarker` (bool): Add # prefix to array counts (default: true)
	//   - `indent` (int): Indentation spacing (default: 2)
	//   - `delimiter` (string): Field separator for tabular arrays
	// - `scrubHtml` - Removes HTML tags and extracts text
	// - `media` - Wraps data URIs for GenKit multimodal support
	// - `eq` - Equality comparison for conditionals
	//
	// **Examples**:
	// - Basic TOON: `{{encodeToon this.fields}}`
	// - Compact TOON: `{{encodeToon this.fields lengthMarker=false indent=0}}`
	// - Tabular data: `{{encodeToon this.fields delimiter="\t"}}`
	// - Custom template: `Title: {{this.fields.title}}\nBody: {{this.fields.body}}`
	// - Traditional format: `{{#each this.fields}}{{@key}}: {{this}}\n{{/each}}`
	//
	// TOON format produces compact, LLM-optimized output like:
	// ```
	// title: Introduction to Vector Search
	// author: Jane Doe
	// tags[#3]: ai,search,ml
	// ```
	//
	// **References**:
	// - TOON Specification: https://github.com/toon-format/toon
	// - Go Implementation: https://github.com/alpkeskin/gotoon
	DocumentRenderer string `json:"document_renderer,omitempty,omitzero"`

	// EmbeddingTemplate Optional Handlebars template for multimodal embedding of the semantic_search query.
	// The template has access to `this` which contains the semantic_search string value.
	//
	// Use this when you want to embed multimodal content (images, PDFs, etc.) instead of
	// just text. The template is rendered using dotprompt with access to remote content helpers.
	//
	// **Available Helpers**:
	// - `remoteMedia url=<url>` - Fetches and embeds remote images/media
	// - `remotePDF url=<url>` - Fetches and extracts content from PDFs
	// - `remoteText url=<url>` - Fetches and includes remote text content
	//
	// **Examples**:
	// - PDF search: `{{remotePDF url=this}}`
	// - Image search: `{{remoteMedia url=this}}`
	// - Mixed: `Search for: {{this}} {{#if this}}{{remoteMedia url=this}}{{/if}}`
	//
	// When not specified, the semantic_search string is embedded as plain text.
	EmbeddingTemplate string `json:"embedding_template,omitempty,omitzero"`

	// Embeddings Pre-computed embeddings to use for semantic searches instead of embedding the semantic_search string.
	// The keys are the index names, and values are the embedding vectors.
	//
	// Use when you've already generated embeddings on the client side to avoid redundant embedding calls.
	Embeddings map[string][]float32 `json:"embeddings,omitempty,omitzero"`

	// ExclusionQuery Bleve query applied as a NOT condition. Documents matching this query are excluded
	// from results. Applied before scoring.
	//
	// See bleve-query-openapi.yaml for complete type definitions.
	//
	// Use for:
	// - Excluding drafts: `"status:draft"`
	// - Removing deprecated content: `"deprecated:true"`
	// - Filtering out archived items: `"status:archived"`
	ExclusionQuery json.RawMessage `json:"exclusion_query,omitempty,omitzero"`

	// ExpandStrategy Strategy for merging graph results with search results:
	// - union: Include nodes from both search and graph results
	// - intersection: Only include nodes appearing in both
	ExpandStrategy RetrievalQueryRequestExpandStrategy `json:"expand_strategy,omitempty,omitzero"`

	// Fields List of fields to include in the results. If not specified, all fields are returned.
	// Use to reduce response size and improve performance.
	Fields []string `json:"fields,omitempty,omitzero"`

	// FilterPrefix Filter results by key prefix. Only returns documents whose keys start with this string.
	// Applied before scoring to improve performance.
	//
	// Common use cases:
	// - Multi-tenant filtering: `"tenant:acme:"`
	// - User-specific data: `"user:123:"`
	// - Document type filtering: `"article:"`
	FilterPrefix []byte `json:"filter_prefix,omitempty,omitzero"`

	// FilterQuery Bleve query applied as an AND condition. Documents must match both the main query
	// and this filter. Applied before scoring for better performance.
	//
	// See bleve-query-openapi.yaml for complete type definitions.
	//
	// Use for:
	// - Status filtering: `"status:published"`
	// - Date ranges: `"created_at:>2023-01-01"`
	// - Category filtering: `"category:technology AND language:en"`
	FilterQuery json.RawMessage `json:"filter_query,omitempty,omitzero"`

	// ForeignSources Map of table name to foreign data source configuration for query-time federated access.
	// When a table name referenced in this query (or in a join's `right_table`) appears as a key
	// here, the query is routed to the external database instead of Antfly shards.
	//
	// This enables joining Antfly search results with structured relational data (customer records,
	// product catalogs, etc.) without ingesting that data into Antfly.
	//
	// **Supported operations on foreign tables:** filter_query, field selection, limit/offset.
	// **Not supported:** full_text_search, semantic_search, graph_searches, aggregations, reranker.
	//
	// **Example - Join Antfly products with Postgres customers:**
	// ```json
	// {
	//   "table": "products",
	//   "full_text_search": {"query": "category:electronics"},
	//   "join": {
	//     "right_table": "pg_customers",
	//     "on": {"left_field": "customer_id", "right_field": "id"}
	//   },
	//   "foreign_sources": {
	//     "pg_customers": {
	//       "type": "postgres",
	//       "dsn": "${secret:pg_dsn}",
	//       "postgres_table": "customers"
	//     }
	//   }
	// }
	// ```
	ForeignSources map[string]ForeignSource `json:"foreign_sources,omitempty,omitzero"`

	// FullTextSearch Bleve query for full-text search. Supports all Bleve query types.
	//
	// See bleve-query-openapi.yaml for complete type definitions.
	//
	// Examples:
	// - Simple: `{"query": "computer"}`
	// - Field-specific: `{"query": "body:computer"}`
	// - Boolean: `{"query": "artificial AND intelligence"}`
	// - Range: `{"query": "year:>2020"}`
	// - Phrase: `{"query": "\"exact phrase\""}`
	FullTextSearch json.RawMessage `json:"full_text_search,omitempty,omitzero"`

	// GraphSearches Declarative graph queries to execute after full-text/vector searches.
	// Results can reference search results using node selectors like $full_text_results.
	GraphSearches map[string]GraphQuery `json:"graph_searches,omitempty,omitzero"`

	// Indexes List of vector index names to use for semantic search. Required when using semantic_search.
	// Multiple indexes can be specified, and their results will be merged using RRF.
	Indexes []string `json:"indexes,omitempty,omitzero"`

	// Join Configuration for joining data from another table.
	// Supports inner, left, and right joins with automatic strategy selection.
	Join JoinClause `json:"join,omitempty,omitzero"`

	// Limit Maximum number of results to return. For semantic_search, this is the topk parameter.
	// Default varies by query type (typically 10).
	Limit int `json:"limit,omitempty,omitzero"`

	// MergeStrategy Merge strategy for combining results from the semantic_search and full_text_search.
	// rrf: Reciprocal Rank Fusion - combines scores using reciprocal rank formula
	// rsf: Relative Score Fusion - normalizes scores by min/max within a window and combines weighted scores
	// failover: Use full_text_search if embedding generation fails
	MergeStrategy MergeStrategy `json:"merge_strategy,omitempty,omitzero"`

	// Offset Number of results to skip for pagination. Only available for full_text_search queries.
	// Not supported for semantic_search due to vector index limitations.
	Offset int `json:"offset,omitempty,omitzero"`

	// OrderBy Sort order for results. Map of field names to boolean (true = descending, false = ascending).
	// Only applicable for full_text_search queries. Semantic searches are always sorted by similarity score.
	OrderBy map[string]bool `json:"order_by,omitempty,omitzero"`

	// Pruner Configuration for pruning search results based on score quality.
	// Helps filter out low-relevance results in RAG pipelines by detecting
	// score gaps or deviations from top results.
	Pruner Pruner `json:"pruner,omitempty,omitzero"`

	// Reranker A unified configuration for a reranking provider.
	Reranker *RerankerConfig `json:"reranker,omitempty"`

	// SemanticSearch Natural language query for vector similarity search. Results are ranked by semantic similarity
	// to the query and can be combined with full_text_search using Reciprocal Rank Fusion (RRF).
	//
	// The semantic_search string is automatically embedded using the configured embedding model
	// for the specified indexes. Use `embedding_template` for multimodal queries.
	SemanticSearch string `json:"semantic_search,omitempty,omitzero"`

	// Table Name of the table to query. Optional for global queries.
	Table string `json:"table,omitempty,omitzero"`

	// TreeSearch Configuration for tree search strategy. Tree search navigates hierarchical
	// document structures by evaluating summaries at each level.
	TreeSearch TreeSearchConfig `json:"tree_search,omitempty,omitzero"`
}

// RetrievalQueryRequestExpandStrategy Strategy for merging graph results with search results:
// - union: Include nodes from both search and graph results
// - intersection: Only include nodes appearing in both
type RetrievalQueryRequestExpandStrategy string

// RetrievalReasoningStep A step in the retrieval reasoning chain
type RetrievalReasoningStep struct {
	// Action What action was taken
	Action string `json:"action"`

	// Details Additional details about the step (e.g., tool arguments, result count)
	Details map[string]interface{} `json:"details,omitempty,omitzero"`

	// Step Name of the tool call or action taken
	Step string `json:"step"`
}

// RetrievalStrategy Strategy for document retrieval:
// - semantic: Vector similarity search using embeddings
// - bm25: Full-text search using BM25 scoring
// - metadata: Structured query on document fields
// - tree: Iterative tree navigation with summarization
// - graph: Relationship-based traversal
// - hybrid: Combine multiple strategies with RRF or rerank
type RetrievalStrategy string

// RetryConfig Retry configuration for generator calls
type RetryConfig struct {
	// BackoffMultiplier Multiplier for exponential backoff
	BackoffMultiplier float32 `json:"backoff_multiplier,omitempty,omitzero"`

	// InitialBackoffMs Initial backoff delay in milliseconds
	InitialBackoffMs int `json:"initial_backoff_ms,omitempty,omitzero"`

	// MaxAttempts Maximum number of retry attempts
	MaxAttempts int `json:"max_attempts,omitempty,omitzero"`

	// MaxBackoffMs Maximum backoff delay in milliseconds
	MaxBackoffMs int `json:"max_backoff_ms,omitempty,omitzero"`
}

// RouteType Classification of query type: question (specific factual query) or search (exploratory query)
type RouteType string

// ScanKeysRequest Request to scan keys in a table within a key range.
// If no range is specified, scans all keys in the table.
type ScanKeysRequest struct {
	// ExclusiveTo If true, exclude keys matching 'to' from the results.
	// Default: false (inclusive upper bound).
	ExclusiveTo bool `json:"exclusive_to,omitempty,omitzero"`

	// Fields List of fields to include in each result. If not specified,
	// only returns the key. Supports:
	// - Simple fields: "title", "author"
	// - Nested paths: "user.address.city"
	// - Wildcards: "_chunks.*"
	// - Exclusions: "-_chunks.*._embedding"
	// - Special fields: "_embeddings", "_summaries", "_chunks"
	Fields []string `json:"fields,omitempty,omitzero"`

	// FilterQuery Bleve query to filter documents. Only documents matching this query
	// are included in results. Uses the sear library for efficient per-document
	// matching without requiring a full index.
	//
	// Examples:
	// - Status filtering: `{"query": "status:published"}`
	// - Date ranges: `{"query": "created_at:>2023-01-01"}`
	// - Field matching: `{"query": "category:technology"}`
	FilterQuery json.RawMessage `json:"filter_query,omitempty,omitzero"`

	// From Start of the key range to scan (exclusive by default).
	// Can be a full key or a prefix. If not specified, starts from
	// the beginning of the table.
	From string `json:"from,omitempty,omitzero"`

	// InclusiveFrom If true, include keys matching 'from' in the results.
	// Default: false (exclusive lower bound for pagination).
	InclusiveFrom bool `json:"inclusive_from,omitempty,omitzero"`

	// Limit Maximum number of results to return. If not specified, returns all
	// matching keys in the range. Useful for pagination or sampling.
	Limit int `json:"limit,omitempty,omitzero"`

	// To End of the key range to scan (inclusive by default).
	// Can be a full key or a prefix. If not specified, scans to
	// the end of the table.
	To string `json:"to,omitempty,omitzero"`
}

// SemanticQueryMode Mode for semantic query generation:
// - rewrite: Transform query into expanded keywords/concepts optimized for vector search (Level 2 optimization)
// - hypothetical: Generate a hypothetical answer that would appear in relevant documents (HyDE - Level 3 optimization)
type SemanticQueryMode string

// SerperSearchConfig defines model for SerperSearchConfig.
type SerperSearchConfig struct {
	// ApiKey Serper API key (or set SERPER_API_KEY env var)
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// Language Preferred language for results (e.g., 'en', 'es', 'fr')
	Language string `json:"language,omitempty,omitzero"`

	// MaxResults Maximum number of search results to return
	MaxResults int `json:"max_results,omitempty,omitzero"`

	// Provider The web search provider to use.
	//
	// - **google**: Google Custom Search API (requires CSE setup)
	// - **bing**: Microsoft Bing Web Search API
	// - **serper**: Serper.dev Google Search API (simpler setup)
	// - **tavily**: Tavily AI Search API (optimized for RAG)
	// - **brave**: Brave Search API
	// - **duckduckgo**: DuckDuckGo Instant Answer API (limited, no API key)
	Provider WebSearchProvider `json:"provider"`

	// Region Preferred region for results (e.g., 'us', 'uk', 'de')
	Region string `json:"region,omitempty,omitzero"`

	// SafeSearch Enable safe search filtering
	SafeSearch *bool `json:"safe_search,omitempty"`

	// SearchType Type of search to perform
	SearchType SerperSearchConfigSearchType `json:"search_type,omitempty,omitzero"`

	// TimePeriod Time period filter: d=day, w=week, m=month, y=year
	TimePeriod SerperSearchConfigTimePeriod `json:"time_period,omitempty,omitzero"`

	// TimeoutMs Request timeout in milliseconds
	TimeoutMs int `json:"timeout_ms,omitempty,omitzero"`
}

// SerperSearchConfigSearchType Type of search to perform
type SerperSearchConfigSearchType string

// SerperSearchConfigTimePeriod Time period filter: d=day, w=week, m=month, y=year
type SerperSearchConfigTimePeriod string

// ShardConfig defines model for ShardConfig.
type ShardConfig struct {
	ByteRange ByteRange `json:"byte_range"`
}

// SignificanceAlgorithm Algorithm for computing term significance:
// - jlh: JLH algorithm (default)
// - mutual_information: Mutual Information
// - chi_squared: Chi-squared test
// - percentage: Simple percentage comparison
type SignificanceAlgorithm string

// StorageStatus defines model for StorageStatus.
type StorageStatus struct {
	// DiskUsage Disk usage in bytes.
	DiskUsage uint64 `json:"disk_usage,omitempty,omitzero"`

	// Empty Whether the table has received data.
	Empty bool `json:"empty,omitempty,omitzero"`
}

// SuccessMessage defines model for SuccessMessage.
type SuccessMessage struct {
	Message string `json:"message,omitempty,omitzero"`
}

// SyncLevel Synchronization level for batch operations:
// - "propose": Wait for Raft proposal acceptance (fastest, default)
// - "write": Wait for Pebble KV write
// - "full_text": Wait for full-text index WAL write
// - "enrichments": Pre-compute enrichments before Raft proposal (synchronous enrichment generation)
// - "aknn": Wait for vector index write with best-effort synchronous embedding (falls back to async on timeout, slowest, most durable)
type SyncLevel string

// Table defines model for Table.
type Table struct {
	// Description Optional description of the table.
	Description string                 `json:"description,omitempty,omitzero"`
	Indexes     map[string]IndexConfig `json:"indexes"`
	Name        string                 `json:"name"`

	// Schema Schema definition for a table with multiple document types
	Schema TableSchema            `json:"schema,omitempty,omitzero"`
	Shards map[string]ShardConfig `json:"shards"`
}

// TableBackupStatus defines model for TableBackupStatus.
type TableBackupStatus struct {
	// Error Error message if backup failed
	Error string `json:"error,omitempty,omitzero"`

	// Name Table name
	Name string `json:"name"`

	// Status Backup status for this table
	Status TableBackupStatusStatus `json:"status"`
}

// TableBackupStatusStatus Backup status for this table
type TableBackupStatusStatus string

// TableRestoreStatus defines model for TableRestoreStatus.
type TableRestoreStatus struct {
	// Error Error message if restore failed
	Error string `json:"error,omitempty,omitzero"`

	// Name Table name
	Name string `json:"name"`

	// Status Restore status for this table
	Status TableRestoreStatusStatus `json:"status"`
}

// TableRestoreStatusStatus Restore status for this table
type TableRestoreStatusStatus string

// TableSchema Schema definition for a table with multiple document types
type TableSchema struct {
	// DefaultType Default type to use from the document_types.
	DefaultType string `json:"default_type,omitempty,omitzero"`

	// DocumentSchemas A map of type names to their document json schemas.
	DocumentSchemas map[string]DocumentSchema `json:"document_schemas,omitempty,omitzero"`

	// DynamicTemplates Rules for mapping dynamically detected fields. When a document contains fields
	// that don't have explicit mappings and dynamic mapping is enabled, templates are
	// evaluated in order to determine how those fields should be indexed.
	DynamicTemplates []DynamicTemplate `json:"dynamic_templates,omitempty,omitzero"`

	// EnforceTypes Whether to enforce that documents must match one of the provided document types.
	// If false, documents not matching any type will be accepted but not indexed.
	EnforceTypes bool `json:"enforce_types,omitempty,omitzero"`

	// TtlDuration The duration after which documents should expire, based on the ttl_field timestamp (optional).
	// Uses Go duration format (e.g., '24h', '7d', '168h').
	TtlDuration string `json:"ttl_duration,omitempty,omitzero"`

	// TtlField The field containing the timestamp for TTL expiration (optional).
	// Defaults to "_timestamp" if ttl_duration is specified but ttl_field is not.
	TtlField string `json:"ttl_field,omitempty,omitzero"`

	// Version Version of the schema. Used for migrations.
	Version uint32 `json:"version,omitempty,omitzero"`
}

// TableStatistics Statistics about a table used for query planning.
type TableStatistics struct {
	// FieldStats Per-field statistics for query optimization.
	FieldStats map[string]FieldStatistics `json:"field_stats,omitempty,omitzero"`

	// LastUpdated When these statistics were last computed.
	LastUpdated time.Time `json:"last_updated,omitempty,omitzero"`

	// RowCount Approximate number of rows in the table.
	RowCount int64 `json:"row_count,omitempty,omitzero"`

	// SizeBytes Approximate size of the table in bytes.
	SizeBytes int64 `json:"size_bytes,omitempty,omitzero"`
}

// TableStatus defines model for TableStatus.
type TableStatus struct {
	// Description Optional description of the table.
	Description string                 `json:"description,omitempty,omitzero"`
	Indexes     map[string]IndexConfig `json:"indexes"`
	Name        string                 `json:"name"`

	// Schema Schema definition for a table with multiple document types
	Schema        TableSchema            `json:"schema,omitempty,omitzero"`
	Shards        map[string]ShardConfig `json:"shards"`
	StorageStatus StorageStatus          `json:"storage_status"`
}

// TavilySearchConfig defines model for TavilySearchConfig.
type TavilySearchConfig struct {
	// ApiKey Tavily API key (or set TAVILY_API_KEY env var)
	ApiKey string `json:"api_key,omitempty,omitzero"`

	// ExcludeDomains Exclude results from these domains
	ExcludeDomains []string `json:"exclude_domains,omitempty,omitzero"`

	// IncludeAnswer Include AI-generated answer summary
	IncludeAnswer bool `json:"include_answer,omitempty,omitzero"`

	// IncludeDomains Only include results from these domains
	IncludeDomains []string `json:"include_domains,omitempty,omitzero"`

	// IncludeRawContent Include raw HTML content of pages
	IncludeRawContent bool `json:"include_raw_content,omitempty,omitzero"`

	// Language Preferred language for results (e.g., 'en', 'es', 'fr')
	Language string `json:"language,omitempty,omitzero"`

	// MaxResults Maximum number of search results to return
	MaxResults int `json:"max_results,omitempty,omitzero"`

	// Provider The web search provider to use.
	//
	// - **google**: Google Custom Search API (requires CSE setup)
	// - **bing**: Microsoft Bing Web Search API
	// - **serper**: Serper.dev Google Search API (simpler setup)
	// - **tavily**: Tavily AI Search API (optimized for RAG)
	// - **brave**: Brave Search API
	// - **duckduckgo**: DuckDuckGo Instant Answer API (limited, no API key)
	Provider WebSearchProvider `json:"provider"`

	// Region Preferred region for results (e.g., 'us', 'uk', 'de')
	Region string `json:"region,omitempty,omitzero"`

	// SafeSearch Enable safe search filtering
	SafeSearch *bool `json:"safe_search,omitempty"`

	// SearchDepth Search depth:
	// - basic: Fast search with standard results
	// - advanced: Deeper search with more comprehensive results
	SearchDepth TavilySearchConfigSearchDepth `json:"search_depth,omitempty,omitzero"`

	// TimeoutMs Request timeout in milliseconds
	TimeoutMs int `json:"timeout_ms,omitempty,omitzero"`
}

// TavilySearchConfigSearchDepth Search depth:
// - basic: Fast search with standard results
// - advanced: Deeper search with more comprehensive results
type TavilySearchConfigSearchDepth string

// TemplateFieldMapping Field mapping to apply when a dynamic template matches
type TemplateFieldMapping struct {
	// Analyzer Analyzer name (e.g., "standard", "keyword", "en", "html_analyzer").
	// Used for text fields to control tokenization and normalization.
	Analyzer string `json:"analyzer,omitempty,omitzero"`

	// DocValues Whether to enable doc values for sorting/faceting
	DocValues bool `json:"doc_values,omitempty,omitzero"`

	// IncludeInAll Whether to include in the _all field for cross-field search
	IncludeInAll bool `json:"include_in_all,omitempty,omitzero"`

	// Index Whether to index the field (default true)
	Index bool `json:"index,omitempty,omitzero"`

	// Store Whether to store the field value (default false)
	Store bool `json:"store,omitempty,omitzero"`

	// Type Field type annotations for schema fields
	Type SchemasAntflyType `json:"type,omitempty,omitzero"`
}

// TermQuery defines model for TermQuery.
type TermQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost Boost  `json:"boost,omitzero"`
	Field string `json:"field,omitempty,omitzero"`
	Term  string `json:"term"`
}

// TermRangeQuery defines model for TermRangeQuery.
type TermRangeQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost        Boost  `json:"boost,omitzero"`
	Field        string `json:"field,omitempty,omitzero"`
	InclusiveMax bool   `json:"inclusive_max,omitzero"`
	InclusiveMin bool   `json:"inclusive_min,omitzero"`
	Max          string `json:"max,omitzero"`
	Min          string `json:"min,omitzero"`
}

// TermiteChunkerConfig defines model for TermiteChunkerConfig.
type TermiteChunkerConfig struct {
	// ApiUrl The URL of the Termite API endpoint (e.g., 'http://localhost:8080'). Can also be set via ANTFLY_TERMITE_URL environment variable.
	ApiUrl string `json:"api_url,omitempty,omitzero"`

	// MaxChunks Maximum number of chunks to generate per document.
	MaxChunks int `json:"max_chunks,omitempty,omitzero"`

	// Model The chunking model to use. Either 'fixed' for simple token-based chunking, or a model name from models/chunkers/{name}/.
	Model string `json:"model"`

	// OverlapDurationMs Overlap duration in milliseconds between audio chunks (default: 0).
	OverlapDurationMs int `json:"overlap_duration_ms,omitempty,omitzero"`

	// OverlapTokens Number of tokens to overlap between consecutive chunks. Helps maintain context across chunk boundaries. Only used by fixed-size chunkers.
	OverlapTokens int `json:"overlap_tokens,omitempty,omitzero"`

	// Separator Separator string for splitting (e.g., '\n\n' for paragraphs). Only used by fixed-size chunkers.
	Separator string `json:"separator,omitempty,omitzero"`

	// TargetTokens Target number of tokens per chunk.
	TargetTokens int `json:"target_tokens,omitempty,omitzero"`

	// Threshold Minimum confidence threshold for separator detection (0.0-1.0). Only used by ONNX models.
	Threshold float32 `json:"threshold,omitempty,omitzero"`

	// WindowDurationMs Window duration in milliseconds for audio chunking (default: 30000).
	WindowDurationMs int `json:"window_duration_ms,omitempty,omitzero"`
}

// TermiteEmbedderConfig Configuration for the Termite embedding provider.
//
// Termite is Antfly's built-in ML service for local embeddings using ONNX models.
// It provides embedding generation with multi-tier caching (memory + persistent).
//
// **Features:**
// - Local ONNX-based embedding generation
// - L1 memory cache with configurable TTL
// - L2 persistent Pebble database cache
// - Singleflight deduplication for concurrent identical requests
//
// **Example Models:** bge-base-en-v1.5 (768 dims), all-MiniLM-L6-v2 (384 dims)
//
// Models are loaded from the `models/embedders/{name}/` directory.
type TermiteEmbedderConfig struct {
	// ApiUrl The URL of the Termite API endpoint. Can also be set via ANTFLY_TERMITE_URL environment variable.
	ApiUrl string `json:"api_url,omitempty,omitzero"`

	// Model The embedding model name (maps to models/embedders/{name}/ directory).
	Model string `json:"model"`
}

// TermiteGeneratorConfig Configuration for the Termite generative AI provider.
//
// Termite is Antfly's built-in ML service for local LLM inference using
// ONNX Runtime GenAI models. It provides text generation with automatic
// model discovery from the `models/generators/` directory.
//
// **Example Models:** onnxruntime/Gemma-3-ONNX (from HuggingFace)
//
// **Features:**
// - Local inference with no external API dependencies
// - ONNX Runtime GenAI for efficient CPU/GPU execution
// - Auto-discovery of models from `models/generators/` directory
// - OpenAI-compatible chat format
type TermiteGeneratorConfig struct {
	// ApiUrl The URL of the Termite API endpoint.
	ApiUrl string `json:"api_url,omitempty,omitzero"`

	// MaxTokens Maximum number of tokens to generate.
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Model The name of the generator model (maps to models/generators/{name}/ directory).
	Model string `json:"model"`

	// Temperature Controls randomness in generation (0.0-2.0).
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// TopK Top-k sampling parameter.
	TopK int `json:"top_k,omitempty,omitzero"`

	// TopP Nucleus sampling parameter.
	TopP float32 `json:"top_p,omitempty,omitzero"`
}

// TermiteRerankerConfig Configuration for the Termite reranking provider.
type TermiteRerankerConfig struct {
	// Model The name of the reranking model (e.g., cross-encoder model name).
	Model string `json:"model"`

	// Url The URL of the Termite API endpoint.
	Url string `json:"url,omitempty,omitzero"`
}

// TransactionCommitRequest Stateless OCC (Optimistic Concurrency Control) transaction commit request.
//
// The client reads documents (capturing version tokens from the X-Antfly-Version
// response header on lookups), computes writes locally, then submits everything
// in this single commit request. The server validates that all read versions
// still match before executing writes atomically via 2PC.
//
// **No server-side state**: There is no "begin" endpoint. The client manages
// its own read set and submits the full transaction in one request.
type TransactionCommitRequest struct {
	// ReadSet Set of keys that were read during the transaction, with their observed versions.
	// The server verifies these versions still match before committing writes.
	ReadSet []TransactionReadItem `json:"read_set"`

	// SyncLevel Synchronization level for batch operations:
	// - "propose": Wait for Raft proposal acceptance (fastest, default)
	// - "write": Wait for Pebble KV write
	// - "full_text": Wait for full-text index WAL write
	// - "enrichments": Pre-compute enrichments before Raft proposal (synchronous enrichment generation)
	// - "aknn": Wait for vector index write with best-effort synchronous embedding (falls back to async on timeout, slowest, most durable)
	SyncLevel SyncLevel `json:"sync_level,omitempty,omitzero"`

	// Tables Write set: map of table names to batch operations, same format as MultiBatchRequest.tables.
	Tables map[string]BatchRequest `json:"tables"`
}

// TransactionCommitResponse Result of an OCC transaction commit attempt.
type TransactionCommitResponse struct {
	// Conflict Details about the conflict that caused an abort (only present when status is "aborted")
	Conflict struct {
		// Key Key that had a version mismatch
		Key string `json:"key,omitempty,omitzero"`

		// Message Human-readable conflict description
		Message string `json:"message,omitempty,omitzero"`

		// Table Table where the conflict was detected
		Table string `json:"table,omitempty,omitzero"`
	} `json:"conflict,omitempty,omitzero"`

	// Status Whether the transaction was committed or aborted due to a conflict
	Status TransactionCommitResponseStatus `json:"status"`

	// Tables Per-table batch results (only present when status is "committed")
	Tables map[string]BatchResponse `json:"tables,omitempty,omitzero"`
}

// TransactionCommitResponseStatus Whether the transaction was committed or aborted due to a conflict
type TransactionCommitResponseStatus string

// TransactionReadItem A key that was read as part of an OCC transaction, along with the version
// observed at read time. Used to detect conflicts at commit time.
type TransactionReadItem struct {
	// Key Document key that was read
	Key string `json:"key"`

	// Table Table name the key belongs to
	Table string `json:"table"`

	// Version Version token observed at read time (from X-Antfly-Version header).
	// Use "0" to assert the key did not exist at read time.
	Version string `json:"version"`
}

// Transform In-place document transformation using MongoDB-style operators. Transforms are applied atomically
// at the storage layer, eliminating read-modify-write races.
//
// **Important:** Transform results are NOT validated against the table schema. This improves performance
// but means it's possible to create invalid documents. Use with care and ensure your operations maintain
// schema compliance.
type Transform struct {
	// Key Document key (must be a string, not an object like inserts)
	Key string `json:"key"`

	// Operations List of operations to apply in sequence
	Operations []TransformOp `json:"operations"`

	// Upsert If true, create document if it doesn't exist (like MongoDB upsert)
	Upsert bool `json:"upsert,omitempty,omitzero"`
}

// TransformOp defines model for TransformOp.
type TransformOp struct {
	// Op MongoDB-style update operator
	Op TransformOpType `json:"op"`

	// Path JSONPath to field (e.g., "$.user.name", "$.tags", or "user.name")
	Path string `json:"path"`

	// Value Value for operation (not required for $unset, $currentDate). Type depends on operator (number for $inc/$mul, any for $set, etc.)
	Value interface{} `json:"value,omitempty,omitzero"`
}

// TransformOpType MongoDB-style update operator
type TransformOpType string

// TraversalResult A single result from graph traversal
type TraversalResult struct {
	// Depth Distance from start node (0 = start node)
	Depth int `json:"depth"`

	// Document Document data (if loaded)
	Document map[string]interface{} `json:"document,omitempty,omitzero"`

	// Key Base64-encoded document key
	Key []byte `json:"key"`

	// Path Sequence of keys from start to this node (if include_paths=true)
	Path [][]byte `json:"path,omitempty,omitzero"`

	// PathEdges Sequence of edges from start to this node (if include_paths=true)
	PathEdges []Edge `json:"path_edges,omitempty,omitzero"`

	// TotalWeight Product of edge weights along the path
	TotalWeight float64 `json:"total_weight,omitempty,omitzero"`
}

// TraversalRules Rules for graph traversal
type TraversalRules struct {
	// DeduplicateNodes Visit each node only once
	DeduplicateNodes bool `json:"deduplicate_nodes,omitempty,omitzero"`

	// Direction Direction of edges to query:
	// - out: Outgoing edges from the node
	// - in: Incoming edges to the node
	// - both: Both outgoing and incoming edges
	Direction EdgeDirection `json:"direction,omitempty,omitzero"`

	// EdgeTypes Filter edges by type (empty = all types)
	EdgeTypes []string `json:"edge_types,omitempty,omitzero"`

	// IncludePaths Include path information in results
	IncludePaths bool `json:"include_paths,omitempty,omitzero"`

	// MaxDepth Maximum traversal depth (0 = unlimited)
	MaxDepth int `json:"max_depth,omitempty,omitzero"`

	// MaxResults Maximum results to return (0 = unlimited)
	MaxResults int `json:"max_results,omitempty,omitzero"`

	// MaxWeight Maximum edge weight filter
	MaxWeight float64 `json:"max_weight,omitempty,omitzero"`

	// MinWeight Minimum edge weight filter
	MinWeight float64 `json:"min_weight,omitempty,omitzero"`
}

// TraverseResponse defines model for TraverseResponse.
type TraverseResponse struct {
	// Count Total number of results
	Count   int               `json:"count,omitempty,omitzero"`
	Results []TraversalResult `json:"results,omitempty,omitzero"`
}

// TreeSearchConfig Configuration for tree search strategy. Tree search navigates hierarchical
// document structures by evaluating summaries at each level.
type TreeSearchConfig struct {
	// BeamWidth Number of branches to explore at each level
	BeamWidth int `json:"beam_width,omitempty,omitzero"`

	// Index Name of the graph index to use for tree navigation
	Index string `json:"index"`

	// MaxDepth Maximum depth to traverse in the tree
	MaxDepth int `json:"max_depth,omitempty,omitzero"`

	// StartNodes Starting nodes for tree search:
	// - "$roots" - Query for root nodes (nodes with no parents)
	// - Comma-separated explicit node IDs
	// When omitted and combined with a QueryRequest in a RetrievalQueryRequest,
	// the query results are used as start nodes.
	StartNodes string `json:"start_nodes,omitempty,omitzero"`
}

// UpdatePasswordRequest defines model for UpdatePasswordRequest.
type UpdatePasswordRequest struct {
	NewPassword string `json:"new_password"`
}

// User defines model for User.
type User struct {
	// PasswordHash Base64 encoded password hash. Exposing this is a security risk.
	PasswordHash []byte `json:"password_hash"`
	Username     string `json:"username"`
}

// VertexEmbedderConfig Configuration for Google Cloud Vertex AI embedding models (enterprise-grade).
//
// Uses Application Default Credentials (ADC) for authentication. Requires IAM role `roles/aiplatform.user`.
//
// **Example Models:** gemini-embedding-001 (default, 3072 dims), multimodalembedding (images/audio/video)
//
// **Docs:** https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-text-embeddings
type VertexEmbedderConfig struct {
	// CredentialsPath Path to service account JSON key file. Alternative to ADC for non-GCP environments.
	CredentialsPath string `json:"credentials_path,omitempty,omitzero"`

	// Dimension The dimension of the embedding vector (768, 1536, or 3072 for gemini-embedding-001; 128-1408 for multimodalembedding).
	Dimension int `json:"dimension,omitempty,omitzero"`

	// Location Google Cloud region for Vertex AI API (e.g., 'us-central1', 'europe-west1'). Can also be set via GOOGLE_CLOUD_LOCATION. Defaults to 'us-central1'.
	Location string `json:"location,omitempty,omitzero"`

	// Model The name of the Vertex AI embedding model to use.
	Model string `json:"model"`

	// ProjectId Google Cloud project ID. Can also be set via GOOGLE_CLOUD_PROJECT environment variable.
	ProjectId string `json:"project_id,omitempty,omitzero"`
}

// VertexGeneratorConfig Configuration for Google Cloud Vertex AI generative models (enterprise-grade).
//
// Uses Application Default Credentials (ADC) for authentication. In GCP environments
// (Cloud Run, GKE, Compute Engine) this is automatic. For local dev, run
// `gcloud auth application-default login`. Requires IAM role `roles/aiplatform.user`.
//
// **Example Models:** gemini-2.5-flash (default), gemini-2.5-pro, gemini-3.0-pro
//
// **Docs:** https://cloud.google.com/vertex-ai/generative-ai/docs/learn/models
type VertexGeneratorConfig struct {
	// CredentialsPath Path to service account JSON key file. Sets GOOGLE_APPLICATION_CREDENTIALS environment variable. Alternative to ADC for non-GCP environments.
	CredentialsPath string `json:"credentials_path,omitempty,omitzero"`

	// Location Google Cloud region for Vertex AI API (e.g., 'us-central1', 'europe-west1'). Can also be set via GOOGLE_CLOUD_LOCATION. Defaults to 'us-central1'.
	Location string `json:"location,omitempty,omitzero"`

	// MaxTokens Maximum number of tokens to generate in the response.
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Model The name of the Vertex AI model to use.
	Model string `json:"model"`

	// ProjectId Google Cloud project ID. Can also be set via GOOGLE_CLOUD_PROJECT environment variable.
	ProjectId string `json:"project_id,omitempty,omitzero"`

	// Temperature Controls randomness in generation (0.0-2.0). Higher values make output more random.
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// TopK Top-k sampling parameter. Only sample from the top K options for each subsequent token.
	TopK int `json:"top_k,omitempty,omitzero"`

	// TopP Nucleus sampling parameter (0.0-1.0). Alternative to temperature.
	TopP float32 `json:"top_p,omitempty,omitzero"`
}

// VertexRerankerConfig Configuration for the Google Vertex AI Ranking API.
//
// Uses Application Default Credentials (ADC) or explicit credentials path.
//
// **Prerequisites:**
// - Enable Discovery Engine API: `gcloud services enable discoveryengine.googleapis.com`
// - Grant IAM role: `roles/discoveryengine.admin` (includes `discoveryengine.rankingConfigs.rank` permission)
//
// **Models:** semantic-ranker-default@latest (default), semantic-ranker-fast-004
//
// **Docs:** https://cloud.google.com/generative-ai-app-builder/docs/ranking
//
// **IAM:** https://cloud.google.com/generative-ai-app-builder/docs/access-control
type VertexRerankerConfig struct {
	// CredentialsPath Path to service account JSON file. Falls back to GOOGLE_APPLICATION_CREDENTIALS environment variable.
	CredentialsPath string `json:"credentials_path,omitempty,omitzero"`

	// Model The ranking model to use.
	Model string `json:"model"`

	// ProjectId Google Cloud project ID. Falls back to GOOGLE_CLOUD_PROJECT environment variable.
	ProjectId string `json:"project_id,omitempty,omitzero"`

	// TopN Maximum number of records to return. If not specified, returns all documents with scores.
	TopN int `json:"top_n,omitempty,omitzero"`
}

// WebSearchConfig A unified configuration for web search providers.
//
// Each provider has specific configuration requirements. Use the appropriate
// provider-specific config or set common options at the top level.
//
// **Environment Variables (fallbacks):**
// - GOOGLE_CSE_API_KEY, GOOGLE_CSE_ID
// - BING_SEARCH_API_KEY
// - SERPER_API_KEY
// - TAVILY_API_KEY
// - BRAVE_API_KEY
type WebSearchConfig struct {
	// Language Preferred language for results (e.g., 'en', 'es', 'fr')
	Language string `json:"language,omitempty,omitzero"`

	// MaxResults Maximum number of search results to return
	MaxResults int `json:"max_results,omitempty,omitzero"`

	// Provider The web search provider to use.
	//
	// - **google**: Google Custom Search API (requires CSE setup)
	// - **bing**: Microsoft Bing Web Search API
	// - **serper**: Serper.dev Google Search API (simpler setup)
	// - **tavily**: Tavily AI Search API (optimized for RAG)
	// - **brave**: Brave Search API
	// - **duckduckgo**: DuckDuckGo Instant Answer API (limited, no API key)
	Provider WebSearchProvider `json:"provider"`

	// Region Preferred region for results (e.g., 'us', 'uk', 'de')
	Region string `json:"region,omitempty,omitzero"`

	// SafeSearch Enable safe search filtering
	SafeSearch *bool `json:"safe_search,omitempty"`

	// TimeoutMs Request timeout in milliseconds
	TimeoutMs int `json:"timeout_ms,omitempty,omitzero"`
}

// WebSearchProvider The web search provider to use.
//
// - **google**: Google Custom Search API (requires CSE setup)
// - **bing**: Microsoft Bing Web Search API
// - **serper**: Serper.dev Google Search API (simpler setup)
// - **tavily**: Tavily AI Search API (optimized for RAG)
// - **brave**: Brave Search API
// - **duckduckgo**: DuckDuckGo Instant Answer API (limited, no API key)
type WebSearchProvider string

// WildcardQuery defines model for WildcardQuery.
type WildcardQuery struct {
	// Boost A floating-point number used to decrease or increase the relevance scores of a query.
	Boost    Boost  `json:"boost,omitzero"`
	Field    string `json:"field,omitempty,omitzero"`
	Wildcard string `json:"wildcard"`
}

// SchemasAntflyType Field type annotations for schema fields
type SchemasAntflyType string

// UserNamePathParameter defines model for UserNamePathParameter.
type UserNamePathParameter = string

// BadRequest defines model for BadRequest.
type BadRequest = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// ListBackupsParams defines parameters for ListBackups.
type ListBackupsParams struct {
	// Location Storage location to search for backups.
	// - Local filesystem: `file:///path/to/backup`
	// - Amazon S3: `s3://bucket-name/path/to/backup`
	Location string `form:"location" json:"location"`
}

// ListTablesParams defines parameters for ListTables.
type ListTablesParams struct {
	// Prefix Filter tables by name prefix (e.g., "prod_")
	Prefix string `form:"prefix,omitempty" json:"prefix,omitempty,omitzero"`

	// Pattern Filter tables by regex pattern (e.g., "^prod_.*_v[0-9]+$")
	Pattern string `form:"pattern,omitempty" json:"pattern,omitempty,omitzero"`
}

// LookupKeyParams defines parameters for LookupKey.
type LookupKeyParams struct {
	// Fields Comma-separated list of fields to include in the response.
	// If not specified, returns the full document. Supports:
	// - Simple fields: "title,author"
	// - Nested paths: "user.address.city"
	// - Wildcards: "_chunks.*"
	// - Exclusions: "-_chunks.*._embedding"
	// - Special fields: "_embeddings,_summaries,_chunks"
	Fields string `form:"fields,omitempty" json:"fields,omitempty,omitzero"`
}

// RemovePermissionFromUserParams defines parameters for RemovePermissionFromUser.
type RemovePermissionFromUserParams struct {
	// Resource The name of the resource for the permission to be removed.
	Resource string `form:"resource" json:"resource"`

	// ResourceType The type of the resource for the permission to be removed.
	ResourceType ResourceType `form:"resourceType" json:"resourceType"`
}

// AnswerAgentJSONRequestBody defines body for AnswerAgent for application/json ContentType.
type AnswerAgentJSONRequestBody = AnswerAgentRequest

// QueryBuilderAgentJSONRequestBody defines body for QueryBuilderAgent for application/json ContentType.
type QueryBuilderAgentJSONRequestBody = QueryBuilderRequest

// RetrievalAgentJSONRequestBody defines body for RetrievalAgent for application/json ContentType.
type RetrievalAgentJSONRequestBody = RetrievalAgentRequest

// BackupJSONRequestBody defines body for Backup for application/json ContentType.
type BackupJSONRequestBody = ClusterBackupRequest

// MultiBatchWriteJSONRequestBody defines body for MultiBatchWrite for application/json ContentType.
type MultiBatchWriteJSONRequestBody = MultiBatchRequest

// EvaluateJSONRequestBody defines body for Evaluate for application/json ContentType.
type EvaluateJSONRequestBody = EvalRequest

// GlobalQueryJSONRequestBody defines body for GlobalQuery for application/json ContentType.
type GlobalQueryJSONRequestBody = QueryRequest

// RestoreJSONRequestBody defines body for Restore for application/json ContentType.
type RestoreJSONRequestBody = ClusterRestoreRequest

// CreateTableJSONRequestBody defines body for CreateTable for application/json ContentType.
type CreateTableJSONRequestBody = CreateTableRequest

// BackupTableJSONRequestBody defines body for BackupTable for application/json ContentType.
type BackupTableJSONRequestBody = BackupRequest

// BatchWriteJSONRequestBody defines body for BatchWrite for application/json ContentType.
type BatchWriteJSONRequestBody = BatchRequest

// CreateIndexJSONRequestBody defines body for CreateIndex for application/json ContentType.
type CreateIndexJSONRequestBody = IndexConfig

// ScanKeysJSONRequestBody defines body for ScanKeys for application/json ContentType.
type ScanKeysJSONRequestBody = ScanKeysRequest

// LinearMergeJSONRequestBody defines body for LinearMerge for application/json ContentType.
type LinearMergeJSONRequestBody = LinearMergeRequest

// QueryTableJSONRequestBody defines body for QueryTable for application/json ContentType.
type QueryTableJSONRequestBody = QueryRequest

// RestoreTableJSONRequestBody defines body for RestoreTable for application/json ContentType.
type RestoreTableJSONRequestBody = RestoreRequest

// UpdateSchemaJSONRequestBody defines body for UpdateSchema for application/json ContentType.
type UpdateSchemaJSONRequestBody = TableSchema

// CommitTransactionJSONRequestBody defines body for CommitTransaction for application/json ContentType.
type CommitTransactionJSONRequestBody = TransactionCommitRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = CreateUserRequest

// UpdateUserPasswordJSONRequestBody defines body for UpdateUserPassword for application/json ContentType.
type UpdateUserPasswordJSONRequestBody = UpdatePasswordRequest

// AddPermissionToUserJSONRequestBody defines body for AddPermissionToUser for application/json ContentType.
type AddPermissionToUserJSONRequestBody = Permission

// Getter for additional properties for ClusterStatus. Returns the specified
// element and whether it was found
func (a ClusterStatus) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ClusterStatus
func (a *ClusterStatus) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ClusterStatus to handle AdditionalProperties
func (a *ClusterStatus) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["auth_enabled"]; found {
		err = json.Unmarshal(raw, &a.AuthEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'auth_enabled': %w", err)
		}
		delete(object, "auth_enabled")
	}

	if raw, found := object["health"]; found {
		err = json.Unmarshal(raw, &a.Health)
		if err != nil {
			return fmt.Errorf("error reading 'health': %w", err)
		}
		delete(object, "health")
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ClusterStatus to handle AdditionalProperties
func (a ClusterStatus) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["auth_enabled"], err = json.Marshal(a.AuthEnabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth_enabled': %w", err)
	}

	object["health"], err = json.Marshal(a.Health)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'health': %w", err)
	}

	object["message"], err = json.Marshal(a.Message)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'message': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsTermiteChunkerConfig returns the union data inside the ChunkerConfig as a TermiteChunkerConfig
func (t ChunkerConfig) AsTermiteChunkerConfig() (TermiteChunkerConfig, error) {
	var body TermiteChunkerConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTermiteChunkerConfig overwrites any union data inside the ChunkerConfig as the provided TermiteChunkerConfig
func (t *ChunkerConfig) FromTermiteChunkerConfig(v TermiteChunkerConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTermiteChunkerConfig performs a merge with any union data inside the ChunkerConfig, using the provided TermiteChunkerConfig
func (t *ChunkerConfig) MergeTermiteChunkerConfig(v TermiteChunkerConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAntflyChunkerConfig returns the union data inside the ChunkerConfig as a AntflyChunkerConfig
func (t ChunkerConfig) AsAntflyChunkerConfig() (AntflyChunkerConfig, error) {
	var body AntflyChunkerConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAntflyChunkerConfig overwrites any union data inside the ChunkerConfig as the provided AntflyChunkerConfig
func (t *ChunkerConfig) FromAntflyChunkerConfig(v AntflyChunkerConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAntflyChunkerConfig performs a merge with any union data inside the ChunkerConfig, using the provided AntflyChunkerConfig
func (t *ChunkerConfig) MergeAntflyChunkerConfig(v AntflyChunkerConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChunkerConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["full_text_index"], err = json.Marshal(t.FullTextIndex)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'full_text_index': %w", err)
	}

	object["provider"], err = json.Marshal(t.Provider)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'provider': %w", err)
	}

	object["store_chunks"], err = json.Marshal(t.StoreChunks)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'store_chunks': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ChunkerConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["full_text_index"]; found {
		err = json.Unmarshal(raw, &t.FullTextIndex)
		if err != nil {
			return fmt.Errorf("error reading 'full_text_index': %w", err)
		}
	}

	if raw, found := object["provider"]; found {
		err = json.Unmarshal(raw, &t.Provider)
		if err != nil {
			return fmt.Errorf("error reading 'provider': %w", err)
		}
	}

	if raw, found := object["store_chunks"]; found {
		err = json.Unmarshal(raw, &t.StoreChunks)
		if err != nil {
			return fmt.Errorf("error reading 'store_chunks': %w", err)
		}
	}

	return err
}

// AsGoogleEmbedderConfig returns the union data inside the EmbedderConfig as a GoogleEmbedderConfig
func (t EmbedderConfig) AsGoogleEmbedderConfig() (GoogleEmbedderConfig, error) {
	var body GoogleEmbedderConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoogleEmbedderConfig overwrites any union data inside the EmbedderConfig as the provided GoogleEmbedderConfig
func (t *EmbedderConfig) FromGoogleEmbedderConfig(v GoogleEmbedderConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoogleEmbedderConfig performs a merge with any union data inside the EmbedderConfig, using the provided GoogleEmbedderConfig
func (t *EmbedderConfig) MergeGoogleEmbedderConfig(v GoogleEmbedderConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVertexEmbedderConfig returns the union data inside the EmbedderConfig as a VertexEmbedderConfig
func (t EmbedderConfig) AsVertexEmbedderConfig() (VertexEmbedderConfig, error) {
	var body VertexEmbedderConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVertexEmbedderConfig overwrites any union data inside the EmbedderConfig as the provided VertexEmbedderConfig
func (t *EmbedderConfig) FromVertexEmbedderConfig(v VertexEmbedderConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVertexEmbedderConfig performs a merge with any union data inside the EmbedderConfig, using the provided VertexEmbedderConfig
func (t *EmbedderConfig) MergeVertexEmbedderConfig(v VertexEmbedderConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOllamaEmbedderConfig returns the union data inside the EmbedderConfig as a OllamaEmbedderConfig
func (t EmbedderConfig) AsOllamaEmbedderConfig() (OllamaEmbedderConfig, error) {
	var body OllamaEmbedderConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOllamaEmbedderConfig overwrites any union data inside the EmbedderConfig as the provided OllamaEmbedderConfig
func (t *EmbedderConfig) FromOllamaEmbedderConfig(v OllamaEmbedderConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOllamaEmbedderConfig performs a merge with any union data inside the EmbedderConfig, using the provided OllamaEmbedderConfig
func (t *EmbedderConfig) MergeOllamaEmbedderConfig(v OllamaEmbedderConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenAIEmbedderConfig returns the union data inside the EmbedderConfig as a OpenAIEmbedderConfig
func (t EmbedderConfig) AsOpenAIEmbedderConfig() (OpenAIEmbedderConfig, error) {
	var body OpenAIEmbedderConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenAIEmbedderConfig overwrites any union data inside the EmbedderConfig as the provided OpenAIEmbedderConfig
func (t *EmbedderConfig) FromOpenAIEmbedderConfig(v OpenAIEmbedderConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenAIEmbedderConfig performs a merge with any union data inside the EmbedderConfig, using the provided OpenAIEmbedderConfig
func (t *EmbedderConfig) MergeOpenAIEmbedderConfig(v OpenAIEmbedderConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenRouterEmbedderConfig returns the union data inside the EmbedderConfig as a OpenRouterEmbedderConfig
func (t EmbedderConfig) AsOpenRouterEmbedderConfig() (OpenRouterEmbedderConfig, error) {
	var body OpenRouterEmbedderConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenRouterEmbedderConfig overwrites any union data inside the EmbedderConfig as the provided OpenRouterEmbedderConfig
func (t *EmbedderConfig) FromOpenRouterEmbedderConfig(v OpenRouterEmbedderConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenRouterEmbedderConfig performs a merge with any union data inside the EmbedderConfig, using the provided OpenRouterEmbedderConfig
func (t *EmbedderConfig) MergeOpenRouterEmbedderConfig(v OpenRouterEmbedderConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBedrockEmbedderConfig returns the union data inside the EmbedderConfig as a BedrockEmbedderConfig
func (t EmbedderConfig) AsBedrockEmbedderConfig() (BedrockEmbedderConfig, error) {
	var body BedrockEmbedderConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBedrockEmbedderConfig overwrites any union data inside the EmbedderConfig as the provided BedrockEmbedderConfig
func (t *EmbedderConfig) FromBedrockEmbedderConfig(v BedrockEmbedderConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBedrockEmbedderConfig performs a merge with any union data inside the EmbedderConfig, using the provided BedrockEmbedderConfig
func (t *EmbedderConfig) MergeBedrockEmbedderConfig(v BedrockEmbedderConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCohereEmbedderConfig returns the union data inside the EmbedderConfig as a CohereEmbedderConfig
func (t EmbedderConfig) AsCohereEmbedderConfig() (CohereEmbedderConfig, error) {
	var body CohereEmbedderConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCohereEmbedderConfig overwrites any union data inside the EmbedderConfig as the provided CohereEmbedderConfig
func (t *EmbedderConfig) FromCohereEmbedderConfig(v CohereEmbedderConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCohereEmbedderConfig performs a merge with any union data inside the EmbedderConfig, using the provided CohereEmbedderConfig
func (t *EmbedderConfig) MergeCohereEmbedderConfig(v CohereEmbedderConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTermiteEmbedderConfig returns the union data inside the EmbedderConfig as a TermiteEmbedderConfig
func (t EmbedderConfig) AsTermiteEmbedderConfig() (TermiteEmbedderConfig, error) {
	var body TermiteEmbedderConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTermiteEmbedderConfig overwrites any union data inside the EmbedderConfig as the provided TermiteEmbedderConfig
func (t *EmbedderConfig) FromTermiteEmbedderConfig(v TermiteEmbedderConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTermiteEmbedderConfig performs a merge with any union data inside the EmbedderConfig, using the provided TermiteEmbedderConfig
func (t *EmbedderConfig) MergeTermiteEmbedderConfig(v TermiteEmbedderConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAntflyEmbedderConfig returns the union data inside the EmbedderConfig as a AntflyEmbedderConfig
func (t EmbedderConfig) AsAntflyEmbedderConfig() (AntflyEmbedderConfig, error) {
	var body AntflyEmbedderConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAntflyEmbedderConfig overwrites any union data inside the EmbedderConfig as the provided AntflyEmbedderConfig
func (t *EmbedderConfig) FromAntflyEmbedderConfig(v AntflyEmbedderConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAntflyEmbedderConfig performs a merge with any union data inside the EmbedderConfig, using the provided AntflyEmbedderConfig
func (t *EmbedderConfig) MergeAntflyEmbedderConfig(v AntflyEmbedderConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmbedderConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["provider"], err = json.Marshal(t.Provider)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'provider': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *EmbedderConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["provider"]; found {
		err = json.Unmarshal(raw, &t.Provider)
		if err != nil {
			return fmt.Errorf("error reading 'provider': %w", err)
		}
	}

	return err
}

// AsFuzziness0 returns the union data inside the Fuzziness as a Fuzziness0
func (t Fuzziness) AsFuzziness0() (Fuzziness0, error) {
	var body Fuzziness0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFuzziness0 overwrites any union data inside the Fuzziness as the provided Fuzziness0
func (t *Fuzziness) FromFuzziness0(v Fuzziness0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFuzziness0 performs a merge with any union data inside the Fuzziness, using the provided Fuzziness0
func (t *Fuzziness) MergeFuzziness0(v Fuzziness0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFuzziness1 returns the union data inside the Fuzziness as a Fuzziness1
func (t Fuzziness) AsFuzziness1() (Fuzziness1, error) {
	var body Fuzziness1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFuzziness1 overwrites any union data inside the Fuzziness as the provided Fuzziness1
func (t *Fuzziness) FromFuzziness1(v Fuzziness1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFuzziness1 performs a merge with any union data inside the Fuzziness, using the provided Fuzziness1
func (t *Fuzziness) MergeFuzziness1(v Fuzziness1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Fuzziness) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Fuzziness) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGoogleGeneratorConfig returns the union data inside the GeneratorConfig as a GoogleGeneratorConfig
func (t GeneratorConfig) AsGoogleGeneratorConfig() (GoogleGeneratorConfig, error) {
	var body GoogleGeneratorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoogleGeneratorConfig overwrites any union data inside the GeneratorConfig as the provided GoogleGeneratorConfig
func (t *GeneratorConfig) FromGoogleGeneratorConfig(v GoogleGeneratorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoogleGeneratorConfig performs a merge with any union data inside the GeneratorConfig, using the provided GoogleGeneratorConfig
func (t *GeneratorConfig) MergeGoogleGeneratorConfig(v GoogleGeneratorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVertexGeneratorConfig returns the union data inside the GeneratorConfig as a VertexGeneratorConfig
func (t GeneratorConfig) AsVertexGeneratorConfig() (VertexGeneratorConfig, error) {
	var body VertexGeneratorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVertexGeneratorConfig overwrites any union data inside the GeneratorConfig as the provided VertexGeneratorConfig
func (t *GeneratorConfig) FromVertexGeneratorConfig(v VertexGeneratorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVertexGeneratorConfig performs a merge with any union data inside the GeneratorConfig, using the provided VertexGeneratorConfig
func (t *GeneratorConfig) MergeVertexGeneratorConfig(v VertexGeneratorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOllamaGeneratorConfig returns the union data inside the GeneratorConfig as a OllamaGeneratorConfig
func (t GeneratorConfig) AsOllamaGeneratorConfig() (OllamaGeneratorConfig, error) {
	var body OllamaGeneratorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOllamaGeneratorConfig overwrites any union data inside the GeneratorConfig as the provided OllamaGeneratorConfig
func (t *GeneratorConfig) FromOllamaGeneratorConfig(v OllamaGeneratorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOllamaGeneratorConfig performs a merge with any union data inside the GeneratorConfig, using the provided OllamaGeneratorConfig
func (t *GeneratorConfig) MergeOllamaGeneratorConfig(v OllamaGeneratorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTermiteGeneratorConfig returns the union data inside the GeneratorConfig as a TermiteGeneratorConfig
func (t GeneratorConfig) AsTermiteGeneratorConfig() (TermiteGeneratorConfig, error) {
	var body TermiteGeneratorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTermiteGeneratorConfig overwrites any union data inside the GeneratorConfig as the provided TermiteGeneratorConfig
func (t *GeneratorConfig) FromTermiteGeneratorConfig(v TermiteGeneratorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTermiteGeneratorConfig performs a merge with any union data inside the GeneratorConfig, using the provided TermiteGeneratorConfig
func (t *GeneratorConfig) MergeTermiteGeneratorConfig(v TermiteGeneratorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenAIGeneratorConfig returns the union data inside the GeneratorConfig as a OpenAIGeneratorConfig
func (t GeneratorConfig) AsOpenAIGeneratorConfig() (OpenAIGeneratorConfig, error) {
	var body OpenAIGeneratorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenAIGeneratorConfig overwrites any union data inside the GeneratorConfig as the provided OpenAIGeneratorConfig
func (t *GeneratorConfig) FromOpenAIGeneratorConfig(v OpenAIGeneratorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenAIGeneratorConfig performs a merge with any union data inside the GeneratorConfig, using the provided OpenAIGeneratorConfig
func (t *GeneratorConfig) MergeOpenAIGeneratorConfig(v OpenAIGeneratorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenRouterGeneratorConfig returns the union data inside the GeneratorConfig as a OpenRouterGeneratorConfig
func (t GeneratorConfig) AsOpenRouterGeneratorConfig() (OpenRouterGeneratorConfig, error) {
	var body OpenRouterGeneratorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenRouterGeneratorConfig overwrites any union data inside the GeneratorConfig as the provided OpenRouterGeneratorConfig
func (t *GeneratorConfig) FromOpenRouterGeneratorConfig(v OpenRouterGeneratorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenRouterGeneratorConfig performs a merge with any union data inside the GeneratorConfig, using the provided OpenRouterGeneratorConfig
func (t *GeneratorConfig) MergeOpenRouterGeneratorConfig(v OpenRouterGeneratorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBedrockGeneratorConfig returns the union data inside the GeneratorConfig as a BedrockGeneratorConfig
func (t GeneratorConfig) AsBedrockGeneratorConfig() (BedrockGeneratorConfig, error) {
	var body BedrockGeneratorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBedrockGeneratorConfig overwrites any union data inside the GeneratorConfig as the provided BedrockGeneratorConfig
func (t *GeneratorConfig) FromBedrockGeneratorConfig(v BedrockGeneratorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBedrockGeneratorConfig performs a merge with any union data inside the GeneratorConfig, using the provided BedrockGeneratorConfig
func (t *GeneratorConfig) MergeBedrockGeneratorConfig(v BedrockGeneratorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnthropicGeneratorConfig returns the union data inside the GeneratorConfig as a AnthropicGeneratorConfig
func (t GeneratorConfig) AsAnthropicGeneratorConfig() (AnthropicGeneratorConfig, error) {
	var body AnthropicGeneratorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnthropicGeneratorConfig overwrites any union data inside the GeneratorConfig as the provided AnthropicGeneratorConfig
func (t *GeneratorConfig) FromAnthropicGeneratorConfig(v AnthropicGeneratorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnthropicGeneratorConfig performs a merge with any union data inside the GeneratorConfig, using the provided AnthropicGeneratorConfig
func (t *GeneratorConfig) MergeAnthropicGeneratorConfig(v AnthropicGeneratorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCohereGeneratorConfig returns the union data inside the GeneratorConfig as a CohereGeneratorConfig
func (t GeneratorConfig) AsCohereGeneratorConfig() (CohereGeneratorConfig, error) {
	var body CohereGeneratorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCohereGeneratorConfig overwrites any union data inside the GeneratorConfig as the provided CohereGeneratorConfig
func (t *GeneratorConfig) FromCohereGeneratorConfig(v CohereGeneratorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCohereGeneratorConfig performs a merge with any union data inside the GeneratorConfig, using the provided CohereGeneratorConfig
func (t *GeneratorConfig) MergeCohereGeneratorConfig(v CohereGeneratorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GeneratorConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["provider"], err = json.Marshal(t.Provider)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'provider': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *GeneratorConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["provider"]; found {
		err = json.Unmarshal(raw, &t.Provider)
		if err != nil {
			return fmt.Errorf("error reading 'provider': %w", err)
		}
	}

	return err
}

// AsBleveIndexV2Config returns the union data inside the IndexConfig as a BleveIndexV2Config
func (t IndexConfig) AsBleveIndexV2Config() (BleveIndexV2Config, error) {
	var body BleveIndexV2Config
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBleveIndexV2Config overwrites any union data inside the IndexConfig as the provided BleveIndexV2Config
func (t *IndexConfig) FromBleveIndexV2Config(v BleveIndexV2Config) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBleveIndexV2Config performs a merge with any union data inside the IndexConfig, using the provided BleveIndexV2Config
func (t *IndexConfig) MergeBleveIndexV2Config(v BleveIndexV2Config) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbeddingIndexConfig returns the union data inside the IndexConfig as a EmbeddingIndexConfig
func (t IndexConfig) AsEmbeddingIndexConfig() (EmbeddingIndexConfig, error) {
	var body EmbeddingIndexConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbeddingIndexConfig overwrites any union data inside the IndexConfig as the provided EmbeddingIndexConfig
func (t *IndexConfig) FromEmbeddingIndexConfig(v EmbeddingIndexConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbeddingIndexConfig performs a merge with any union data inside the IndexConfig, using the provided EmbeddingIndexConfig
func (t *IndexConfig) MergeEmbeddingIndexConfig(v EmbeddingIndexConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGraphIndexV0Config returns the union data inside the IndexConfig as a GraphIndexV0Config
func (t IndexConfig) AsGraphIndexV0Config() (GraphIndexV0Config, error) {
	var body GraphIndexV0Config
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGraphIndexV0Config overwrites any union data inside the IndexConfig as the provided GraphIndexV0Config
func (t *IndexConfig) FromGraphIndexV0Config(v GraphIndexV0Config) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGraphIndexV0Config performs a merge with any union data inside the IndexConfig, using the provided GraphIndexV0Config
func (t *IndexConfig) MergeGraphIndexV0Config(v GraphIndexV0Config) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IndexConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["description"], err = json.Marshal(t.Description)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'description': %w", err)
	}

	if t.Enrichments != nil {
		object["enrichments"], err = json.Marshal(t.Enrichments)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enrichments': %w", err)
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *IndexConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["enrichments"]; found {
		err = json.Unmarshal(raw, &t.Enrichments)
		if err != nil {
			return fmt.Errorf("error reading 'enrichments': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsBleveIndexV2Stats returns the union data inside the IndexStats as a BleveIndexV2Stats
func (t IndexStats) AsBleveIndexV2Stats() (BleveIndexV2Stats, error) {
	var body BleveIndexV2Stats
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBleveIndexV2Stats overwrites any union data inside the IndexStats as the provided BleveIndexV2Stats
func (t *IndexStats) FromBleveIndexV2Stats(v BleveIndexV2Stats) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBleveIndexV2Stats performs a merge with any union data inside the IndexStats, using the provided BleveIndexV2Stats
func (t *IndexStats) MergeBleveIndexV2Stats(v BleveIndexV2Stats) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbeddingIndexStats returns the union data inside the IndexStats as a EmbeddingIndexStats
func (t IndexStats) AsEmbeddingIndexStats() (EmbeddingIndexStats, error) {
	var body EmbeddingIndexStats
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbeddingIndexStats overwrites any union data inside the IndexStats as the provided EmbeddingIndexStats
func (t *IndexStats) FromEmbeddingIndexStats(v EmbeddingIndexStats) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbeddingIndexStats performs a merge with any union data inside the IndexStats, using the provided EmbeddingIndexStats
func (t *IndexStats) MergeEmbeddingIndexStats(v EmbeddingIndexStats) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGraphIndexV0Stats returns the union data inside the IndexStats as a GraphIndexV0Stats
func (t IndexStats) AsGraphIndexV0Stats() (GraphIndexV0Stats, error) {
	var body GraphIndexV0Stats
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGraphIndexV0Stats overwrites any union data inside the IndexStats as the provided GraphIndexV0Stats
func (t *IndexStats) FromGraphIndexV0Stats(v GraphIndexV0Stats) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGraphIndexV0Stats performs a merge with any union data inside the IndexStats, using the provided GraphIndexV0Stats
func (t *IndexStats) MergeGraphIndexV0Stats(v GraphIndexV0Stats) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IndexStats) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IndexStats) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTermQuery returns the union data inside the Query as a TermQuery
func (t Query) AsTermQuery() (TermQuery, error) {
	var body TermQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTermQuery overwrites any union data inside the Query as the provided TermQuery
func (t *Query) FromTermQuery(v TermQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTermQuery performs a merge with any union data inside the Query, using the provided TermQuery
func (t *Query) MergeTermQuery(v TermQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMatchQuery returns the union data inside the Query as a MatchQuery
func (t Query) AsMatchQuery() (MatchQuery, error) {
	var body MatchQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMatchQuery overwrites any union data inside the Query as the provided MatchQuery
func (t *Query) FromMatchQuery(v MatchQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMatchQuery performs a merge with any union data inside the Query, using the provided MatchQuery
func (t *Query) MergeMatchQuery(v MatchQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMatchPhraseQuery returns the union data inside the Query as a MatchPhraseQuery
func (t Query) AsMatchPhraseQuery() (MatchPhraseQuery, error) {
	var body MatchPhraseQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMatchPhraseQuery overwrites any union data inside the Query as the provided MatchPhraseQuery
func (t *Query) FromMatchPhraseQuery(v MatchPhraseQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMatchPhraseQuery performs a merge with any union data inside the Query, using the provided MatchPhraseQuery
func (t *Query) MergeMatchPhraseQuery(v MatchPhraseQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPhraseQuery returns the union data inside the Query as a PhraseQuery
func (t Query) AsPhraseQuery() (PhraseQuery, error) {
	var body PhraseQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPhraseQuery overwrites any union data inside the Query as the provided PhraseQuery
func (t *Query) FromPhraseQuery(v PhraseQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePhraseQuery performs a merge with any union data inside the Query, using the provided PhraseQuery
func (t *Query) MergePhraseQuery(v PhraseQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultiPhraseQuery returns the union data inside the Query as a MultiPhraseQuery
func (t Query) AsMultiPhraseQuery() (MultiPhraseQuery, error) {
	var body MultiPhraseQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiPhraseQuery overwrites any union data inside the Query as the provided MultiPhraseQuery
func (t *Query) FromMultiPhraseQuery(v MultiPhraseQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiPhraseQuery performs a merge with any union data inside the Query, using the provided MultiPhraseQuery
func (t *Query) MergeMultiPhraseQuery(v MultiPhraseQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFuzzyQuery returns the union data inside the Query as a FuzzyQuery
func (t Query) AsFuzzyQuery() (FuzzyQuery, error) {
	var body FuzzyQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFuzzyQuery overwrites any union data inside the Query as the provided FuzzyQuery
func (t *Query) FromFuzzyQuery(v FuzzyQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFuzzyQuery performs a merge with any union data inside the Query, using the provided FuzzyQuery
func (t *Query) MergeFuzzyQuery(v FuzzyQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPrefixQuery returns the union data inside the Query as a PrefixQuery
func (t Query) AsPrefixQuery() (PrefixQuery, error) {
	var body PrefixQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrefixQuery overwrites any union data inside the Query as the provided PrefixQuery
func (t *Query) FromPrefixQuery(v PrefixQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrefixQuery performs a merge with any union data inside the Query, using the provided PrefixQuery
func (t *Query) MergePrefixQuery(v PrefixQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRegexpQuery returns the union data inside the Query as a RegexpQuery
func (t Query) AsRegexpQuery() (RegexpQuery, error) {
	var body RegexpQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRegexpQuery overwrites any union data inside the Query as the provided RegexpQuery
func (t *Query) FromRegexpQuery(v RegexpQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRegexpQuery performs a merge with any union data inside the Query, using the provided RegexpQuery
func (t *Query) MergeRegexpQuery(v RegexpQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWildcardQuery returns the union data inside the Query as a WildcardQuery
func (t Query) AsWildcardQuery() (WildcardQuery, error) {
	var body WildcardQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWildcardQuery overwrites any union data inside the Query as the provided WildcardQuery
func (t *Query) FromWildcardQuery(v WildcardQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWildcardQuery performs a merge with any union data inside the Query, using the provided WildcardQuery
func (t *Query) MergeWildcardQuery(v WildcardQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQueryStringQuery returns the union data inside the Query as a QueryStringQuery
func (t Query) AsQueryStringQuery() (QueryStringQuery, error) {
	var body QueryStringQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQueryStringQuery overwrites any union data inside the Query as the provided QueryStringQuery
func (t *Query) FromQueryStringQuery(v QueryStringQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQueryStringQuery performs a merge with any union data inside the Query, using the provided QueryStringQuery
func (t *Query) MergeQueryStringQuery(v QueryStringQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNumericRangeQuery returns the union data inside the Query as a NumericRangeQuery
func (t Query) AsNumericRangeQuery() (NumericRangeQuery, error) {
	var body NumericRangeQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNumericRangeQuery overwrites any union data inside the Query as the provided NumericRangeQuery
func (t *Query) FromNumericRangeQuery(v NumericRangeQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNumericRangeQuery performs a merge with any union data inside the Query, using the provided NumericRangeQuery
func (t *Query) MergeNumericRangeQuery(v NumericRangeQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTermRangeQuery returns the union data inside the Query as a TermRangeQuery
func (t Query) AsTermRangeQuery() (TermRangeQuery, error) {
	var body TermRangeQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTermRangeQuery overwrites any union data inside the Query as the provided TermRangeQuery
func (t *Query) FromTermRangeQuery(v TermRangeQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTermRangeQuery performs a merge with any union data inside the Query, using the provided TermRangeQuery
func (t *Query) MergeTermRangeQuery(v TermRangeQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDateRangeStringQuery returns the union data inside the Query as a DateRangeStringQuery
func (t Query) AsDateRangeStringQuery() (DateRangeStringQuery, error) {
	var body DateRangeStringQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateRangeStringQuery overwrites any union data inside the Query as the provided DateRangeStringQuery
func (t *Query) FromDateRangeStringQuery(v DateRangeStringQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateRangeStringQuery performs a merge with any union data inside the Query, using the provided DateRangeStringQuery
func (t *Query) MergeDateRangeStringQuery(v DateRangeStringQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBooleanQuery returns the union data inside the Query as a BooleanQuery
func (t Query) AsBooleanQuery() (BooleanQuery, error) {
	var body BooleanQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanQuery overwrites any union data inside the Query as the provided BooleanQuery
func (t *Query) FromBooleanQuery(v BooleanQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanQuery performs a merge with any union data inside the Query, using the provided BooleanQuery
func (t *Query) MergeBooleanQuery(v BooleanQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConjunctionQuery returns the union data inside the Query as a ConjunctionQuery
func (t Query) AsConjunctionQuery() (ConjunctionQuery, error) {
	var body ConjunctionQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConjunctionQuery overwrites any union data inside the Query as the provided ConjunctionQuery
func (t *Query) FromConjunctionQuery(v ConjunctionQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConjunctionQuery performs a merge with any union data inside the Query, using the provided ConjunctionQuery
func (t *Query) MergeConjunctionQuery(v ConjunctionQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDisjunctionQuery returns the union data inside the Query as a DisjunctionQuery
func (t Query) AsDisjunctionQuery() (DisjunctionQuery, error) {
	var body DisjunctionQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDisjunctionQuery overwrites any union data inside the Query as the provided DisjunctionQuery
func (t *Query) FromDisjunctionQuery(v DisjunctionQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDisjunctionQuery performs a merge with any union data inside the Query, using the provided DisjunctionQuery
func (t *Query) MergeDisjunctionQuery(v DisjunctionQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMatchAllQuery returns the union data inside the Query as a MatchAllQuery
func (t Query) AsMatchAllQuery() (MatchAllQuery, error) {
	var body MatchAllQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMatchAllQuery overwrites any union data inside the Query as the provided MatchAllQuery
func (t *Query) FromMatchAllQuery(v MatchAllQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMatchAllQuery performs a merge with any union data inside the Query, using the provided MatchAllQuery
func (t *Query) MergeMatchAllQuery(v MatchAllQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMatchNoneQuery returns the union data inside the Query as a MatchNoneQuery
func (t Query) AsMatchNoneQuery() (MatchNoneQuery, error) {
	var body MatchNoneQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMatchNoneQuery overwrites any union data inside the Query as the provided MatchNoneQuery
func (t *Query) FromMatchNoneQuery(v MatchNoneQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMatchNoneQuery performs a merge with any union data inside the Query, using the provided MatchNoneQuery
func (t *Query) MergeMatchNoneQuery(v MatchNoneQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDocIdQuery returns the union data inside the Query as a DocIdQuery
func (t Query) AsDocIdQuery() (DocIdQuery, error) {
	var body DocIdQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocIdQuery overwrites any union data inside the Query as the provided DocIdQuery
func (t *Query) FromDocIdQuery(v DocIdQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocIdQuery performs a merge with any union data inside the Query, using the provided DocIdQuery
func (t *Query) MergeDocIdQuery(v DocIdQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBoolFieldQuery returns the union data inside the Query as a BoolFieldQuery
func (t Query) AsBoolFieldQuery() (BoolFieldQuery, error) {
	var body BoolFieldQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBoolFieldQuery overwrites any union data inside the Query as the provided BoolFieldQuery
func (t *Query) FromBoolFieldQuery(v BoolFieldQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBoolFieldQuery performs a merge with any union data inside the Query, using the provided BoolFieldQuery
func (t *Query) MergeBoolFieldQuery(v BoolFieldQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIPRangeQuery returns the union data inside the Query as a IPRangeQuery
func (t Query) AsIPRangeQuery() (IPRangeQuery, error) {
	var body IPRangeQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIPRangeQuery overwrites any union data inside the Query as the provided IPRangeQuery
func (t *Query) FromIPRangeQuery(v IPRangeQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIPRangeQuery performs a merge with any union data inside the Query, using the provided IPRangeQuery
func (t *Query) MergeIPRangeQuery(v IPRangeQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeoBoundingBoxQuery returns the union data inside the Query as a GeoBoundingBoxQuery
func (t Query) AsGeoBoundingBoxQuery() (GeoBoundingBoxQuery, error) {
	var body GeoBoundingBoxQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoBoundingBoxQuery overwrites any union data inside the Query as the provided GeoBoundingBoxQuery
func (t *Query) FromGeoBoundingBoxQuery(v GeoBoundingBoxQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoBoundingBoxQuery performs a merge with any union data inside the Query, using the provided GeoBoundingBoxQuery
func (t *Query) MergeGeoBoundingBoxQuery(v GeoBoundingBoxQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeoDistanceQuery returns the union data inside the Query as a GeoDistanceQuery
func (t Query) AsGeoDistanceQuery() (GeoDistanceQuery, error) {
	var body GeoDistanceQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoDistanceQuery overwrites any union data inside the Query as the provided GeoDistanceQuery
func (t *Query) FromGeoDistanceQuery(v GeoDistanceQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoDistanceQuery performs a merge with any union data inside the Query, using the provided GeoDistanceQuery
func (t *Query) MergeGeoDistanceQuery(v GeoDistanceQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeoBoundingPolygonQuery returns the union data inside the Query as a GeoBoundingPolygonQuery
func (t Query) AsGeoBoundingPolygonQuery() (GeoBoundingPolygonQuery, error) {
	var body GeoBoundingPolygonQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoBoundingPolygonQuery overwrites any union data inside the Query as the provided GeoBoundingPolygonQuery
func (t *Query) FromGeoBoundingPolygonQuery(v GeoBoundingPolygonQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoBoundingPolygonQuery performs a merge with any union data inside the Query, using the provided GeoBoundingPolygonQuery
func (t *Query) MergeGeoBoundingPolygonQuery(v GeoBoundingPolygonQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeoShapeQuery returns the union data inside the Query as a GeoShapeQuery
func (t Query) AsGeoShapeQuery() (GeoShapeQuery, error) {
	var body GeoShapeQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoShapeQuery overwrites any union data inside the Query as the provided GeoShapeQuery
func (t *Query) FromGeoShapeQuery(v GeoShapeQuery) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoShapeQuery performs a merge with any union data inside the Query, using the provided GeoShapeQuery
func (t *Query) MergeGeoShapeQuery(v GeoShapeQuery) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Query) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Query) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOllamaRerankerConfig returns the union data inside the RerankerConfig as a OllamaRerankerConfig
func (t RerankerConfig) AsOllamaRerankerConfig() (OllamaRerankerConfig, error) {
	var body OllamaRerankerConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOllamaRerankerConfig overwrites any union data inside the RerankerConfig as the provided OllamaRerankerConfig
func (t *RerankerConfig) FromOllamaRerankerConfig(v OllamaRerankerConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOllamaRerankerConfig performs a merge with any union data inside the RerankerConfig, using the provided OllamaRerankerConfig
func (t *RerankerConfig) MergeOllamaRerankerConfig(v OllamaRerankerConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTermiteRerankerConfig returns the union data inside the RerankerConfig as a TermiteRerankerConfig
func (t RerankerConfig) AsTermiteRerankerConfig() (TermiteRerankerConfig, error) {
	var body TermiteRerankerConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTermiteRerankerConfig overwrites any union data inside the RerankerConfig as the provided TermiteRerankerConfig
func (t *RerankerConfig) FromTermiteRerankerConfig(v TermiteRerankerConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTermiteRerankerConfig performs a merge with any union data inside the RerankerConfig, using the provided TermiteRerankerConfig
func (t *RerankerConfig) MergeTermiteRerankerConfig(v TermiteRerankerConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCohereRerankerConfig returns the union data inside the RerankerConfig as a CohereRerankerConfig
func (t RerankerConfig) AsCohereRerankerConfig() (CohereRerankerConfig, error) {
	var body CohereRerankerConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCohereRerankerConfig overwrites any union data inside the RerankerConfig as the provided CohereRerankerConfig
func (t *RerankerConfig) FromCohereRerankerConfig(v CohereRerankerConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCohereRerankerConfig performs a merge with any union data inside the RerankerConfig, using the provided CohereRerankerConfig
func (t *RerankerConfig) MergeCohereRerankerConfig(v CohereRerankerConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVertexRerankerConfig returns the union data inside the RerankerConfig as a VertexRerankerConfig
func (t RerankerConfig) AsVertexRerankerConfig() (VertexRerankerConfig, error) {
	var body VertexRerankerConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVertexRerankerConfig overwrites any union data inside the RerankerConfig as the provided VertexRerankerConfig
func (t *RerankerConfig) FromVertexRerankerConfig(v VertexRerankerConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVertexRerankerConfig performs a merge with any union data inside the RerankerConfig, using the provided VertexRerankerConfig
func (t *RerankerConfig) MergeVertexRerankerConfig(v VertexRerankerConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RerankerConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["field"], err = json.Marshal(t.Field)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'field': %w", err)
	}

	object["provider"], err = json.Marshal(t.Provider)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'provider': %w", err)
	}

	object["template"], err = json.Marshal(t.Template)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'template': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *RerankerConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["field"]; found {
		err = json.Unmarshal(raw, &t.Field)
		if err != nil {
			return fmt.Errorf("error reading 'field': %w", err)
		}
	}

	if raw, found := object["provider"]; found {
		err = json.Unmarshal(raw, &t.Provider)
		if err != nil {
			return fmt.Errorf("error reading 'provider': %w", err)
		}
	}

	if raw, found := object["template"]; found {
		err = json.Unmarshal(raw, &t.Template)
		if err != nil {
			return fmt.Errorf("error reading 'template': %w", err)
		}
	}

	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AnswerAgentWithBody request with any body
	AnswerAgentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AnswerAgent(ctx context.Context, body AnswerAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryBuilderAgentWithBody request with any body
	QueryBuilderAgentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryBuilderAgent(ctx context.Context, body QueryBuilderAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrievalAgentWithBody request with any body
	RetrievalAgentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RetrievalAgent(ctx context.Context, body RetrievalAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BackupWithBody request with any body
	BackupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Backup(ctx context.Context, body BackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBackups request
	ListBackups(ctx context.Context, params *ListBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MultiBatchWriteWithBody request with any body
	MultiBatchWriteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MultiBatchWrite(ctx context.Context, body MultiBatchWriteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EvaluateWithBody request with any body
	EvaluateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Evaluate(ctx context.Context, body EvaluateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalQueryWithBody request with any body
	GlobalQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GlobalQuery(ctx context.Context, body GlobalQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreWithBody request with any body
	RestoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Restore(ctx context.Context, body RestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTables request
	ListTables(ctx context.Context, params *ListTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DropTable request
	DropTable(ctx context.Context, tableName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTable request
	GetTable(ctx context.Context, tableName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTableWithBody request with any body
	CreateTableWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTable(ctx context.Context, tableName string, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BackupTableWithBody request with any body
	BackupTableWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BackupTable(ctx context.Context, tableName string, body BackupTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BatchWriteWithBody request with any body
	BatchWriteWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BatchWrite(ctx context.Context, tableName string, body BatchWriteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIndexes request
	ListIndexes(ctx context.Context, tableName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DropIndex request
	DropIndex(ctx context.Context, tableName string, indexName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndex request
	GetIndex(ctx context.Context, tableName string, indexName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIndexWithBody request with any body
	CreateIndexWithBody(ctx context.Context, tableName string, indexName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIndex(ctx context.Context, tableName string, indexName string, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScanKeysWithBody request with any body
	ScanKeysWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScanKeys(ctx context.Context, tableName string, body ScanKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LookupKey request
	LookupKey(ctx context.Context, tableName string, key string, params *LookupKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinearMergeWithBody request with any body
	LinearMergeWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinearMerge(ctx context.Context, tableName string, body LinearMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryTableWithBody request with any body
	QueryTableWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryTable(ctx context.Context, tableName string, body QueryTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreTableWithBody request with any body
	RestoreTableWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestoreTable(ctx context.Context, tableName string, body RestoreTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSchemaWithBody request with any body
	UpdateSchemaWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSchema(ctx context.Context, tableName string, body UpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitTransactionWithBody request with any body
	CommitTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommitTransaction(ctx context.Context, body CommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userName UserNamePathParameter, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserByName request
	GetUserByName(ctx context.Context, userName UserNamePathParameter, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, userName UserNamePathParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, userName UserNamePathParameter, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserPasswordWithBody request with any body
	UpdateUserPasswordWithBody(ctx context.Context, userName UserNamePathParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserPassword(ctx context.Context, userName UserNamePathParameter, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePermissionFromUser request
	RemovePermissionFromUser(ctx context.Context, userName UserNamePathParameter, params *RemovePermissionFromUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserPermissions request
	GetUserPermissions(ctx context.Context, userName UserNamePathParameter, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPermissionToUserWithBody request with any body
	AddPermissionToUserWithBody(ctx context.Context, userName UserNamePathParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPermissionToUser(ctx context.Context, userName UserNamePathParameter, body AddPermissionToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AnswerAgentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnswerAgentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnswerAgent(ctx context.Context, body AnswerAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnswerAgentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryBuilderAgentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryBuilderAgentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryBuilderAgent(ctx context.Context, body QueryBuilderAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryBuilderAgentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrievalAgentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrievalAgentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrievalAgent(ctx context.Context, body RetrievalAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrievalAgentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BackupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBackupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Backup(ctx context.Context, body BackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBackupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBackups(ctx context.Context, params *ListBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBackupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MultiBatchWriteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultiBatchWriteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MultiBatchWrite(ctx context.Context, body MultiBatchWriteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultiBatchWriteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EvaluateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEvaluateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Evaluate(ctx context.Context, body EvaluateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEvaluateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalQuery(ctx context.Context, body GlobalQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Restore(ctx context.Context, body RestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTables(ctx context.Context, params *ListTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTablesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DropTable(ctx context.Context, tableName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropTableRequest(c.Server, tableName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTable(ctx context.Context, tableName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTableRequest(c.Server, tableName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTableWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequestWithBody(c.Server, tableName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTable(ctx context.Context, tableName string, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequest(c.Server, tableName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BackupTableWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBackupTableRequestWithBody(c.Server, tableName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BackupTable(ctx context.Context, tableName string, body BackupTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBackupTableRequest(c.Server, tableName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BatchWriteWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBatchWriteRequestWithBody(c.Server, tableName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BatchWrite(ctx context.Context, tableName string, body BatchWriteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBatchWriteRequest(c.Server, tableName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIndexes(ctx context.Context, tableName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIndexesRequest(c.Server, tableName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DropIndex(ctx context.Context, tableName string, indexName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropIndexRequest(c.Server, tableName, indexName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndex(ctx context.Context, tableName string, indexName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndexRequest(c.Server, tableName, indexName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexWithBody(ctx context.Context, tableName string, indexName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequestWithBody(c.Server, tableName, indexName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndex(ctx context.Context, tableName string, indexName string, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequest(c.Server, tableName, indexName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScanKeysWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScanKeysRequestWithBody(c.Server, tableName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScanKeys(ctx context.Context, tableName string, body ScanKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScanKeysRequest(c.Server, tableName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LookupKey(ctx context.Context, tableName string, key string, params *LookupKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLookupKeyRequest(c.Server, tableName, key, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinearMergeWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinearMergeRequestWithBody(c.Server, tableName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinearMerge(ctx context.Context, tableName string, body LinearMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinearMergeRequest(c.Server, tableName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryTableWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryTableRequestWithBody(c.Server, tableName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryTable(ctx context.Context, tableName string, body QueryTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryTableRequest(c.Server, tableName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreTableWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreTableRequestWithBody(c.Server, tableName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreTable(ctx context.Context, tableName string, body RestoreTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreTableRequest(c.Server, tableName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSchemaWithBody(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSchemaRequestWithBody(c.Server, tableName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSchema(ctx context.Context, tableName string, body UpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSchemaRequest(c.Server, tableName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitTransaction(ctx context.Context, body CommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userName UserNamePathParameter, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserByName(ctx context.Context, userName UserNamePathParameter, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserByNameRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, userName UserNamePathParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, userName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, userName UserNamePathParameter, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, userName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPasswordWithBody(ctx context.Context, userName UserNamePathParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPasswordRequestWithBody(c.Server, userName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPassword(ctx context.Context, userName UserNamePathParameter, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPasswordRequest(c.Server, userName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePermissionFromUser(ctx context.Context, userName UserNamePathParameter, params *RemovePermissionFromUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePermissionFromUserRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserPermissions(ctx context.Context, userName UserNamePathParameter, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserPermissionsRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPermissionToUserWithBody(ctx context.Context, userName UserNamePathParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPermissionToUserRequestWithBody(c.Server, userName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPermissionToUser(ctx context.Context, userName UserNamePathParameter, body AddPermissionToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPermissionToUserRequest(c.Server, userName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAnswerAgentRequest calls the generic AnswerAgent builder with application/json body
func NewAnswerAgentRequest(server string, body AnswerAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAnswerAgentRequestWithBody(server, "application/json", bodyReader)
}

// NewAnswerAgentRequestWithBody generates requests for AnswerAgent with any type of body
func NewAnswerAgentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/answer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryBuilderAgentRequest calls the generic QueryBuilderAgent builder with application/json body
func NewQueryBuilderAgentRequest(server string, body QueryBuilderAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryBuilderAgentRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryBuilderAgentRequestWithBody generates requests for QueryBuilderAgent with any type of body
func NewQueryBuilderAgentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/query-builder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrievalAgentRequest calls the generic RetrievalAgent builder with application/json body
func NewRetrievalAgentRequest(server string, body RetrievalAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRetrievalAgentRequestWithBody(server, "application/json", bodyReader)
}

// NewRetrievalAgentRequestWithBody generates requests for RetrievalAgent with any type of body
func NewRetrievalAgentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/retrieval")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBackupRequest calls the generic Backup builder with application/json body
func NewBackupRequest(server string, body BackupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBackupRequestWithBody(server, "application/json", bodyReader)
}

// NewBackupRequestWithBody generates requests for Backup with any type of body
func NewBackupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBackupsRequest generates requests for ListBackups
func NewListBackupsRequest(server string, params *ListBackupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location", runtime.ParamLocationQuery, params.Location); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMultiBatchWriteRequest calls the generic MultiBatchWrite builder with application/json body
func NewMultiBatchWriteRequest(server string, body MultiBatchWriteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMultiBatchWriteRequestWithBody(server, "application/json", bodyReader)
}

// NewMultiBatchWriteRequestWithBody generates requests for MultiBatchWrite with any type of body
func NewMultiBatchWriteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEvaluateRequest calls the generic Evaluate builder with application/json body
func NewEvaluateRequest(server string, body EvaluateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEvaluateRequestWithBody(server, "application/json", bodyReader)
}

// NewEvaluateRequestWithBody generates requests for Evaluate with any type of body
func NewEvaluateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eval")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGlobalQueryRequest calls the generic GlobalQuery builder with application/json body
func NewGlobalQueryRequest(server string, body GlobalQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGlobalQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewGlobalQueryRequestWithBody generates requests for GlobalQuery with any type of body
func NewGlobalQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreRequest calls the generic Restore builder with application/json body
func NewRestoreRequest(server string, body RestoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreRequestWithBody(server, "application/json", bodyReader)
}

// NewRestoreRequestWithBody generates requests for Restore with any type of body
func NewRestoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTablesRequest generates requests for ListTables
func NewListTablesRequest(server string, params *ListTablesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pattern", runtime.ParamLocationQuery, params.Pattern); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDropTableRequest generates requests for DropTable
func NewDropTableRequest(server string, tableName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTableRequest generates requests for GetTable
func NewGetTableRequest(server string, tableName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTableRequest calls the generic CreateTable builder with application/json body
func NewCreateTableRequest(server string, tableName string, body CreateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTableRequestWithBody(server, tableName, "application/json", bodyReader)
}

// NewCreateTableRequestWithBody generates requests for CreateTable with any type of body
func NewCreateTableRequestWithBody(server string, tableName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBackupTableRequest calls the generic BackupTable builder with application/json body
func NewBackupTableRequest(server string, tableName string, body BackupTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBackupTableRequestWithBody(server, tableName, "application/json", bodyReader)
}

// NewBackupTableRequestWithBody generates requests for BackupTable with any type of body
func NewBackupTableRequestWithBody(server string, tableName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/backup", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBatchWriteRequest calls the generic BatchWrite builder with application/json body
func NewBatchWriteRequest(server string, tableName string, body BatchWriteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBatchWriteRequestWithBody(server, tableName, "application/json", bodyReader)
}

// NewBatchWriteRequestWithBody generates requests for BatchWrite with any type of body
func NewBatchWriteRequestWithBody(server string, tableName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListIndexesRequest generates requests for ListIndexes
func NewListIndexesRequest(server string, tableName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/indexes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDropIndexRequest generates requests for DropIndex
func NewDropIndexRequest(server string, tableName string, indexName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "indexName", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/indexes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIndexRequest generates requests for GetIndex
func NewGetIndexRequest(server string, tableName string, indexName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "indexName", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/indexes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIndexRequest calls the generic CreateIndex builder with application/json body
func NewCreateIndexRequest(server string, tableName string, indexName string, body CreateIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIndexRequestWithBody(server, tableName, indexName, "application/json", bodyReader)
}

// NewCreateIndexRequestWithBody generates requests for CreateIndex with any type of body
func NewCreateIndexRequestWithBody(server string, tableName string, indexName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "indexName", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/indexes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScanKeysRequest calls the generic ScanKeys builder with application/json body
func NewScanKeysRequest(server string, tableName string, body ScanKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScanKeysRequestWithBody(server, tableName, "application/json", bodyReader)
}

// NewScanKeysRequestWithBody generates requests for ScanKeys with any type of body
func NewScanKeysRequestWithBody(server string, tableName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/lookup", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLookupKeyRequest generates requests for LookupKey
func NewLookupKeyRequest(server string, tableName string, key string, params *LookupKeyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/lookup/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, params.Fields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinearMergeRequest calls the generic LinearMerge builder with application/json body
func NewLinearMergeRequest(server string, tableName string, body LinearMergeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinearMergeRequestWithBody(server, tableName, "application/json", bodyReader)
}

// NewLinearMergeRequestWithBody generates requests for LinearMerge with any type of body
func NewLinearMergeRequestWithBody(server string, tableName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/merge", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryTableRequest calls the generic QueryTable builder with application/json body
func NewQueryTableRequest(server string, tableName string, body QueryTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryTableRequestWithBody(server, tableName, "application/json", bodyReader)
}

// NewQueryTableRequestWithBody generates requests for QueryTable with any type of body
func NewQueryTableRequestWithBody(server string, tableName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreTableRequest calls the generic RestoreTable builder with application/json body
func NewRestoreTableRequest(server string, tableName string, body RestoreTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreTableRequestWithBody(server, tableName, "application/json", bodyReader)
}

// NewRestoreTableRequestWithBody generates requests for RestoreTable with any type of body
func NewRestoreTableRequestWithBody(server string, tableName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateSchemaRequest calls the generic UpdateSchema builder with application/json body
func NewUpdateSchemaRequest(server string, tableName string, body UpdateSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSchemaRequestWithBody(server, tableName, "application/json", bodyReader)
}

// NewUpdateSchemaRequestWithBody generates requests for UpdateSchema with any type of body
func NewUpdateSchemaRequestWithBody(server string, tableName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableName", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/schema", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommitTransactionRequest calls the generic CommitTransaction builder with application/json body
func NewCommitTransactionRequest(server string, body CommitTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommitTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewCommitTransactionRequestWithBody generates requests for CommitTransaction with any type of body
func NewCommitTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/commit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userName UserNamePathParameter) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userName", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserByNameRequest generates requests for GetUserByName
func NewGetUserByNameRequest(server string, userName UserNamePathParameter) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userName", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, userName UserNamePathParameter, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, userName, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, userName UserNamePathParameter, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userName", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateUserPasswordRequest calls the generic UpdateUserPassword builder with application/json body
func NewUpdateUserPasswordRequest(server string, userName UserNamePathParameter, body UpdateUserPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserPasswordRequestWithBody(server, userName, "application/json", bodyReader)
}

// NewUpdateUserPasswordRequestWithBody generates requests for UpdateUserPassword with any type of body
func NewUpdateUserPasswordRequestWithBody(server string, userName UserNamePathParameter, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userName", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/password", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePermissionFromUserRequest generates requests for RemovePermissionFromUser
func NewRemovePermissionFromUserRequest(server string, userName UserNamePathParameter, params *RemovePermissionFromUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userName", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceType", runtime.ParamLocationQuery, params.ResourceType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserPermissionsRequest generates requests for GetUserPermissions
func NewGetUserPermissionsRequest(server string, userName UserNamePathParameter) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userName", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPermissionToUserRequest calls the generic AddPermissionToUser builder with application/json body
func NewAddPermissionToUserRequest(server string, userName UserNamePathParameter, body AddPermissionToUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPermissionToUserRequestWithBody(server, userName, "application/json", bodyReader)
}

// NewAddPermissionToUserRequestWithBody generates requests for AddPermissionToUser with any type of body
func NewAddPermissionToUserRequestWithBody(server string, userName UserNamePathParameter, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userName", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AnswerAgentWithBodyWithResponse request with any body
	AnswerAgentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnswerAgentResponse, error)

	AnswerAgentWithResponse(ctx context.Context, body AnswerAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*AnswerAgentResponse, error)

	// QueryBuilderAgentWithBodyWithResponse request with any body
	QueryBuilderAgentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryBuilderAgentResponse, error)

	QueryBuilderAgentWithResponse(ctx context.Context, body QueryBuilderAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryBuilderAgentResponse, error)

	// RetrievalAgentWithBodyWithResponse request with any body
	RetrievalAgentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RetrievalAgentResponse, error)

	RetrievalAgentWithResponse(ctx context.Context, body RetrievalAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*RetrievalAgentResponse, error)

	// BackupWithBodyWithResponse request with any body
	BackupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BackupResponse, error)

	BackupWithResponse(ctx context.Context, body BackupJSONRequestBody, reqEditors ...RequestEditorFn) (*BackupResponse, error)

	// ListBackupsWithResponse request
	ListBackupsWithResponse(ctx context.Context, params *ListBackupsParams, reqEditors ...RequestEditorFn) (*ListBackupsResponse, error)

	// MultiBatchWriteWithBodyWithResponse request with any body
	MultiBatchWriteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MultiBatchWriteResponse, error)

	MultiBatchWriteWithResponse(ctx context.Context, body MultiBatchWriteJSONRequestBody, reqEditors ...RequestEditorFn) (*MultiBatchWriteResponse, error)

	// EvaluateWithBodyWithResponse request with any body
	EvaluateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EvaluateResponse, error)

	EvaluateWithResponse(ctx context.Context, body EvaluateJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateResponse, error)

	// GlobalQueryWithBodyWithResponse request with any body
	GlobalQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalQueryResponse, error)

	GlobalQueryWithResponse(ctx context.Context, body GlobalQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalQueryResponse, error)

	// RestoreWithBodyWithResponse request with any body
	RestoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreResponse, error)

	RestoreWithResponse(ctx context.Context, body RestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreResponse, error)

	// GetStatusWithResponse request
	GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error)

	// ListTablesWithResponse request
	ListTablesWithResponse(ctx context.Context, params *ListTablesParams, reqEditors ...RequestEditorFn) (*ListTablesResponse, error)

	// DropTableWithResponse request
	DropTableWithResponse(ctx context.Context, tableName string, reqEditors ...RequestEditorFn) (*DropTableResponse, error)

	// GetTableWithResponse request
	GetTableWithResponse(ctx context.Context, tableName string, reqEditors ...RequestEditorFn) (*GetTableResponse, error)

	// CreateTableWithBodyWithResponse request with any body
	CreateTableWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	CreateTableWithResponse(ctx context.Context, tableName string, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	// BackupTableWithBodyWithResponse request with any body
	BackupTableWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BackupTableResponse, error)

	BackupTableWithResponse(ctx context.Context, tableName string, body BackupTableJSONRequestBody, reqEditors ...RequestEditorFn) (*BackupTableResponse, error)

	// BatchWriteWithBodyWithResponse request with any body
	BatchWriteWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BatchWriteResponse, error)

	BatchWriteWithResponse(ctx context.Context, tableName string, body BatchWriteJSONRequestBody, reqEditors ...RequestEditorFn) (*BatchWriteResponse, error)

	// ListIndexesWithResponse request
	ListIndexesWithResponse(ctx context.Context, tableName string, reqEditors ...RequestEditorFn) (*ListIndexesResponse, error)

	// DropIndexWithResponse request
	DropIndexWithResponse(ctx context.Context, tableName string, indexName string, reqEditors ...RequestEditorFn) (*DropIndexResponse, error)

	// GetIndexWithResponse request
	GetIndexWithResponse(ctx context.Context, tableName string, indexName string, reqEditors ...RequestEditorFn) (*GetIndexResponse, error)

	// CreateIndexWithBodyWithResponse request with any body
	CreateIndexWithBodyWithResponse(ctx context.Context, tableName string, indexName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	CreateIndexWithResponse(ctx context.Context, tableName string, indexName string, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	// ScanKeysWithBodyWithResponse request with any body
	ScanKeysWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScanKeysResponse, error)

	ScanKeysWithResponse(ctx context.Context, tableName string, body ScanKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*ScanKeysResponse, error)

	// LookupKeyWithResponse request
	LookupKeyWithResponse(ctx context.Context, tableName string, key string, params *LookupKeyParams, reqEditors ...RequestEditorFn) (*LookupKeyResponse, error)

	// LinearMergeWithBodyWithResponse request with any body
	LinearMergeWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinearMergeResponse, error)

	LinearMergeWithResponse(ctx context.Context, tableName string, body LinearMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*LinearMergeResponse, error)

	// QueryTableWithBodyWithResponse request with any body
	QueryTableWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryTableResponse, error)

	QueryTableWithResponse(ctx context.Context, tableName string, body QueryTableJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryTableResponse, error)

	// RestoreTableWithBodyWithResponse request with any body
	RestoreTableWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreTableResponse, error)

	RestoreTableWithResponse(ctx context.Context, tableName string, body RestoreTableJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreTableResponse, error)

	// UpdateSchemaWithBodyWithResponse request with any body
	UpdateSchemaWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSchemaResponse, error)

	UpdateSchemaWithResponse(ctx context.Context, tableName string, body UpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSchemaResponse, error)

	// CommitTransactionWithBodyWithResponse request with any body
	CommitTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error)

	CommitTransactionWithResponse(ctx context.Context, body CommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// GetCurrentUserWithResponse request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, userName UserNamePathParameter, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserByNameWithResponse request
	GetUserByNameWithResponse(ctx context.Context, userName UserNamePathParameter, reqEditors ...RequestEditorFn) (*GetUserByNameResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, userName UserNamePathParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, userName UserNamePathParameter, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// UpdateUserPasswordWithBodyWithResponse request with any body
	UpdateUserPasswordWithBodyWithResponse(ctx context.Context, userName UserNamePathParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error)

	UpdateUserPasswordWithResponse(ctx context.Context, userName UserNamePathParameter, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error)

	// RemovePermissionFromUserWithResponse request
	RemovePermissionFromUserWithResponse(ctx context.Context, userName UserNamePathParameter, params *RemovePermissionFromUserParams, reqEditors ...RequestEditorFn) (*RemovePermissionFromUserResponse, error)

	// GetUserPermissionsWithResponse request
	GetUserPermissionsWithResponse(ctx context.Context, userName UserNamePathParameter, reqEditors ...RequestEditorFn) (*GetUserPermissionsResponse, error)

	// AddPermissionToUserWithBodyWithResponse request with any body
	AddPermissionToUserWithBodyWithResponse(ctx context.Context, userName UserNamePathParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPermissionToUserResponse, error)

	AddPermissionToUserWithResponse(ctx context.Context, userName UserNamePathParameter, body AddPermissionToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPermissionToUserResponse, error)
}

type AnswerAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnswerAgentResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AnswerAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnswerAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryBuilderAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryBuilderResult
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r QueryBuilderAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryBuilderAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrievalAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RetrievalAgentResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RetrievalAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrievalAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterBackupResponse
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r BackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBackupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupListResponse
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListBackupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBackupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MultiBatchWriteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MultiBatchResponse
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MultiBatchWriteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MultiBatchWriteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EvaluateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvalResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r EvaluateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EvaluateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryResponses
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GlobalQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ClusterRestoreResponse
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RestoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterStatus
	JSON401      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TableStatus
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DropTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DropTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DropTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TableStatus
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Table
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r CreateTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BackupTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Backup string `json:"backup,omitempty,omitzero"`
	}
	JSON400 *BadRequest
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r BackupTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BackupTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BatchWriteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BatchResponse
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r BatchWriteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BatchWriteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIndexesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IndexStatus
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListIndexesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIndexesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DropIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DropIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DropIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexStatus
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScanKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ScanKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScanKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LookupKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r LookupKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LookupKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinearMergeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinearMergeResult
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r LinearMergeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinearMergeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryResponses
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r QueryTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		Restore string `json:"restore,omitempty,omitzero"`
	}
	JSON400 *BadRequest
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RestoreTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Table
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionCommitResponse
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON409      *TransactionCommitResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CommitTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Username string `json:"username,omitempty,omitzero"`
	}
	JSON401 *Error
	JSON403 *Error
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Permissions []Permission `json:"permissions,omitempty,omitzero"`
		Username    string       `json:"username,omitempty,omitzero"`
	}
	JSON401 *Error
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUserByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON400      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateUserPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePermissionFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RemovePermissionFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePermissionFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Permission
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUserPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPermissionToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SuccessMessage
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AddPermissionToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPermissionToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AnswerAgentWithBodyWithResponse request with arbitrary body returning *AnswerAgentResponse
func (c *ClientWithResponses) AnswerAgentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnswerAgentResponse, error) {
	rsp, err := c.AnswerAgentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnswerAgentResponse(rsp)
}

func (c *ClientWithResponses) AnswerAgentWithResponse(ctx context.Context, body AnswerAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*AnswerAgentResponse, error) {
	rsp, err := c.AnswerAgent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnswerAgentResponse(rsp)
}

// QueryBuilderAgentWithBodyWithResponse request with arbitrary body returning *QueryBuilderAgentResponse
func (c *ClientWithResponses) QueryBuilderAgentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryBuilderAgentResponse, error) {
	rsp, err := c.QueryBuilderAgentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryBuilderAgentResponse(rsp)
}

func (c *ClientWithResponses) QueryBuilderAgentWithResponse(ctx context.Context, body QueryBuilderAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryBuilderAgentResponse, error) {
	rsp, err := c.QueryBuilderAgent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryBuilderAgentResponse(rsp)
}

// RetrievalAgentWithBodyWithResponse request with arbitrary body returning *RetrievalAgentResponse
func (c *ClientWithResponses) RetrievalAgentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RetrievalAgentResponse, error) {
	rsp, err := c.RetrievalAgentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrievalAgentResponse(rsp)
}

func (c *ClientWithResponses) RetrievalAgentWithResponse(ctx context.Context, body RetrievalAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*RetrievalAgentResponse, error) {
	rsp, err := c.RetrievalAgent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrievalAgentResponse(rsp)
}

// BackupWithBodyWithResponse request with arbitrary body returning *BackupResponse
func (c *ClientWithResponses) BackupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BackupResponse, error) {
	rsp, err := c.BackupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBackupResponse(rsp)
}

func (c *ClientWithResponses) BackupWithResponse(ctx context.Context, body BackupJSONRequestBody, reqEditors ...RequestEditorFn) (*BackupResponse, error) {
	rsp, err := c.Backup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBackupResponse(rsp)
}

// ListBackupsWithResponse request returning *ListBackupsResponse
func (c *ClientWithResponses) ListBackupsWithResponse(ctx context.Context, params *ListBackupsParams, reqEditors ...RequestEditorFn) (*ListBackupsResponse, error) {
	rsp, err := c.ListBackups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBackupsResponse(rsp)
}

// MultiBatchWriteWithBodyWithResponse request with arbitrary body returning *MultiBatchWriteResponse
func (c *ClientWithResponses) MultiBatchWriteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MultiBatchWriteResponse, error) {
	rsp, err := c.MultiBatchWriteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultiBatchWriteResponse(rsp)
}

func (c *ClientWithResponses) MultiBatchWriteWithResponse(ctx context.Context, body MultiBatchWriteJSONRequestBody, reqEditors ...RequestEditorFn) (*MultiBatchWriteResponse, error) {
	rsp, err := c.MultiBatchWrite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultiBatchWriteResponse(rsp)
}

// EvaluateWithBodyWithResponse request with arbitrary body returning *EvaluateResponse
func (c *ClientWithResponses) EvaluateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EvaluateResponse, error) {
	rsp, err := c.EvaluateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEvaluateResponse(rsp)
}

func (c *ClientWithResponses) EvaluateWithResponse(ctx context.Context, body EvaluateJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateResponse, error) {
	rsp, err := c.Evaluate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEvaluateResponse(rsp)
}

// GlobalQueryWithBodyWithResponse request with arbitrary body returning *GlobalQueryResponse
func (c *ClientWithResponses) GlobalQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalQueryResponse, error) {
	rsp, err := c.GlobalQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalQueryResponse(rsp)
}

func (c *ClientWithResponses) GlobalQueryWithResponse(ctx context.Context, body GlobalQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalQueryResponse, error) {
	rsp, err := c.GlobalQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalQueryResponse(rsp)
}

// RestoreWithBodyWithResponse request with arbitrary body returning *RestoreResponse
func (c *ClientWithResponses) RestoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreResponse, error) {
	rsp, err := c.RestoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreResponse(rsp)
}

func (c *ClientWithResponses) RestoreWithResponse(ctx context.Context, body RestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreResponse, error) {
	rsp, err := c.Restore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error) {
	rsp, err := c.GetStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// ListTablesWithResponse request returning *ListTablesResponse
func (c *ClientWithResponses) ListTablesWithResponse(ctx context.Context, params *ListTablesParams, reqEditors ...RequestEditorFn) (*ListTablesResponse, error) {
	rsp, err := c.ListTables(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTablesResponse(rsp)
}

// DropTableWithResponse request returning *DropTableResponse
func (c *ClientWithResponses) DropTableWithResponse(ctx context.Context, tableName string, reqEditors ...RequestEditorFn) (*DropTableResponse, error) {
	rsp, err := c.DropTable(ctx, tableName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropTableResponse(rsp)
}

// GetTableWithResponse request returning *GetTableResponse
func (c *ClientWithResponses) GetTableWithResponse(ctx context.Context, tableName string, reqEditors ...RequestEditorFn) (*GetTableResponse, error) {
	rsp, err := c.GetTable(ctx, tableName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTableResponse(rsp)
}

// CreateTableWithBodyWithResponse request with arbitrary body returning *CreateTableResponse
func (c *ClientWithResponses) CreateTableWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTableWithBody(ctx, tableName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

func (c *ClientWithResponses) CreateTableWithResponse(ctx context.Context, tableName string, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTable(ctx, tableName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

// BackupTableWithBodyWithResponse request with arbitrary body returning *BackupTableResponse
func (c *ClientWithResponses) BackupTableWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BackupTableResponse, error) {
	rsp, err := c.BackupTableWithBody(ctx, tableName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBackupTableResponse(rsp)
}

func (c *ClientWithResponses) BackupTableWithResponse(ctx context.Context, tableName string, body BackupTableJSONRequestBody, reqEditors ...RequestEditorFn) (*BackupTableResponse, error) {
	rsp, err := c.BackupTable(ctx, tableName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBackupTableResponse(rsp)
}

// BatchWriteWithBodyWithResponse request with arbitrary body returning *BatchWriteResponse
func (c *ClientWithResponses) BatchWriteWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BatchWriteResponse, error) {
	rsp, err := c.BatchWriteWithBody(ctx, tableName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBatchWriteResponse(rsp)
}

func (c *ClientWithResponses) BatchWriteWithResponse(ctx context.Context, tableName string, body BatchWriteJSONRequestBody, reqEditors ...RequestEditorFn) (*BatchWriteResponse, error) {
	rsp, err := c.BatchWrite(ctx, tableName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBatchWriteResponse(rsp)
}

// ListIndexesWithResponse request returning *ListIndexesResponse
func (c *ClientWithResponses) ListIndexesWithResponse(ctx context.Context, tableName string, reqEditors ...RequestEditorFn) (*ListIndexesResponse, error) {
	rsp, err := c.ListIndexes(ctx, tableName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIndexesResponse(rsp)
}

// DropIndexWithResponse request returning *DropIndexResponse
func (c *ClientWithResponses) DropIndexWithResponse(ctx context.Context, tableName string, indexName string, reqEditors ...RequestEditorFn) (*DropIndexResponse, error) {
	rsp, err := c.DropIndex(ctx, tableName, indexName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropIndexResponse(rsp)
}

// GetIndexWithResponse request returning *GetIndexResponse
func (c *ClientWithResponses) GetIndexWithResponse(ctx context.Context, tableName string, indexName string, reqEditors ...RequestEditorFn) (*GetIndexResponse, error) {
	rsp, err := c.GetIndex(ctx, tableName, indexName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndexResponse(rsp)
}

// CreateIndexWithBodyWithResponse request with arbitrary body returning *CreateIndexResponse
func (c *ClientWithResponses) CreateIndexWithBodyWithResponse(ctx context.Context, tableName string, indexName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndexWithBody(ctx, tableName, indexName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

func (c *ClientWithResponses) CreateIndexWithResponse(ctx context.Context, tableName string, indexName string, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndex(ctx, tableName, indexName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

// ScanKeysWithBodyWithResponse request with arbitrary body returning *ScanKeysResponse
func (c *ClientWithResponses) ScanKeysWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScanKeysResponse, error) {
	rsp, err := c.ScanKeysWithBody(ctx, tableName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScanKeysResponse(rsp)
}

func (c *ClientWithResponses) ScanKeysWithResponse(ctx context.Context, tableName string, body ScanKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*ScanKeysResponse, error) {
	rsp, err := c.ScanKeys(ctx, tableName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScanKeysResponse(rsp)
}

// LookupKeyWithResponse request returning *LookupKeyResponse
func (c *ClientWithResponses) LookupKeyWithResponse(ctx context.Context, tableName string, key string, params *LookupKeyParams, reqEditors ...RequestEditorFn) (*LookupKeyResponse, error) {
	rsp, err := c.LookupKey(ctx, tableName, key, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLookupKeyResponse(rsp)
}

// LinearMergeWithBodyWithResponse request with arbitrary body returning *LinearMergeResponse
func (c *ClientWithResponses) LinearMergeWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinearMergeResponse, error) {
	rsp, err := c.LinearMergeWithBody(ctx, tableName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinearMergeResponse(rsp)
}

func (c *ClientWithResponses) LinearMergeWithResponse(ctx context.Context, tableName string, body LinearMergeJSONRequestBody, reqEditors ...RequestEditorFn) (*LinearMergeResponse, error) {
	rsp, err := c.LinearMerge(ctx, tableName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinearMergeResponse(rsp)
}

// QueryTableWithBodyWithResponse request with arbitrary body returning *QueryTableResponse
func (c *ClientWithResponses) QueryTableWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryTableResponse, error) {
	rsp, err := c.QueryTableWithBody(ctx, tableName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryTableResponse(rsp)
}

func (c *ClientWithResponses) QueryTableWithResponse(ctx context.Context, tableName string, body QueryTableJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryTableResponse, error) {
	rsp, err := c.QueryTable(ctx, tableName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryTableResponse(rsp)
}

// RestoreTableWithBodyWithResponse request with arbitrary body returning *RestoreTableResponse
func (c *ClientWithResponses) RestoreTableWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreTableResponse, error) {
	rsp, err := c.RestoreTableWithBody(ctx, tableName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreTableResponse(rsp)
}

func (c *ClientWithResponses) RestoreTableWithResponse(ctx context.Context, tableName string, body RestoreTableJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreTableResponse, error) {
	rsp, err := c.RestoreTable(ctx, tableName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreTableResponse(rsp)
}

// UpdateSchemaWithBodyWithResponse request with arbitrary body returning *UpdateSchemaResponse
func (c *ClientWithResponses) UpdateSchemaWithBodyWithResponse(ctx context.Context, tableName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSchemaResponse, error) {
	rsp, err := c.UpdateSchemaWithBody(ctx, tableName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSchemaResponse(rsp)
}

func (c *ClientWithResponses) UpdateSchemaWithResponse(ctx context.Context, tableName string, body UpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSchemaResponse, error) {
	rsp, err := c.UpdateSchema(ctx, tableName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSchemaResponse(rsp)
}

// CommitTransactionWithBodyWithResponse request with arbitrary body returning *CommitTransactionResponse
func (c *ClientWithResponses) CommitTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error) {
	rsp, err := c.CommitTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitTransactionResponse(rsp)
}

func (c *ClientWithResponses) CommitTransactionWithResponse(ctx context.Context, body CommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error) {
	rsp, err := c.CommitTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitTransactionResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userName UserNamePathParameter, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserByNameWithResponse request returning *GetUserByNameResponse
func (c *ClientWithResponses) GetUserByNameWithResponse(ctx context.Context, userName UserNamePathParameter, reqEditors ...RequestEditorFn) (*GetUserByNameResponse, error) {
	rsp, err := c.GetUserByName(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserByNameResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, userName UserNamePathParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, userName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, userName UserNamePathParameter, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, userName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// UpdateUserPasswordWithBodyWithResponse request with arbitrary body returning *UpdateUserPasswordResponse
func (c *ClientWithResponses) UpdateUserPasswordWithBodyWithResponse(ctx context.Context, userName UserNamePathParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error) {
	rsp, err := c.UpdateUserPasswordWithBody(ctx, userName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPasswordResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserPasswordWithResponse(ctx context.Context, userName UserNamePathParameter, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error) {
	rsp, err := c.UpdateUserPassword(ctx, userName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPasswordResponse(rsp)
}

// RemovePermissionFromUserWithResponse request returning *RemovePermissionFromUserResponse
func (c *ClientWithResponses) RemovePermissionFromUserWithResponse(ctx context.Context, userName UserNamePathParameter, params *RemovePermissionFromUserParams, reqEditors ...RequestEditorFn) (*RemovePermissionFromUserResponse, error) {
	rsp, err := c.RemovePermissionFromUser(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePermissionFromUserResponse(rsp)
}

// GetUserPermissionsWithResponse request returning *GetUserPermissionsResponse
func (c *ClientWithResponses) GetUserPermissionsWithResponse(ctx context.Context, userName UserNamePathParameter, reqEditors ...RequestEditorFn) (*GetUserPermissionsResponse, error) {
	rsp, err := c.GetUserPermissions(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserPermissionsResponse(rsp)
}

// AddPermissionToUserWithBodyWithResponse request with arbitrary body returning *AddPermissionToUserResponse
func (c *ClientWithResponses) AddPermissionToUserWithBodyWithResponse(ctx context.Context, userName UserNamePathParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPermissionToUserResponse, error) {
	rsp, err := c.AddPermissionToUserWithBody(ctx, userName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPermissionToUserResponse(rsp)
}

func (c *ClientWithResponses) AddPermissionToUserWithResponse(ctx context.Context, userName UserNamePathParameter, body AddPermissionToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPermissionToUserResponse, error) {
	rsp, err := c.AddPermissionToUser(ctx, userName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPermissionToUserResponse(rsp)
}

// ParseAnswerAgentResponse parses an HTTP response from a AnswerAgentWithResponse call
func ParseAnswerAgentResponse(rsp *http.Response) (*AnswerAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnswerAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnswerAgentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/event-stream) unsupported

	}

	return response, nil
}

// ParseQueryBuilderAgentResponse parses an HTTP response from a QueryBuilderAgentWithResponse call
func ParseQueryBuilderAgentResponse(rsp *http.Response) (*QueryBuilderAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryBuilderAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryBuilderResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRetrievalAgentResponse parses an HTTP response from a RetrievalAgentWithResponse call
func ParseRetrievalAgentResponse(rsp *http.Response) (*RetrievalAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrievalAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RetrievalAgentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/event-stream) unsupported

	}

	return response, nil
}

// ParseBackupResponse parses an HTTP response from a BackupWithResponse call
func ParseBackupResponse(rsp *http.Response) (*BackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterBackupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBackupsResponse parses an HTTP response from a ListBackupsWithResponse call
func ParseListBackupsResponse(rsp *http.Response) (*ListBackupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBackupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMultiBatchWriteResponse parses an HTTP response from a MultiBatchWriteWithResponse call
func ParseMultiBatchWriteResponse(rsp *http.Response) (*MultiBatchWriteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MultiBatchWriteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MultiBatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEvaluateResponse parses an HTTP response from a EvaluateWithResponse call
func ParseEvaluateResponse(rsp *http.Response) (*EvaluateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EvaluateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvalResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGlobalQueryResponse parses an HTTP response from a GlobalQueryWithResponse call
func ParseGlobalQueryResponse(rsp *http.Response) (*GlobalQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryResponses
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRestoreResponse parses an HTTP response from a RestoreWithResponse call
func ParseRestoreResponse(rsp *http.Response) (*RestoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ClusterRestoreResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTablesResponse parses an HTTP response from a ListTablesWithResponse call
func ParseListTablesResponse(rsp *http.Response) (*ListTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TableStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDropTableResponse parses an HTTP response from a DropTableWithResponse call
func ParseDropTableResponse(rsp *http.Response) (*DropTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DropTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTableResponse parses an HTTP response from a GetTableWithResponse call
func ParseGetTableResponse(rsp *http.Response) (*GetTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TableStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateTableResponse parses an HTTP response from a CreateTableWithResponse call
func ParseCreateTableResponse(rsp *http.Response) (*CreateTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBackupTableResponse parses an HTTP response from a BackupTableWithResponse call
func ParseBackupTableResponse(rsp *http.Response) (*BackupTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BackupTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Backup string `json:"backup,omitempty,omitzero"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBatchWriteResponse parses an HTTP response from a BatchWriteWithResponse call
func ParseBatchWriteResponse(rsp *http.Response) (*BatchWriteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BatchWriteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListIndexesResponse parses an HTTP response from a ListIndexesWithResponse call
func ParseListIndexesResponse(rsp *http.Response) (*ListIndexesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIndexesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IndexStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDropIndexResponse parses an HTTP response from a DropIndexWithResponse call
func ParseDropIndexResponse(rsp *http.Response) (*DropIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DropIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIndexResponse parses an HTTP response from a GetIndexWithResponse call
func ParseGetIndexResponse(rsp *http.Response) (*GetIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateIndexResponse parses an HTTP response from a CreateIndexWithResponse call
func ParseCreateIndexResponse(rsp *http.Response) (*CreateIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseScanKeysResponse parses an HTTP response from a ScanKeysWithResponse call
func ParseScanKeysResponse(rsp *http.Response) (*ScanKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScanKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLookupKeyResponse parses an HTTP response from a LookupKeyWithResponse call
func ParseLookupKeyResponse(rsp *http.Response) (*LookupKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LookupKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLinearMergeResponse parses an HTTP response from a LinearMergeWithResponse call
func ParseLinearMergeResponse(rsp *http.Response) (*LinearMergeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinearMergeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinearMergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseQueryTableResponse parses an HTTP response from a QueryTableWithResponse call
func ParseQueryTableResponse(rsp *http.Response) (*QueryTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryResponses
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRestoreTableResponse parses an HTTP response from a RestoreTableWithResponse call
func ParseRestoreTableResponse(rsp *http.Response) (*RestoreTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			Restore string `json:"restore,omitempty,omitzero"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSchemaResponse parses an HTTP response from a UpdateSchemaWithResponse call
func ParseUpdateSchemaResponse(rsp *http.Response) (*UpdateSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCommitTransactionResponse parses an HTTP response from a CommitTransactionWithResponse call
func ParseCommitTransactionResponse(rsp *http.Response) (*CommitTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionCommitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest TransactionCommitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Username string `json:"username,omitempty,omitzero"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Permissions []Permission `json:"permissions,omitempty,omitzero"`
			Username    string       `json:"username,omitempty,omitzero"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserByNameResponse parses an HTTP response from a GetUserByNameWithResponse call
func ParseGetUserByNameResponse(rsp *http.Response) (*GetUserByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserPasswordResponse parses an HTTP response from a UpdateUserPasswordWithResponse call
func ParseUpdateUserPasswordResponse(rsp *http.Response) (*UpdateUserPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemovePermissionFromUserResponse parses an HTTP response from a RemovePermissionFromUserWithResponse call
func ParseRemovePermissionFromUserResponse(rsp *http.Response) (*RemovePermissionFromUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePermissionFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserPermissionsResponse parses an HTTP response from a GetUserPermissionsWithResponse call
func ParseGetUserPermissionsResponse(rsp *http.Response) (*GetUserPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Permission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddPermissionToUserResponse parses an HTTP response from a AddPermissionToUserWithResponse call
func ParseAddPermissionToUserResponse(rsp *http.Response) (*AddPermissionToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPermissionToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"z2hGgyH+8vTL0/8LAAD//4u4Tfzm6QMA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
